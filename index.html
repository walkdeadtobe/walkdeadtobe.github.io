<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/29/基础知识/工具网站/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/29/基础知识/工具网站/" itemprop="url">工具网站</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-29T09:57:50+08:00">
                2020-08-29
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-08-30T13:25:24+08:00" content="2020-08-30">
                2020-08-30
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>latex：</p>
<ul>
<li><a href="https://www.overleaf.com/" target="_blank" rel="noopener">latex 在线编辑和导出</a></li>
<li><a href="https://www.tablesgenerator.com/latex_tables" target="_blank" rel="noopener">latex table在线编辑和转换</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/28/工作求职/数据库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/28/工作求职/数据库/" itemprop="url">数据库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-28T18:59:47+08:00">
                2020-08-28
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-08-30T13:22:36+08:00" content="2020-08-30">
                2020-08-30
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据库">数据库</h1>
<h2 id="reids">Reids</h2>
<h3 id="基础数据类型">基础数据类型：</h3>
<blockquote>
<p>string，hash，list，set及有序集合（每个元素都关联一个分数，通过分数排序）</p>
</blockquote>
<h3 id="redis持久化">Redis持久化：</h3>
<blockquote>
<p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失<br>
两种持久化方式:RDB（Redis DataBase；默认；定期备份；把内存中数据写到磁盘以及把文件读到内存；制定的时间间隔生成数据集的快） 和AOF(Append-only file;写入保存两个步骤；WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件 ；SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。持久化记录服务器执行的所有写命令到日志文件，并在服务器重启时，重新执行这些命令来恢复数据)</p>
<blockquote>
<p>两种区别就是，一个是持续的用日志记录写操作，crash后利用日志恢复；一个是平时写操作的时候不触发写，只有手动提交save命令，或者是关闭命令时，才触发备份操作。<br>
选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。</p>
</blockquote>
</blockquote>
<h3 id="过期策略定期删除惰性删除内存淘汰机制">过期策略：定期删除+惰性删除+内存淘汰机制</h3>
<blockquote>
<p>定期删除：redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除</p>
</blockquote>
<blockquote>
<p>惰性删除：当访问key时，检测key是否过期，过期则不返回</p>
</blockquote>
<blockquote>
<p>内存淘汰机制：当内存不足以写入新数据时，什么都不做，写入报错/移除随机key/移除最近最少使用的key/随机（或者选择最先过期 ）移除有过期时间的key/移除有过期的key中最近最少使用的/</p>
</blockquote>
<h3 id="redis的架构模式">Redis的架构模式</h3>
<blockquote>
<p>单机版（存储，处理有限，无法高可用）</p>
</blockquote>
<blockquote>
<p>主从复制（读写分离；更新同步；但是master写的压力存在，高可用不行）</p>
</blockquote>
<blockquote>
<p>哨兵（监控主从模式，遇到故障自动迁移；解决高可用，但master写仍存在）</p>
</blockquote>
<blockquote>
<p>集群（proxy 型）：利用哈希进行数据分布，分布到多个主从集群+哨兵</p>
</blockquote>
<blockquote>
<p>集群（直连型）：</p>
<blockquote>
<p>集群（直连型）:<a href="https://blog.csdn.net/z15732621582/article/details/79121213" target="_blank" rel="noopener">简介</a>  和 <a href="https://www.cnblogs.com/lpfuture/p/5796398.html" target="_blank" rel="noopener">一致性Hash算法</a><br>
Redis集群预分好16384个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中<br>
节点的fail是通过集群中超过半数的节点检测失效时才生效</p>
</blockquote>
</blockquote>
<h3 id="相关概念">相关概念</h3>
<h4 id="缓存雪崩">缓存雪崩</h4>
<blockquote>
<p>描述：大量相同过期时间的缓存，同时失效，导致大量的并发访问失败并访问磁盘；<br>
解决：使用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写</p>
</blockquote>
<h4 id="缓存穿透">缓存穿透</h4>
<blockquote>
<p>描述：用户在查询一个持久层数据库也没有的数据时，会出现缓存未命中，且访问持久层无果的情况，大量这种类型的访问会给持久层数据库带来很大压力<br>
解决：利用布隆过滤器判断对象是否一定不存在；缓存空对象</p>
</blockquote>
<h4 id="缓存击穿">缓存击穿</h4>
<blockquote>
<p>描述；指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞</p>
</blockquote>
<h4 id="缓存预热">缓存预热</h4>
<blockquote>
<p>描述：相关的缓存数据直接加载到缓存系</p>
</blockquote>
<h4 id="缓存更新">缓存更新</h4>
<blockquote>
<p>除了缓存失效策略（定义失效时间）外，还有定时去清理过期的缓存策略（判断是否失效）以及访问时才判断是否失效</p>
</blockquote>
<h4 id="缓存降级">缓存降级</h4>
<blockquote>
<p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级，保证核心服务可用</p>
</blockquote>
<h4 id="热点数据和冷数据">热点数据和冷数据：</h4>
<blockquote>
<p>频繁访问修改的数据称之为热点数据；冷数据指访问间隔很长的数据（出现只访问一次，就被挤出内存的情况）</p>
</blockquote>
<h4 id="单线程的redis为什么这么快">单线程的redis为什么这么快</h4>
<blockquote>
<p>(1)纯内存操作<br>
(2)单线程操作，避免了频繁的上下文切换<br>
(3)采用了非阻塞I/O多路复用机制</p>
</blockquote>
<h4 id="memcache-vs-redis">Memcache VS Redis</h4>
<blockquote>
<p>(1)存储方式 ：Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，redis可以持久化其数据<br><br>
(2)数据支持类型 memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 ，提供list，set，zset，hash等数据结构的存储<br><br>
(3)使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。<br><br>
(4)value 值大小不同：Redis 最大可以达到 512M；memcache 只有 1mb。<br><br>
(5)redis的速度比memcached快很多<br><br>
(6)Redis支持数据的备份，即master-slave模式的数据备份。<br><br>
Redis key和value的大小限制：512MB</p>
</blockquote>
<h4 id="redis数据库的数据一致性">Redis数据库的数据一致性</h4>
<blockquote>
<p>主从同步：从服务器启动，会向主服务器发起sync命令；主服务器收到后会在后台保存快照（RDB操作），并缓存保存期间的命令；结束后，会将快照和缓存命令传递给从数据库，从数据库接收到后，会载入快照并执行缓存命令；</p>
<p>哈希槽算法：与一致性哈希算法相似，一个节点根据其存储量，分为若干个槽</p>
<p>全量复制，增量复制，异步复制</p>
</blockquote>
<h4 id="哨兵模式"><a href="https://blog.csdn.net/sz85850597/article/details/86751215" target="_blank" rel="noopener">哨兵模式</a></h4>
<blockquote>
<p>主观下线-&gt;客观下线<br>
sential leader 选举：当每一个发现redis master 的sential节点都可以向其他节点发送选举信号，每个接收到该信号的节点如果没有投票，可以投它，当达到最低票数时，正式成为sential leader；否则进行下一轮；<br>
redis master 选举：由 sential leader 选择redis集群中的某个节点作为master</p>
<blockquote>
<p>a.排除故障节点</p>
</blockquote>
<blockquote>
<p>b.选择节点中slave-priority最大的从节点作为主节点</p>
</blockquote>
<blockquote>
<p>c.选择择复制偏移量（数据写入量的字节，记录写了多少数据。主服务器会把偏移量同步给从服务器，当主从的偏移量一致，则数据是完全同步）最大的从节点作为主节点</p>
</blockquote>
<blockquote>
<p>d.选择runid（redis每次启动的时候生成随机的runid作为redis的标识）最小的从节点作为主节点</p>
</blockquote>
</blockquote>
<h4 id="redis-集群选举">redis <a href="https://www.cnblogs.com/nijunyang/p/12508098.html" target="_blank" rel="noopener">集群选举</a></h4>
<blockquote>
<p>背景：利用hash桶算法进行数据的分隔布置到多个主从模式服务器去<br>
选举：slave发现master Fail之后，就尝试选举</p>
<blockquote>
<p>a.增加currentEpoch加1，并广播FAILOVER_AUTH_REQUEST信息</p>
</blockquote>
<blockquote>
<p>b.收到信息的Master节点会判断请求者的合法性，并发&gt;送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack</p>
</blockquote>
<blockquote>
<p>c.尝试failover的slave收集FAILOVER_AUTH_ACK;超过半数后变成新Master;广播Pong通知其他集群节点</p>
</blockquote>
</blockquote>
<h2 id="mysql">Mysql</h2>
<h3 id="事务的基本要素">事务的基本要素</h3>
<blockquote>
<p>原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。<br><br>
一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏。<br><br>
隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。<br><br>
持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚</p>
</blockquote>
<h3 id="事务的并发问题">事务的并发问题</h3>
<blockquote>
<p>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据<br><br>
不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。<br><br>
幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读.<br><br>
小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表<br></p>
</blockquote>
<h3 id="事物隔离级别">事物隔离级别</h3>
<table>
<thead>
<tr>
<th style="text-align:left">事务隔离级别</th>
<th style="text-align:right">脏读</th>
<th style="text-align:right">不可重复</th>
<th style="text-align:right">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">读未提交（read-uncommitted）</td>
<td style="text-align:right">是</td>
<td style="text-align:right">是</td>
<td style="text-align:right">是</td>
</tr>
<tr>
<td style="text-align:left">读未提交（read-uncommitted）</td>
<td style="text-align:right">否</td>
<td style="text-align:right">是</td>
<td style="text-align:right">是</td>
</tr>
<tr>
<td style="text-align:left">可重复读（默认，repeatable-read）</td>
<td style="text-align:right">否</td>
<td style="text-align:right">否</td>
<td style="text-align:right">是</td>
</tr>
<tr>
<td style="text-align:left">串行化（serializable）</td>
<td style="text-align:right">否</td>
<td style="text-align:right">否</td>
<td style="text-align:right">否</td>
</tr>
</tbody>
</table>
<h3 id="存储引擎">存储引擎</h3>
<blockquote>
<p>存储引擎是数据库管理系统用来从数据库创建、读取和更新数据的软件模块<br>
mysql5.5之后默认使用事务性存储引擎 InnoDB(这是MySQL 5.5或更高版本的默认存储引擎。它提供了事务安全(ACID兼容)表，支持外键引用完整性约束。它支持提交、回滚和紧急恢复功能来保护数据。它还支持行级锁定。当在多用户环境中使用时，它的“一致非锁定读取”提高了性能。它将数据存储在集群索引中，从而减少了基于主键的查询的I/O)</p>
</blockquote>
<h4 id="innodb">InnoDB</h4>
<blockquote>
<p>在 InnoDB 存储引擎中，所有的数据都被逻辑地存放在表空间中，表空间（tablespace）是存储引擎中最高的存储逻辑单位，在表空间的下面又包括段（segment）、区（extent）、页（page）<br><br>
MySQL 使用 InnoDB 存储表时，会将表的定义和数据索引等信息分开存储，其中前者存储在 .frm文件中，后者存储在 .ibd 文件中<br></p>
</blockquote>
<h3 id="索引">索引</h3>
<blockquote>
<p>索引优化是对查询性能优化的最有效手段<br>
InnoDB 存储引擎在绝大多数情况下使用 B+ 树建立索引，这是关系型数据库中查找最为常用和有效的索引</p>
</blockquote>
<blockquote>
<p>一张表一定包含一个聚集索引构成的 B+ 树以及若干辅助索引的构成的 B+ 树（辅助索引的存在并不会影响聚集索引，因为聚集索引构成的 B+ 树是数据实际存储的形式，而辅助索引只用于加速数据的查找，所以一张表上往往有多个辅助索引以此来提升数据库的性能。）</p>
</blockquote>
<h4 id="聚集索引-和-辅助索引">聚集索引  和  辅助索引</h4>
<blockquote>
<p>聚合索引可以理解为基于主键的索引，是实际存储的位置；而附注索引是对于其他键的索引，最终叶子节点内容为指向基于主键的索引；<br><br>
主键(指定主键或者选择费控的合适键或者隐藏键uuid)</p>
</blockquote>
<h3 id="数据库主从同步">数据库主从同步</h3>
<blockquote>
<p><a href="https://www.cnblogs.com/syncnavigator/p/10189597.html" target="_blank" rel="noopener">流程参考</a><br>
首先必须打开master端的binlog (mysql-bin.xxxxxx)日志功能，否则无法实现mysql的主从复制。因为mysql的整个主从复制过程实际上就是：slave端从 master端获取binlog日志，然后再在自己身上完全顺序的执行该日志中所记录的各种SQL操作</p>
<blockquote>
<p>1.master在执行sql之后，记录二进制log文件（bin-log）。<br>
2.slave连接master，并从master获取binlog，存于本地relay-log中，然后从上次记住的位置起执行SQL语句，一旦遇到错误则停止同步。</p>
</blockquote>
</blockquote>
<h3 id="主从复制的数据一致性">主从复制的数据一致性</h3>
<p><a href="https://www.jianshu.com/p/790a158d9eb3" target="_blank" rel="noopener">参考链接</a></p>
<blockquote>
<p>三种主从复制模式：异步复制、半同步复制、全同步复制<br>
异步复制:Mysql 默认同步模式,主库在执行完客户端提交的事物之后会直接将结果返回给客户端,不管 从库是否接收同步并成功处理,在这种情况下,主库如果crash掉,从库提升为主库,那么可能出现从库数据不完备的现象<br>
半同步复制:在前者的基础上要求 至少一个从库同步成功,才会将保存在binlog中的操作,提交到存储引擎,返回结果给客户端<br>
全同步复制:在异步复制的基础上,要求 所有从库 都同步成功,才真正执行事物，返回给客户端<br>
相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP/IP往返的时间。所以，半同步复制最好在低延时的网络中使用。<br>
半同步复制和全同步复制 可能会出现 从库执行成功而 主库 执行失败的情况，导致 数据不一致</p>
</blockquote>
<h3 id="mvcc">MVCC</h3>
<blockquote>
<p>待完善<br>
<a href="https://blog.csdn.net/weixin_41835916/article/details/81633072?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3" target="_blank" rel="noopener">参考博客1</a></p>
</blockquote>
<h3 id="最左匹配原则">最左匹配原则</h3>
<blockquote>
<p>索引的简历是从左开始的</p>
</blockquote>
<h3 id="myisam与innodb">MyISAM与InnoDB</h3>
<blockquote>
<p>1.对事务的的支持<br>
2.对外键的支持<br>
3.InnoDB是聚集索引（主索引存储数据文件，辅助索引指向主键），MyISAM 是非聚集索引（主键索引和辅助索引都指向文件指针）<br>
4.InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁<br>
5.InnoDB表必须有主键（用户没有指定的话会自己找或生产一个主键），而Myisam可以没有</p>
</blockquote>
<h3 id="postgresql-vs-mysql">PostgreSQL  VS MySQL</h3>
<blockquote>
<p>待完善</p>
</blockquote>
<h3 id="主键索引和唯一索引区别">主键索引和唯一索引区别</h3>
<blockquote>
<p>待完善</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/28/工作求职/面经收集/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/28/工作求职/面经收集/" itemprop="url">面经收集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-28T15:30:33+08:00">
                2020-08-28
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-08-30T13:22:36+08:00" content="2020-08-30">
                2020-08-30
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java 后台开发<br>
<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">Github 知识总结</a></p>
<ul>
<li><a href="https://www.nowcoder.com/discuss/491234?channel=1013&amp;source_id=home_feed" target="_blank" rel="noopener">美团一面</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/15/工作求职/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/15/工作求职/JVM/" itemprop="url">JVM</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-15T17:39:54+08:00">
                2020-08-15
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-08-30T13:24:40+08:00" content="2020-08-30">
                2020-08-30
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>JVM 内存</li>
</ol>
<ul>
<li>方法区：存放类运行时必须的结构信息,比如类的静态变量,常量,类的全局名称,方法信息,父类引用等如</li>
<li>堆：实际存储对象的地方,占据大量内存,主要GC对象,具体可以分为老年堆和年轻堆</li>
<li>虚拟机栈：每个线程都有一个自己独立的Java栈，每次线程执行到一个新的方法时就在栈里面压入一个栈帧。帧里包含了方法里的局部变量，操作数栈(数据运算)以及帧数据区。这三种区域中局部变量很好理解，就是在方法作用范围内的变量，包括基本变量和对象的引用</li>
<li>本地方法栈：调用系统提供的方法时,涉及的机制和数据</li>
<li>PC寄存器：线程运行时对于程序运行中的位置和状态的标识</li>
</ul>
<ol start="2">
<li>类加载/Class.forName</li>
</ol>
<ul>
<li>class文件记载到内,把字节码文件转换为二进制文件</li>
<li>在方法区中形成内部数据结构</li>
<li>验证类文件中数据合法性</li>
<li>初始化的过程（主要给静态变量和静态块初始化）</li>
</ul>
<ol start="3">
<li>实例化/newInstance</li>
</ol>
<ul>
<li>在堆中生成一个对象实例</li>
<li>对实例的内部变量初始化</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/21/工作求职/DataStructure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/21/工作求职/DataStructure/" itemprop="url">DataStructure</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-21T16:07:22+08:00">
                2020-07-21
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-08-30T13:25:49+08:00" content="2020-08-30">
                2020-08-30
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>算法概述</p>
<h2 id></h2>
<p>递归<br>
动态规划<br>
树</p>
<h3 id="其他">其他</h3>
<p><a href="https://www.cnblogs.com/jason2003/p/9676729.html" target="_blank" rel="noopener">线段树</a></p>
<blockquote>
<p>这个东西感觉挺有意思</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/21/基础知识/Algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/21/基础知识/Algorithm/" itemprop="url">Algorithm</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-21T16:07:22+08:00">
                2020-07-21
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-08-30T13:21:09+08:00" content="2020-08-30">
                2020-08-30
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>算法概述</p>
<h2 id></h2>
<p>递归<br>
动态规划</p>
<p>###并查集<br>
<a href="https://blog.csdn.net/qq_19782019/article/details/78916595" target="_blank" rel="noopener">size数组和rank数组</a><br>
题目:<a href="https://leetcode-cn.com/problems/number-of-islands" target="_blank" rel="noopener">leetcode 200</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/06/工作求职/剑指offer/1_面试的流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/06/工作求职/剑指offer/1_面试的流程/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-06T11:26:17+08:00">
                2020-07-06
              </time>
            

            

            
          </span>
          
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面试的流程">面试的流程</h1>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/06/工作求职/剑指offer/README/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/06/工作求职/剑指offer/README/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-06T11:26:17+08:00">
                2020-07-06
              </time>
            

            

            
          </span>
          
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="coding_interviews">Coding_Interviews</h1>
<p>本项目是对《剑指Offer——名企面试官精讲典型编程题（纪念版）》一书所做的笔记，以及书中67个编程题目的代码实现和解析。</p>
<p>全书共8章，因此，我的笔记也分为相应的8个章节，可以从以下目录进行快速访问：</p>
<ul>
<li><a href="https://github.com/familyld/Coding_Interviews/blob/master/01interview_process.md" target="_blank" rel="noopener">面试的流程</a></li>
<li><a href="https://github.com/familyld/Coding_Interviews/blob/master/02the_basics.md" target="_blank" rel="noopener">面试需要的基础知识</a></li>
<li><a href="https://github.com/familyld/Coding_Interviews/blob/master/03high_quality_code.md" target="_blank" rel="noopener">高质量的代码</a></li>
<li><a href="https://github.com/familyld/Coding_Interviews/blob/master/04approaches_to_solutions.md" target="_blank" rel="noopener">解决面试题的思路</a></li>
<li><a href="https://github.com/familyld/Coding_Interviews/blob/master/05optimization.md" target="_blank" rel="noopener">优化时间和空间效率</a></li>
<li><a href="https://github.com/familyld/Coding_Interviews/blob/master/06skills_for_interviews.md" target="_blank" rel="noopener">面试中的各项能力</a></li>
<li><a href="https://github.com/familyld/Coding_Interviews/blob/master/07interview_cases.md" target="_blank" rel="noopener">两个面试案例</a></li>
<li><a href="https://github.com/familyld/Coding_Interviews/blob/master/08additional_interview_questions.md" target="_blank" rel="noopener">英文版新增面试题</a></li>
</ul>
<p>笔记中会记录各章节的一些重点，各编程题的题目以及比较详细的思路解析。完整的代码会另外整理在C++文件夹和Python文件夹下。</p>
<p>除了原作者给出的C++实现（其中题目2用的是C#）之外，我还打算编写对应的Python实现，这是后话了。代码文件夹中的utilities文件夹包含通用的各种数据结构，以及一些对应的基本方法。</p>
<h2 id="内容简介">内容简介</h2>
<h3 id="面试的流程">面试的流程</h3>
<p>面试中每个环节需要注意的问题。</p>
<h3 id="面试需要的基础知识">面试需要的基础知识</h3>
<p>从编程语言、数据结构、算法三个方面总结程序员的面试知识点。</p>
<h3 id="高质量的代码">高质量的代码</h3>
<p>讨论影响代码质量的3个要素（规范性、完整性、鲁棒性），强调高质量代码除完成基本功能外，还能考虑特殊情况，并对非法输入进行合理处理。</p>
<h3 id="解决面试题的思路">解决面试题的思路</h3>
<p>总结编程面试中解决难题的有效思考模式，如在面试中遇到复杂难题，可以利用画图、举例和分解这3中方法将其化繁为简，先形成清晰思路再动手编程。</p>
<h3 id="优化时间和空间效率">优化时间和空间效率</h3>
<p>介绍优化时间效率和用空间换时间的常用算法。</p>
<h3 id="面试中的各项能力">面试中的各项能力</h3>
<p>总结应聘者如何充分表现学习和沟通能力，并通过具体面试题讨论如何培养知识迁移、抽象建模和发散思维能力。</p>
<h3 id="两个面试案例">两个面试案例</h3>
<p>总结哪些面试举动是不良行为，而哪些表现又是面试官所期待的行为。</p>
<h3 id="英文版新增面试题">英文版新增面试题</h3>
<p>优选久经欧美知名企业面试考验的经典题目，帮助国内读者开阔视野、增补技能。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/06/工作求职/剑指offer/7_两个面试案例/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/06/工作求职/剑指offer/7_两个面试案例/" itemprop="url">剑指offer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-06T11:11:41+08:00">
                2020-07-06
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-07-06T11:35:18+08:00" content="2020-07-06">
                2020-07-06
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="两个面试案例">两个面试案例</h1>
<h2 id="面试题49把字符串转换成整数">面试题49：把字符串转换成整数</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>写一个函数StrToInt，实现把字符串转换为整数这个功能。不能使用atoi或者其他类似的库函数。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>这条题看似简单，要把数字字符转为int型数值，只需要减去字符0就可以了。但是实际上这里有很多需要考虑的状况，这里简单地概括一下：</p>
<ol>
<li>能检测出非法的输入，包括空指针、空字符串、只有正号/负号没有数字、数字部分出现非数字字符。</li>
<li>输入非法时，依然能返回一个整数（比方说0），而且能和正常返回该整数的状况区别开来。因此还要设置一个全局标志位（atoi就是这样做的）。</li>
<li>字符串表示的数字超出int型的表示范围时，同样属于非法输入，程序能够检测到并做恰当的处理。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Status &#123;kValid = <span class="number">0</span>, kInvalid&#125;;</span><br><span class="line"><span class="comment">// 全局标志，输入无效字符串时函数返回0，该标志用于和输入字符串'0'作区分</span></span><br><span class="line"><span class="keyword">int</span> g_nStatus = kValid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_nStatus = kInvalid;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>; <span class="comment">// 使用long long来获取转换的数，然后再判断是否超出int型（发生溢出）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(str != <span class="literal">NULL</span> &amp;&amp; *str != <span class="string">'\0'</span>) <span class="comment">// 避免空指针和空字符串的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取出正负号，并移动到数字部分的第一位</span></span><br><span class="line">        <span class="comment">// 如果只有正负号没有数字则会移动到结束符'\0'，不会继续转换</span></span><br><span class="line">        <span class="keyword">bool</span> minus = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">'+'</span>)</span><br><span class="line">            str ++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*str == <span class="string">'-'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            str ++;</span><br><span class="line">            minus = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(*str != <span class="string">'\0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num = StrToIntCore(str, minus);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)num; <span class="comment">//记得最后要转换为int型返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">StrToIntCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* digit, <span class="keyword">bool</span> minus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*digit != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*digit &gt;= <span class="string">'0'</span> &amp;&amp; *digit &lt;= <span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> flag = minus ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">            num = num * <span class="number">10</span> + flag * (*digit - <span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否超出了int型的表示范围，也即发生溢出</span></span><br><span class="line">            <span class="keyword">if</span>((!minus &amp;&amp; num &gt; <span class="number">0x7FFFFFFF</span>)</span><br><span class="line">                || (minus &amp;&amp; num &lt; (<span class="keyword">signed</span> <span class="keyword">int</span>)<span class="number">0x80000000</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            digit++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 一旦遇到非数字字符，就退出并返回0</span></span><br><span class="line">        &#123;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功转换完成，把全局标志置为有效</span></span><br><span class="line">    <span class="keyword">if</span>(*digit == <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        g_nStatus = kValid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题50树中两个结点的最低公共祖先">面试题50：树中两个结点的最低公共祖先</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>输入两个树结点，求它们的最低公共祖先。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>这一题的题目其实故意没有说清楚，给定两个树节点，那么这是一棵怎样的树呢？数据结构的定义是怎样的呢？面试官希望我们能想到这些未曾提到的点，并做出反应。</p>
<p>如果这是一棵二叉搜索树，那找到两个结点的最低公共祖先很简单。我们从根结点开始遍历这棵树，如果当前结点比两个输入结点都大，那么两个输入结点必然都在当前结点的左子树上；如果当前结点比两个输入结点都小，那么两个输入结点必然都在当前结点的右子树上。当我们遍历到一个结点比其中一个输入结点大，比另外一个输入结点小，就找到两个输入结点的最低公共祖先了。因为从这个结点再往下，两个输入结点不会再出现在同一棵子树上了。</p>
<p>如果是一棵普通的树，但是每个结点有指向父结点的指针，我们把这棵树换个方向来看，其实这道题就变成了前面求两个链表的第一个共同结点的题目。</p>
<p>如果只是一棵普通的树，树结点定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                    m_nValue;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TreeNode*&gt;    m_vChildren;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个结点有个数不等的多个子结点，且只有指向子结点的指针。这时又应该怎样求解呢？</p>
<p>最笨的方法是从根结点开始遍历，逐个结点判断两个输入结点是否都在它的同一棵子树中，当到达一个结点，两个输入结点被分散在该结点的不同子树中时，该结点就是最低公共祖先。</p>
<p>这个方法效率不高，因为从上往下扫的过程中产生了相当多重复的查找。这里介绍一种借助辅助空间来减少时间复杂度的方法。</p>
<p>我们可以使用两个双向链表（list容器）来分别记录下到达两个结点的完整路径（基于前序遍历来获取），然后就可以把问题转化为求两个链表的第一个共同结点（把list最后一个元素作为链表第一个元素）了。这里因为我们可以直接得到链表头，所以这个问题又可以写作求两个链表的最后一个共同结点（从list.begin()开始）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历根结点为pRoot的树，找到pNode所在的路径，记录在path里面</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetNodePath</span><span class="params">(TreeNode* pRoot, TreeNode* pNode, <span class="built_in">list</span>&lt;TreeNode*&gt;&amp; path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == pNode)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    path.push_back(pRoot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历当前结点的所有子结点，直到找到pNode</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt;::iterator i = pRoot-&gt;m_vChildren.begin();</span><br><span class="line">    <span class="keyword">while</span>(!found &amp;&amp; i &lt; pRoot-&gt;m_vChildren.end())</span><br><span class="line">    &#123;</span><br><span class="line">        found = GetNodePath(*i, pNode, path);</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前路径无法到达pNode，从路径中移除当前结点，返回上一层</span></span><br><span class="line">    <span class="keyword">if</span>(!found)</span><br><span class="line">        path.pop_back();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取path1和path2两条路径的最后一个共同结点</span></span><br><span class="line">TreeNode* GetLastCommonNode</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">list</span>&lt;TreeNode*&gt;&amp; path1,</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">list</span>&lt;TreeNode*&gt;&amp; path2</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// const_iterator指向的对象是常量，即iterator指向常对象，</span></span><br><span class="line">    <span class="comment">// 迭代器本身指向可变，但它指向的对象的内容是const的。</span></span><br><span class="line">    <span class="built_in">list</span>&lt;TreeNode*&gt;::const_iterator iterator1 = path1.begin();</span><br><span class="line">    <span class="built_in">list</span>&lt;TreeNode*&gt;::const_iterator iterator2 = path2.begin();</span><br><span class="line"></span><br><span class="line">    TreeNode* pLast = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(iterator1 != path1.end() &amp;&amp; iterator2 != path2.end())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*iterator1 == *iterator2) <span class="comment">// 每次找到共同结点都会更新</span></span><br><span class="line">            pLast = *iterator1;</span><br><span class="line"></span><br><span class="line">        iterator1++;</span><br><span class="line">        iterator2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pLast;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">GetLastCommonParent</span><span class="params">(TreeNode* pRoot, TreeNode* pNode1, TreeNode* pNode2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span> || pNode1 == <span class="literal">NULL</span> || pNode2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先分别拿到路径</span></span><br><span class="line">    <span class="built_in">list</span>&lt;TreeNode*&gt; path1;</span><br><span class="line">    GetNodePath(pRoot, pNode1, path1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;TreeNode*&gt; path2;</span><br><span class="line">    GetNodePath(pRoot, pNode2, path2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再找路径的最后共同结点</span></span><br><span class="line">    <span class="keyword">return</span> GetLastCommonNode(path1, path2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/06/工作求职/剑指offer/6_面试中的各项能力/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/06/工作求职/剑指offer/6_面试中的各项能力/" itemprop="url">剑指offer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-06T11:11:41+08:00">
                2020-07-06
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-07-06T11:35:09+08:00" content="2020-07-06">
                2020-07-06
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面试中的各项能力">面试中的各项能力</h1>
<h2 id="面试题38数字在排序数组中出现的次数">面试题38：数字在排序数组中出现的次数</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>统计一个数字在排序数组中出现的次数。例如输入排序数组 <code>{1,2,3,3,3,3,4,5}</code> 和数字3，由于3在这个数组中出现了4次，因此输出4。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>最简单的方法就是顺序查找，然后计数了，这种方法的时间复杂度是O(n)。但是既然题目给定的是一个排序数组，那么就要充分利用好这个优势，我们可以基于<strong>二分查找</strong>来做。</p>
<p>具体来说我们使用二分查找的方式来分别找到输入数字第一次出现的索引和最后一次出现的索引，然后继续差值就是了。注意数字可能根本没有出现在数组中，这时应返回0。</p>
<p>实现很简单，修改一下递归二分查找的判定条件就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> length, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(data != <span class="literal">NULL</span> &amp;&amp; length &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> first = GetFirstK(data, length, k, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> last = GetLastK(data, length, k, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(first &gt; <span class="number">-1</span> &amp;&amp; last &gt; <span class="number">-1</span>)</span><br><span class="line">            number = last - first + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到数组中第一个k的下标。如果数组中不存在k，返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFirstK</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> length, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt; end)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> middleIndex = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> middleData = data[middleIndex];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(middleData == k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((middleIndex &gt; <span class="number">0</span> &amp;&amp; data[middleIndex - <span class="number">1</span>] != k)</span><br><span class="line">            || middleIndex == <span class="number">0</span>) <span class="comment">// 前面没有k了，或者当前索引为0没有更前面了</span></span><br><span class="line">            <span class="keyword">return</span> middleIndex;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 前面还有k，继续搜索前半段</span></span><br><span class="line">            end  = middleIndex - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(middleData &gt; k) <span class="comment">// 中位数大于k，继续搜索前半段</span></span><br><span class="line">        end = middleIndex - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>                    <span class="comment">// 中位数小于k，搜索后半段</span></span><br><span class="line">        start = middleIndex + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> GetFirstK(data, length, k, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到数组中最后一个k的下标。如果数组中不存在k，返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLastK</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> length, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt; end)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> middleIndex = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> middleData = data[middleIndex];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(middleData == k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((middleIndex &lt; length - <span class="number">1</span> &amp;&amp; data[middleIndex + <span class="number">1</span>] != k)</span><br><span class="line">            || middleIndex == length - <span class="number">1</span>) <span class="comment">// 后面没有k了，或者当前索引已是最后</span></span><br><span class="line">            <span class="keyword">return</span> middleIndex;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 后面还有k，继续搜索后半段</span></span><br><span class="line">            start  = middleIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(middleData &lt; k) <span class="comment">// 中位数小于k，继续搜索后半段</span></span><br><span class="line">        start = middleIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>                    <span class="comment">// 中位数大于k，搜索前半段</span></span><br><span class="line">        end = middleIndex - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> GetLastK(data, length, k, start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题39_1二叉树的深度">面试题39_1：二叉树的深度</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>输入一棵二叉树的根节点，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。二叉树结点的定义如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                    m_nValue;</span><br><span class="line">    BinaryTreeNode*        m_pLeft;</span><br><span class="line">    BinaryTreeNode*        m_pRight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解析">解析</h3>
<p>第一次看到这题，可能还有点迷茫，需要所有路径都走一次然后取最长路径的长度吗？并不是这样的，其实这题很简单，我们可以从另一个角度来理解树的深度：</p>
<ul>
<li>如果树只有一个根结点，则深度为1；</li>
<li>如果根结点只有左子树，则深度为左子树深度+1；</li>
<li>如果根结点只有右子树，则深度为右子树深度+1；</li>
<li>如果根结点既有左子树，又有右子树，则深度为左右子树深度的较大值+1；</li>
</ul>
<p>就是这么四种情况，我们可以非常容易地写出递归实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(BinaryTreeNode* pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nLeft = TreeDepth(pRoot-&gt;m_pLeft);</span><br><span class="line">    <span class="keyword">int</span> nRight = TreeDepth(pRoot-&gt;m_pRight);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (nLeft &gt; nRight) ? (nLeft + <span class="number">1</span>) : (nRight + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题39_2判断是否平衡二叉树">面试题39_2：判断是否平衡二叉树</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>输入一棵二叉树的根结点，判断该树是不是平衡二叉树。如果某二叉树中任意结点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>有了上一题的思路，我们很容易想到这一题可以逐个结点来判断是否平衡二叉树，也即对每个结点都检查左右子树的深度是否相差1，但是这个做法并不够好，因为它需要多次遍历同一结点，比如二叉树：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      <span class="number">10</span></span><br><span class="line">     /  \</span><br><span class="line">    <span class="number">7</span>    <span class="number">8</span></span><br><span class="line">   /    / \</span><br><span class="line">  <span class="number">5</span>    <span class="number">4</span>   <span class="number">3</span></span><br><span class="line"> /</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>我们在检查根结点10时，需要计算以7和8为根结点的左右子树的深度，按照递归的方式，我们需要先计算出以5，4，3为根结点的这几棵子树的深度。由于以7和8为根结点的左右子树的深度不超过1，所以继续检查。这时我们需要根结点7了，此时又需要再计算一次以5为根结点的子树的深度，所以说<strong>产生了重复计算，效率不高</strong>。</p>
<p>这里介绍一种只需要遍历每个结点1次的方法。在上面的方法中，我们是由上到下逐层检查，所以每次都需要对当前层下面的层计算一次。只要我们转换一下思路，<strong>由下往上逐层检查，并且把树深作为参数传递然后累加</strong>，就不需要作重复的计算了，所有结点都只需访问1次。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution2</span><span class="params">(BinaryTreeNode* pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> IsBalanced(pRoot, &amp;depth);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced</span><span class="params">(BinaryTreeNode* pRoot, <span class="keyword">int</span>* pDepth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *pDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">    <span class="keyword">if</span>(IsBalanced(pRoot-&gt;m_pLeft, &amp;left)</span><br><span class="line">        &amp;&amp; IsBalanced(pRoot-&gt;m_pRight, &amp;right))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = left - right;</span><br><span class="line">        <span class="keyword">if</span>(diff &lt;= <span class="number">1</span> &amp;&amp; diff &gt;= <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *pDepth = <span class="number">1</span> + (left &gt; right ? left : right);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题40数组中只出现一次的数字">面试题40：数组中只出现一次的数字</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>第一次看这条题，一点思路都没有，看书中给出的解法时真的被惊艳到了。</p>
<p>首先，我们要明白题目所说的<strong>只出现一次到底意味着什么</strong>？如果我们把题目换成只有一个出现一次的数字，可以怎么找出来呢？</p>
<p>这里利用的是<strong>异或的特性</strong>，<strong>两个相同的数异或结果为0，两个不同的数异或结果的二进制表示至少有一位为1</strong>。举个例子，比方说要在数组 <code>20,10,20,30,30</code> 中找出只出现一次的10，那么我们只需要求整个数组异或的结果就可以了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span> xor <span class="number">10</span> xor <span class="number">20</span> xor <span class="number">30</span> xor <span class="number">30</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>结果就是只出现一次的数字。</p>
<p>但数组中有两个只出现一次的数字，这要怎么找呢？</p>
<ol>
<li>首先对整个数组进行异或，所得结果就是那两个只出现一次的数的异或结果，因为这两个数字是不同的，所以结果的二进制表示至少有一位为1；</li>
<li>从异或结果的二进制表示中找到从右往左第一个为1的位置，它表明<strong>两个只出现一次的数字的二进制表示在这一位上是不同的</strong>；</li>
<li>按照步骤2中第一个为1的位置将数组分为两部分，一部分在该位置为1，另一部分在该位置为0；</li>
<li>因为同一个数字的二进制表示也是相同的，所以步骤3划分的数组中，同一个数字会被分到同一边，也即划分后，<strong>问题变成数组中只有一个出现一次的数字，其他数字都出现两次，如何找出那个只出现一次的数字</strong>。</li>
<li>分别对两个数组求异或结果，得到问题的解。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> length, <span class="keyword">int</span>* num1, <span class="keyword">int</span>* num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span> || length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对整个数组求异或结果</span></span><br><span class="line">    <span class="keyword">int</span> resultExclusiveOR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++ i)</span><br><span class="line">        resultExclusiveOR ^= data[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出异或结果二进制表示中第一个1出现的位置</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> indexOf1 = FindFirstBitIs1(resultExclusiveOR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照indexOf1划分数组并分别求异或结果（也即两个只出现一次的数字）</span></span><br><span class="line">    *num1 = *num2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(IsBit1(data[j], indexOf1))</span><br><span class="line">            *num1 ^= data[j];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *num2 ^= data[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到num从右边数起第一个是1的位</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">FindFirstBitIs1</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> indexBit = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 数字的二进制表示最右边为0，且当前位数不超过int型表示的范围（8*4bytes = 32bits）</span></span><br><span class="line">    <span class="keyword">while</span> (((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &amp;&amp; (indexBit &lt; <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        num = num &gt;&gt; <span class="number">1</span>; <span class="comment">//右移一位</span></span><br><span class="line">        ++ indexBit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> indexBit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断数字num的第indexBit位是不是1</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBit1</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">unsigned</span> <span class="keyword">int</span> indexBit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num = num &gt;&gt; indexBit;</span><br><span class="line">    <span class="keyword">return</span> (num &amp; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题41_1和为s的两个数字">面试题41_1：和为s的两个数字</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，输出任意一对即可。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>因为可以输出任意一对，所以只要找到一对就可以了。又因为这是一个递增数组，所以我们只需要维护两个指针behind和ahead，前者从数组开头（最小数字）开始往后扫描，后者从数组末尾（最大数字）开始往前扫描。每一次我们比较两个指针所指数字之和与s的大小关系，如果比s大，我们就往前移动ahead；如果比s小，我们就往后移动behind；如果和s相等，就进行输出。</p>
<p>这个算法的时间复杂度是O(n)，当ahead与behind相遇时，搜索就结束了，最多也只是扫描一次整个数组。如果数组中确实有和为s的一对数字，这个算法是必然能找到的。因为移动指针时，选择的指针和移动的方向都是必然的，并不需要ahead往后或者behind往前，因为外侧的数字都是已经排除掉，不可能构成指定的和的，这需要自己分析理解一下。</p>
<p>还是不偷懒了，简单举个例子吧… 比方说有数组 <code>1,2,4,7,11,15</code>，指定s为15。</p>
<ol>
<li><code>1+15=16 &gt; 15</code>，往前移动ahead，这很好理解，因为behind已经在最前了，自然不可能再往前移动它来减少和值；</li>
<li><code>1+11=12 &lt; 15</code>，往后移动behind。为什么不往后移动ahead呢？很简单，因为前面第一步已经验证了<code>1+15=16 &gt; 15</code>，正是因为这样才把ahead往前移的，自然就没有理由又把它移回去了；</li>
<li><code>2+11=13 &lt; 15</code>，往后移动behind。为什么不往后移动ahead呢？也很简单，因为比2小的1和15加起来都超过s了，那么2加上15的和就更大了，所以不可能往后移动ahead；</li>
<li><code>4+11=15 = 15</code>，找到了，完成查找。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> length, <span class="keyword">int</span> sum,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span>* num1, <span class="keyword">int</span>* num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">1</span> || num1 == <span class="literal">NULL</span> || num2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ahead = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> behind = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(ahead &gt; behind)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curSum = data[ahead] + data[behind];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(curSum == sum)</span><br><span class="line">        &#123;</span><br><span class="line">            *num1 = data[behind];</span><br><span class="line">            *num2 = data[ahead];</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(curSum &gt; sum)</span><br><span class="line">            ahead --;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            behind ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题41_2和为s的连续正数序列">面试题41_2：和为s的连续正数序列</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>输入一个正数s，打印出所有和为s的连续正数序列（至少会有两个数）。例如输入15，由于 <code>1+2+3+4+5 = 4+5+6 = 7+8 = 15</code>，所以结果打印出3个连续序列 <code>1~5</code>、<code>4~6</code>和<code>7~8</code>。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>首先审审题，这里不再给出数组，而是说找出<strong>连续正数数列</strong>，也即从 <code>1,2,3,4,.....</code> 这个正数序列中找。而所谓“序列”，指的是至少要包含两个数字。还有一点就是题目要求<strong>打印出所有</strong>符合要求的序列。</p>
<p>因为正数序列延伸到正无穷，我们自然没有办法说从序列最大值开始减少。我们转换一种思路，维护small和big两个指针来指向当前序列最小和最大的数，从和最小的序列开始找起，也即只包含两个整数的序列 <code>1,2</code>（small初始化为1，big初始化为2）。</p>
<ul>
<li>当前序列和小于s时，通过往后移动big来把新的数字补充进序列，使得序列的和能更接近s。</li>
<li>当前序列和大于s时，通过往后移动small来把小的数字丢掉，使得序列的和能更接近s。</li>
<li>当前序列和为s时，打印序列，并往后移动big来把新的数字补充进序列来打破平衡，使得small可以往后移动，从而有机会找到符合要求的新序列。</li>
</ul>
<p>注意了，什么时候停止移动呢？我们不难发现，当small大于 <code>(1 + s) / 2</code> 之后，任意两个数和都必定大于s，所以终止条件就是small大于等于 <code>(1 + s) / 2</code>。</p>
<p>还有一个小trick，计算序列和是一件挺麻烦的事（虽然可以用公式，但是乘除法还是开销蛮大的）。这里我们不需要这样做，因为新序列和旧序列只是相差一个元素而已。我们维护一个变量curSum，在删除/补充数字时，把curSum更新一下就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindContinuousSequence</span><span class="params">(<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum &lt; <span class="number">3</span>) <span class="comment">// 不存在和小于3的连续正数序列，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> small = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> big = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> middle = (<span class="number">1</span> + sum) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> curSum = small + big;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// small超过middle以后就不可能再有符合要求的序列产生了</span></span><br><span class="line">    <span class="comment">// 因为此后的任意两个数和都必定大于sum</span></span><br><span class="line">    <span class="keyword">while</span>(small &lt; middle)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(curSum == sum)</span><br><span class="line">            PrintContinuousSequence(small, big);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curSum &gt; sum &amp;&amp; small &lt; middle)</span><br><span class="line">        &#123;</span><br><span class="line">            curSum -= small;</span><br><span class="line">            small ++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curSum == sum)</span><br><span class="line">                PrintContinuousSequence(small, big);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加大big有两个意义</span></span><br><span class="line">        <span class="comment">// 一是curSum小于sum时补充序列，使得序列的和能更接近sum</span></span><br><span class="line">        <span class="comment">// 二是curSum等于sum时打破平衡，使得small可以往后移动，找到符合要求的新序列</span></span><br><span class="line">        big ++;</span><br><span class="line">        curSum += big;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintContinuousSequence</span><span class="params">(<span class="keyword">int</span> small, <span class="keyword">int</span> big)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = small; i &lt;= big; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题42_1翻转单词顺序">面试题42_1：翻转单词顺序</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串 <code>&quot;I am a student.&quot;</code>，则输出 <code>&quot;student. a am I&quot;</code>。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>这条题我们可以分为两步处理：</p>
<ol>
<li>翻转整个句子</li>
<li>以空格和结束符 <code>'\0'</code> 划分，逐个单词翻转</li>
</ol>
<p>写成代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 翻转两个字符指针之间的内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">char</span> *pBegin, <span class="keyword">char</span> *pEnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pBegin == <span class="literal">NULL</span> || pEnd == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pBegin &lt; pEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> temp = *pBegin;</span><br><span class="line">        *pBegin = *pEnd;</span><br><span class="line">        *pEnd = temp;</span><br><span class="line"></span><br><span class="line">        pBegin ++, pEnd --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">ReverseSentence</span><span class="params">(<span class="keyword">char</span> *pData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pData == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *pBegin = pData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *pEnd = pData;</span><br><span class="line">    <span class="keyword">while</span>(*pEnd != <span class="string">'\0'</span>)</span><br><span class="line">        pEnd ++;</span><br><span class="line">    pEnd--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 翻转整个句子</span></span><br><span class="line">    Reverse(pBegin, pEnd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 翻转句子中的每个单词</span></span><br><span class="line">    pBegin = pEnd = pData;</span><br><span class="line">    <span class="keyword">while</span>(*pBegin != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*pBegin == <span class="string">' '</span>) <span class="comment">// 处理连续空格，末字符为空格的情形</span></span><br><span class="line">        &#123;</span><br><span class="line">            pBegin ++;</span><br><span class="line">            pEnd ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*pEnd == <span class="string">' '</span> || *pEnd == <span class="string">'\0'</span>) <span class="comment">// 找到了划分单词的地方</span></span><br><span class="line">        &#123;</span><br><span class="line">            Reverse(pBegin, --pEnd); <span class="comment">// 翻转整个单词</span></span><br><span class="line">            pBegin = ++pEnd;         <span class="comment">// 令pBegin跳到下一个单词的开头</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pEnd ++; <span class="comment">// 单词未结束，继续找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题42_2左旋转字符串">面试题42_2：左旋转字符串</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如输入字符串 <code>&quot;abcdefg&quot;</code> 和数字2，该函数将返回左旋转2位得到的结果 <code>&quot;cdefgab&quot;</code>。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>这题很有意思，我们先再分析一下上一题翻转单词顺序，比方说有一个句子 <code>Hello world</code>，上一题就是把这个句子处理为 <code>world Hello</code>。不看空格的话，这实际上可以看作是把一部分字符转移到字符串的尾部，也即对这个字符串左旋了5位。</p>
<p>有了这样的启发，不难发现，我们可以先按左旋的位数把数组分割为两部分，然后分别翻转这两部分，最后翻转整个数组就完成左旋转这个操作了。</p>
<p>书中给出的代码是按照这样的思路实现的，和上一题有一点点差别，因为上一题是先翻转整个字符串，再分别翻转各个部分。这个顺序调转一下其实也是可以的，这里先翻转部分，再翻转整体的原因是先翻转整体之后，左旋位数所指的位置就不是划分两个部分的地方了。</p>
<p>还是举个例子吧~避免自己再看到的时候会懵圈。还是 <code>helloworld</code>，左旋2位，那么划分两部分的位置就在e和l之间，正确答案是 <code>lloworldhe</code>。</p>
<ul>
<li>
<p>如果先翻转整个字符串，字符串变为 <code>dlrowolleh</code>，2指向的地方就变成了l和r之间了，根据这个划分来翻转部分得到的是错误答案 <code>ldhellowor</code>。当然，其实真要算出正确的划分位置也不难…就是字符串长度10-左旋位数2=8嘛…可以解出答案 <code>lloworldhe</code>，所以还是可以正确划分的，改改就好了。</p>
</li>
<li>
<p>如果先翻转部分，按左旋位数2划分出两个部分，分别翻转后，字符串变为 <code>ehdlrowoll</code>，这时再翻转整个字符串，就得到了正确答案 <code>lloworldhe</code>。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 翻转两个字符指针之间的内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">char</span> *pBegin, <span class="keyword">char</span> *pEnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pBegin == <span class="literal">NULL</span> || pEnd == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pBegin &lt; pEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> temp = *pBegin;</span><br><span class="line">        *pBegin = *pEnd;</span><br><span class="line">        *pEnd = temp;</span><br><span class="line"></span><br><span class="line">        pBegin ++, pEnd --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">LeftRotateString</span><span class="params">(<span class="keyword">char</span>* pStr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pStr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nLength = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">strlen</span>(pStr));</span><br><span class="line">        <span class="keyword">if</span>(nLength &gt; <span class="number">0</span> &amp;&amp; n &gt; <span class="number">0</span> &amp;&amp; n &lt; nLength)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span>* pFirstStart = pStr;</span><br><span class="line">            <span class="keyword">char</span>* pFirstEnd = pStr + n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span>* pSecondStart = pStr + n;</span><br><span class="line">            <span class="keyword">char</span>* pSecondEnd = pStr + nLength - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 翻转字符串的前面n个字符</span></span><br><span class="line">            Reverse(pFirstStart, pFirstEnd);</span><br><span class="line">            <span class="comment">// 翻转字符串的后面部分</span></span><br><span class="line">            Reverse(pSecondStart, pSecondEnd);</span><br><span class="line">            <span class="comment">// 翻转整个字符串</span></span><br><span class="line">            Reverse(pFirstStart, pSecondEnd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题43n个骰子的点数">面试题43：n个骰子的点数</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>n个骰子朝上一面的点数之和最小是n，最大是6n，一共有6n-n+1种可能。而n个骰子中每个骰子在一次投掷中可能的取值都为1~6，因此将它们的点数排成序列的话有6^n种不同的排列组合。</p>
<p>最简单的做法是使用递归来把这6^n种排列组合都试一次，每次排列完毕得到和值就在计数数组中为这个和值对应的计数加一。最后把计数数组每个计数除以6^n就得到出现的概率了。</p>
<p>上面这种做法的代码实现比较简单，但是当n变大时，递归实现的效率会变得相当低。<strong>因为这种做法其实有很多重复的计算</strong>，怎么理解呢？举个例子，假设加入一个新骰子时，我们想计算得到和为s的次数，它实际上等于和为s-1，s-2，s-3，s-4，s-5，s-6的次数的和，因为新骰子为和值贡献的只可能是1~6中的一个。如果按照递归的思路，我们要从第一个骰子开始算；但如果我们能保证和值生成的顺序就能有效地利用之前计算出的结果，从而把重复计算节省下来。</p>
<p>具体来说，代码实现的时候还是有不少需要注意的地方。可以简单分为以下几点：</p>
<ol>
<li>
<p><strong>新加入骰子能产生的和值和未加入之前可能会有重叠</strong>，比方说一个骰子时和值可以取2，两个骰子时和值也可以取2，那么怎样去更新和值的计数呢？要注意！新加入骰子后和值为3是基于未加入前和值为1和2的计数来计算的，如果我们把和值为2的计数更新为加入新骰子的情况，然后再计算和值为3的计数就会得到了错误的结果；</p>
</li>
<li>
<p>计数数组需要初始化，只有第一个骰子加入后才可以使用上面提到的形式来计算和值的出现次数；</p>
</li>
<li>
<p>并不是每一个和值s都可以分拆为s-1，s-2，s-3，s-4，s-5，s-6这六项，比如和值为3就只可分拆为和值为2（即s-1）以及1（即s-2）这两项；</p>
</li>
<li>
<p>新加入骰子可能会令和值的出现次数为0，比方说加入第二个骰子时，和的最小值变为2，此时和值1的出现次数就要更新为0了。</p>
</li>
</ol>
<p>这里第1点比较重要，为了不会发生更新覆盖导致错误结果的情况，我们不妨<strong>使用两个数组来存储和值的计数</strong>。可以看代码注释加深理解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintProbability_Solution2</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number &lt; <span class="number">1</span>) <span class="comment">// 至少也要有1个骰子</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用两个数组来存储和值的计数</span></span><br><span class="line">    <span class="keyword">int</span>* pProbabilities[<span class="number">2</span>];</span><br><span class="line">    pProbabilities[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[g_maxValue * number + <span class="number">1</span>];</span><br><span class="line">    pProbabilities[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[g_maxValue * number + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数数组初始化为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g_maxValue * number + <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pProbabilities[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        pProbabilities[<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">// 用于标志使用哪一个计数数组</span></span><br><span class="line">    <span class="comment">// 加入第一个骰子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g_maxValue; ++i)</span><br><span class="line">        pProbabilities[flag][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次加入其它骰子，k为当前骰子数目</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= number; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 加入第k个骰子时，最小值更新为k，所以和值 `0~k-1` 的出现次数变为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">            pProbabilities[<span class="number">1</span> - flag][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加入第k个骰子时，产生的和值范围是[k, 6*k]，依次计算出它们的出现次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= g_maxValue * k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pProbabilities[<span class="number">1</span> - flag][i] = <span class="number">0</span>; <span class="comment">//初始化为0</span></span><br><span class="line">            <span class="comment">// 分拆和值，注意不是所有和值都能分拆出6项，所以要设置j&lt;=i。</span></span><br><span class="line">            <span class="comment">// 特别注意j=i这种状况，可以举例分析一下</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i &amp;&amp; j &lt;= g_maxValue; ++j)</span><br><span class="line">                pProbabilities[<span class="number">1</span> - flag][i] += pProbabilities[flag][i - j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 改变标志位，使加入新骰子后计数不会覆盖未加入前的结果</span></span><br><span class="line">        flag = <span class="number">1</span> - flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> total = <span class="built_in">pow</span>((<span class="keyword">double</span>)g_maxValue, number);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = number; i &lt;= g_maxValue * number; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> ratio = (<span class="keyword">double</span>)pProbabilities[flag][i] / total;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: %e\n"</span>, i, ratio);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] pProbabilities[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] pProbabilities[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能有人还会疑惑，使用两个数组来计数，那最后输出那个数组是否就包含了所有和值的计数呢？会不会有遗漏呢？其实，确实是包含了全部的，因为每次用于赋值的那个计数数组，计数都包含了和值0~加入新骰子后的最大和值，没有遗漏。另外，我们最后输出应该用什么标志位也应该很清楚，应该使用对应于最后一次用于赋值的数组的那个标志位。</p>
<h2 id="面试题44扑克牌的顺子">面试题44：扑克牌的顺子</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2~10为数字本身，A为1，J为11，Q为12，K为13，而大、小王可以看成任意数字。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>这题还挺有意思的，在转换为计算机语言时，手牌其实就是一个数组，为了方便，不妨把大、小王先看作数字0。要判断是否顺子，我们可以先对数组排序，然后分别统计以下0的数目，以及需要填补的间隔大小。最后判断间隔能否被填补好就可以了。</p>
<p>在数组排序这一步，书中给出的是使用qsort快排函数以及自定义的比较函数实现O(n logn)d的排序，我们也可以基于哈希表来实现O(n)的排序。不过鉴于n的规模并不大，所以这两种排序算法相差不大。基于O(n)的排序可以看一下这篇文章：<a href="http://www.cnblogs.com/hellogiser/p/sort-ages-with-hashtable.html" target="_blank" rel="noopener">特殊的O(n)时间排序[sort ages with hashtable]</a>。其实就是先扫一遍数组用哈希表计数，然后扫一遍哈希表重排数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个参数分别是手牌和手牌数（题目中是5 ）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsContinuous</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">NULL</span> || length &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    qsort(numbers, length, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), compare);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numberOfZero = <span class="number">0</span>; <span class="comment">// 大、小王的张数</span></span><br><span class="line">    <span class="keyword">int</span> numberOfGap = <span class="number">0</span>;  <span class="comment">// 需要填补的牌数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计数组中0的个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length &amp;&amp; numbers[i] == <span class="number">0</span>; ++i)</span><br><span class="line">        ++ numberOfZero;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计数组中的间隔数目</span></span><br><span class="line">    <span class="keyword">int</span> small = numberOfZero;</span><br><span class="line">    <span class="keyword">int</span> big = small + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(big &lt; length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 两个数相等，有对子，不可能是顺子</span></span><br><span class="line">        <span class="keyword">if</span>(numbers[small] == numbers[big])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个数不等，计算间隔，两张牌相差1也即相邻时间隔为0</span></span><br><span class="line">        numberOfGap += numbers[big] - numbers[small] - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 继续比较下两张牌</span></span><br><span class="line">        small = big;</span><br><span class="line">        ++big;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若大、小王能把间隔都填补上或者不需要填补间隔就会返回true</span></span><br><span class="line">    <span class="keyword">return</span> (numberOfGap &gt; numberOfZero) ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *arg1, <span class="keyword">const</span> <span class="keyword">void</span> *arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> *(<span class="keyword">int</span>*)arg1 - *(<span class="keyword">int</span>*)arg2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题45圆圈中最后剩下的数字">面试题45：圆圈中最后剩下的数字</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p><code>0,1,...,n-1</code> 这n个数字排成一个圆圈，从数字0开始每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>最简单的做法，用一个环形链表来模拟就好了，每走m-1步删除一个元素，若干轮后就能得到最后一个数字了。在c++中，我们可以用标准库提供的list容器来实现，list是双向循环链表，插入删除等操作都封装好了，使用很方便。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法1====================</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化环形链表</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; numbers;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        numbers.push_back(i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator current = numbers.begin();</span><br><span class="line">    <span class="keyword">while</span>(numbers.size() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++ i)</span><br><span class="line">        &#123;<span class="comment">// 先走m-1步，找到这一轮的第m个数</span></span><br><span class="line">            current ++;</span><br><span class="line">            <span class="comment">// 如果到底了尾部就返回头部，保证环形链表的遍历顺序</span></span><br><span class="line">            <span class="comment">// 注意list.end()指向的是最后一个元素后面的一个位置</span></span><br><span class="line">            <span class="keyword">if</span>(current == numbers.end())</span><br><span class="line">                current = numbers.begin();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记住这一轮第m+1个数的位置</span></span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator next = ++ current;</span><br><span class="line">        <span class="keyword">if</span>(next == numbers.end())</span><br><span class="line">            next = numbers.begin();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除这一轮的第m个数</span></span><br><span class="line">        -- current;</span><br><span class="line">        numbers.erase(current);</span><br><span class="line">        current = next; <span class="comment">// 从第m+1个数开始新的一轮</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意的就是我们使用迭代器来遍历数组，其实就是用一个指针来走list上的结点，走到list.end()就证明已经到达最后了，此时指向的不是最后一个元素（我猜指的应该是NULL），我们需要把迭代器移动回链表头。</p>
<p>另外，在删除时，其实是把指针指向的内存空间释放掉，封装好的erase函数会帮我们把断开的链表接好，但是我们还是需要用一个指针预先记住下一个数的位置，不能删除之后就找不到它了。</p>
<p>假设链表长为n，每m个数删除一个，那么上面的解法复杂度就是O(mn)，因为每删除一个数字都要经历m个操作。而且这种解法还要借助一个O(n)的环形链表来辅助。有没有更好的方法呢？</p>
<p>这里给出一种时间复杂度为O(n)，空间复杂度为O(1)的解法。</p>
<hr>
<p>给定n，把数列 <code>0,1,2,3,...,n-2,n-1</code> 这n个数字围成一圈，从0开始走，每次删除第m个数字，求最后剩下的数字。那么第一个被删除的数字就是 <code>(m-1)%n</code>。</p>
<p>为了方便，先把数字 <code>(m-1)%n</code> 记为k，删除k以后数列剩下n-1个数字。在下一轮中，k+1成为第一个被遍历的数字，k-1则成为最后一个。我们不妨做个映射p：<code>p(x) = (x-k-1)%n</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">k+<span class="number">1</span> -&gt; <span class="number">0</span></span><br><span class="line">k+<span class="number">2</span> -&gt; <span class="number">1</span></span><br><span class="line">...</span><br><span class="line">n<span class="number">-1</span> -&gt; n-k<span class="number">-2</span></span><br><span class="line"><span class="number">0</span>   -&gt; n-k<span class="number">-1</span></span><br><span class="line"><span class="number">1</span>   -&gt; n-k</span><br><span class="line">...</span><br><span class="line">k<span class="number">-2</span> -&gt; n<span class="number">-3</span></span><br><span class="line">k<span class="number">-1</span> -&gt; n<span class="number">-2</span></span><br></pre></td></tr></table></figure>
<p>此时，问题变为了： 给定n-1，把数列 <code>0,1,2,3,...,n-3,n-2</code> 这n-1个数字围成一圈，从0开始走，每次删除第m个数字，求最后剩下的数字。也即<strong>映射后，问题变为了相同的形式</strong>！这样我们就可以很简单地利用递归或者循环来求解了！</p>
<p>进一步分析一下，假设原问题的解是 <code>f(n,m)</code>，映射后问题的解是 <code>f(n-1,m)</code>，我们只要<strong>对映射后问题的解进行逆映射就能得到和原文题同样的解</strong>！也即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n,m) = p^(<span class="number">-1</span>)[f(n<span class="number">-1</span>,m)]</span><br></pre></td></tr></table></figure>
<p>其中逆映射 <code>p^(-1)(x) = (x+k+1)%n</code>。而且有 <code>k=(m-1)%n</code>，因此：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(n,m) = p^(<span class="number">-1</span>)[f(n<span class="number">-1</span>,m)]</span><br><span class="line">       = [f(n<span class="number">-1</span>,m)+(m<span class="number">-1</span>)%n+<span class="number">1</span>]%n</span><br><span class="line">       = [f(n<span class="number">-1</span>,m)+m]%n</span><br></pre></td></tr></table></figure>
<p>得到通项公式后，我们可以基于循环来实现，注意初项的设置（即n为1时问题的解）：</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法2====================</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>; <span class="comment">// 当n为1，数列中只有0，问题的解就是0</span></span><br><span class="line">    <span class="comment">// 从长度为1的数列开始算，i=数列长度+1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)</span><br><span class="line">        last = (last + m) % i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题46求12n">面试题46：求1+2+…+n</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>求 <code>1+2+...+n</code>，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（<code>A?B:C</code>）。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>这题目不属于数据结构和算法的范畴，我不是太关心，它更偏向于对C++语言特性的考查。不过其他编程语言也有共性，所以这里还是简单地进行一下解析。</p>
<p>方法一借助构造函数和静态变量求解，把累加逻辑隐藏在构造函数中，然后创建n个实例来达到累加的目的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法一====================</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Temp() &#123; ++ N; Sum += N; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123; N = <span class="number">0</span>; Sum = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">GetSum</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Sum; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> Sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> Temp::N = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> Temp::Sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Sum_Solution1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Temp::Reset();</span><br><span class="line"></span><br><span class="line">    Temp *a = <span class="keyword">new</span> Temp[n];</span><br><span class="line">    <span class="keyword">delete</span> []a;</span><br><span class="line">    a = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Temp::GetSum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二借助两个虚函数实现递归功能，类A的Sum用于终止条件，类B的Sum用于不断累加和递归：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法二====================</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line">A* Array[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Sum</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Sum</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// n是数值变量，!!n可以把它转换为布尔类型，非零-&gt;true，0-&gt;false</span></span><br><span class="line">        <span class="comment">// 所以当n未到0时，会调用类B的Sum累加，这就类似递归的逻辑</span></span><br><span class="line">        <span class="comment">// 最后n减至0时调用类A返回0，终止递归。</span></span><br><span class="line">        <span class="keyword">return</span> Array[!!n]-&gt;Sum(n<span class="number">-1</span>) + n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    Array[<span class="number">0</span>] = &amp;a;</span><br><span class="line">    Array[<span class="number">1</span>] = &amp;b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> value = Array[<span class="number">1</span>]-&gt;Sum(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法三与二的思路是类似的，在纯C环境中没有虚函数，可以用函数指针来模拟：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法三====================</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*fun)</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Solution3_Teminator</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Sum_Solution3</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> fun f[<span class="number">2</span>] = &#123;Solution3_Teminator, Sum_Solution3&#125;;</span><br><span class="line">    <span class="keyword">return</span> n + f[!!n](n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法四也是模拟递归，但借助的是模版类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法四====================</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">unsigned</span> <span class="keyword">int</span> n&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Sum_Solution4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> Value &#123; N = Sum_Solution4&lt;n - <span class="number">1</span>&gt;::N + n&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Sum_Solution4</span>&lt;1&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> Value &#123; N = <span class="number">1</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Sum_Solution4</span>&lt;0&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> Value &#123; N = <span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="面试题47不用加减乘除做加法">面试题47：不用加减乘除做加法</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、×、÷四则运算符号。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>不能用四则运算符号，那么剩下的选择就是位运算了。<strong>怎么用位运算模拟加法</strong>呢？</p>
<p>我们先不急着分析基于二进制的位运算，从十进制的角度来看，加法可以怎样分解呢？不妨举个例子，计算 <code>915+87</code>：</p>
<ol>
<li>首先不管进位，对915和87逐位相加，百位9+0=9，十位1+8=9，个位5+7=2（不管进位）；</li>
<li>然后我们处理进位1，它由个位产生，我们需要把它<strong>左移</strong>一位，加到十位上，十位9+1=0（不管进位）；</li>
<li>因为还是有进位，所以要继续处理。这次进位1由十位产生，我们同样把它左移一位，加到百位上，百位9+1=0（不管进位）；</li>
<li>因为还是有进位，所以要继续处理。这次进位1由百位产生，我们同样把它左移一位，加到千位上，千位0+1=1；</li>
<li>没有进位，结束运算，得到结果1002。</li>
</ol>
<p>简单来说，<strong>每一次加法可以分成（1）不管进位相加、（2）获得进位 和 （3）处理进位 这三步</strong>，其中第三步其实又是一次加法，所以其实是重复第一步和第二步，直到第二步获得的进位为0，也即不需再进位时结束。还有注意一点，上面例子中每次加法只有一个进位，实际上可能有多个进位，这时流程也是一样的。</p>
<p>好了，有了以上分析，在使用位运算模拟时怎么做呢？</p>
<p>首先看步骤1，不管进位相加，那么对应二进制就是 <code>1和0得1</code>，<code>0和1得1</code>，<code>0和0得0</code>，<code>1和1得0</code>。是的，这一步对应于<strong>异或操作</strong>。</p>
<p>然后看步骤2，怎么获得进位，并且把它们放在正确的位置上呢？其实很简单，因为二进制只有两个数字这一位都是1才会进位，所以我们可以<strong>用位与获得产生进位的位置</strong>，注意了，<strong>产生进位的位置和进位要作用到的位置是不同的</strong>，所以还要对位与结果<strong>左移一位</strong>。</p>
<p>最后我们判断一下步骤2获得的进位是否为0，为0就结束；不为0就继续对步骤1和步骤2的结果做加法，也即继续重复步骤1和步骤2。</p>
<p>写成代码也非常简洁：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum, carry;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum = num1 ^ num2;</span><br><span class="line">        carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        num1 = sum;</span><br><span class="line">        num2 = carry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(num2 != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题48不能被继承的类">面试题48：不能被继承的类</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>用C++设计一个不能被继承的类。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>这题目也不属于数据结构和算法的范畴，我不是太关心，更偏向于对C++对象设计语法的考查。</p>
<p>方法一把构造函数设为私有函数，当别的类试图继承它时，会自动调用它的构造函数和析构函数，从而导致编译出错。因此这样设计的类是无法被继承的。我们可以通过一个公有函数来获取它的实例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法一====================</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SealedClass1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> SealedClass1* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SealedClass1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeleteInstance</span><span class="params">( SealedClass1* pInstance)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> pInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SealedClass1() &#123;&#125;</span><br><span class="line">    ~SealedClass1() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二利用虚拟继承和友元类型，就不详细解释了。想要深入探究的话自己查找资料就好了~</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法二====================</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">MakeSealed</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MakeSealed() &#123;&#125;</span><br><span class="line">    ~MakeSealed() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SealedClass2</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> MakeSealed&lt;SealedClass2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SealedClass2() &#123;&#125;</span><br><span class="line">    ~SealedClass2() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">chengr</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">87</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">48</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chengr</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
