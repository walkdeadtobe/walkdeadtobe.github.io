<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2020/07/06/%E5%89%91%E6%8C%87offer/1_%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/07/06/%E5%89%91%E6%8C%87offer/1_%E9%9D%A2%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="面试的流程">面试的流程</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer</title>
      <link href="/2020/07/06/%E5%89%91%E6%8C%87offer/8_%E8%8B%B1%E6%96%87%E7%89%88%E6%96%B0%E5%A2%9E%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/07/06/%E5%89%91%E6%8C%87offer/8_%E8%8B%B1%E6%96%87%E7%89%88%E6%96%B0%E5%A2%9E%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="英文版新增面试题">英文版新增面试题</h1><h2 id="面试题51数组中重复的数字">面试题51：数组中重复的数字</h2><h3 id="题目">题目</h3><blockquote><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组 <code>{2,3,1,0,2,5,3}</code>，那么对应的输出是重复的数字2或者3。</p></blockquote><h3 id="解析">解析</h3><p>这里介绍一个复杂度O(n)的方法，思想和借助哈希表排序类似，但是由于题目给了非常棒的前提条件，在<strong>长度为n</strong>的数组里的<strong>所有数字都在0到n-1的范围内</strong>，如果没有重复元素，那么必定每个数字都能被放入自己对应的位置上，我们不需要额外的辅助内容。</p><p>具体来说，我们依次遍历数组，当数字i不在位置i上时，把它交换到位置i上；如果发现位置i上的数等于数字i，就说明找到重复元素了。</p><p>为什么这种方法遍历一次数组必然就能找到重复元素呢？因为如果存在两个重复数字，那么在把前面那一个放到正确位置上后，遍历到后面那一个时会再一次检查到这个位置，此时必然能发现数字的重复。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span>) <span class="comment">// 合法性检验</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)    <span class="comment">// 合法性检验</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] &lt; <span class="number">0</span> || numbers[i] &gt; length - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(numbers[i] != i) <span class="comment">// 如果数字已经和序号一致就不用处理了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果发现数字和对应位置上的数相等，就说明已经找到重复元素了</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == numbers[numbers[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                *duplication = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果不相等，就把数字交换到它正确的位置上</span></span><br><span class="line">            <span class="keyword">int</span> temp = numbers[i];</span><br><span class="line">            numbers[i] = numbers[temp];</span><br><span class="line">            numbers[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题52构建乘积数组">面试题52：构建乘积数组</h2><h3 id="题目">题目</h3><blockquote><p>给定一个数组 <code>A[0,1,...,n-1]</code>，请构建一个数组 <code>B[0,1,...,n-1]</code>，其中B中的元素 <code>B[i] = A[0] × A[1] × ... × A[i-1] × A[i+1] × ... × A[n-1]</code>。不能使用除法。</p></blockquote><h3 id="解析">解析</h3><p>一定要看清楚题目，这题要求数组B的每一个元素B[i]等于数组A除A[i]以外所有元素的积。</p><p>不能用除法，但是我们不妨从另外一个角度去想这个问题。<strong>B[i]根据i的位置可以划分为两部分来求解</strong>，它等于数组A中位置i之前的元素之积 * 数组A中位置i之后的元素之积。可以画出下图这样的矩阵：</p><p><img src="https://github.com/familyld/Coding_Interviews/blob/master/graph/52_ArrayConstruction.jpg?raw=true" alt="matrix"></p><p>矩阵第i行对应着B[i]乘积的各个因子，其中位置i用1来代替。按照上面说的那样，我们可以把B[i]分成两部分，假设B[i] = C[i] * D[i]。那么C就对应着数组A中位置i之前的元素之积，D就对应着数组A中位置i之后的元素之积（1同时算入C和D中）。</p><p>我们可以从上往下计算出C[i]，初始化 <code>C[0] = 1</code>，有通项公式 <code>C[i] = C[i-1] *A[i]</code>;</p><p>我们可以从下往上计算出D[i]，初始化 <code>D[n-1] = 1</code>，有通项公式 <code>D[i] = D[i+1] *A[i+1]</code>;</p><p>写成代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; array1, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; array2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length1= array1.size();</span><br><span class="line">    <span class="keyword">int</span> length2 = array2.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有两数组长度相等，且数组长度大于1才是合法输入</span></span><br><span class="line">    <span class="keyword">if</span>(length1 == length2 &amp;&amp; length2 &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        array2[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 初始化C[0]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length1; ++i)</span><br><span class="line">        &#123;   <span class="comment">// 对应从上往下计算出C[i]</span></span><br><span class="line">            array2[i] = array2[i - <span class="number">1</span>] * array1[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> temp = <span class="number">1</span>; <span class="comment">// 初始化D[n-1]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length1 - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            temp *= array1[i + <span class="number">1</span>]; <span class="comment">// 对应从下往上计算出D[i]</span></span><br><span class="line">            array2[i] *= temp;     <span class="comment">// 对应B[i] = C[i] * D[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题53正则表达式匹配">面试题53：正则表达式匹配</h2><h3 id="题目">题目</h3><blockquote><p>请实现一个函数用来匹配包含 <code>'.'</code> 和 <code>'*'</code> 的正则表达式。模式中的字符 <code>'.'</code> 表示任意一个字符，而 <code>'*'</code> 表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如字符串 <code>&quot;aaa&quot;</code> 与模式 <code>&quot;a.a&quot;</code> 和 <code>&quot;ab*ac*a&quot;</code> 匹配，但与 <code>&quot;aa.a&quot;</code> 及 <code>&quot;ab*a&quot;</code> 均不匹配。</p></blockquote><h3 id="解析">解析</h3><p>这题其实还是蛮好分析的，我们用两个指针分别指向字符串和模式，如果两个指针都走到最后，也即同时遇到结束符 <code>'\0</code> 则匹配成功；如果模式用完了，字符串还有未匹配上的部分，就匹配失败；两个指针都未到达最后时，我们需要注意以下 <code>'.'</code> 和 <code>'*'</code> 的处理。<code>'.'</code> 比较简单，因为想匹配什么都可以； <code>'*'</code> 的处理就复杂一点，因为我们有多种选择。每一轮匹配的流程可以概括如下：</p><hr><p>判断模式的下一位字符是否 <code>'*'</code> 号：</p><ul><li>是<ul><li>当前字符可以匹配<ol><li>模式的当前字符仅匹配一次（也即当*号不存在，字符串指针和模式指针各往后移一步）</li><li>模式的当前字符匹配多次（字符串指针往后移，模式指针不动）</li><li>模式的当前字符匹配零次（同时忽略模式当前字符和*号，字符串指针不动，模式指针后移两步）</li></ol></li><li>当前字符不能匹配<ol><li>模式的当前字符匹配零次（同时忽略模式当前字符和*号，字符串指针不动，模式指针后移两步）</li></ol></li></ul></li><li>否<ul><li>当前字符可以匹配<ol><li>继续下一次匹配（字符串指针和模式指针各往后移一步）</li></ol></li><li>当前字符不能匹配<ol><li>返回匹配失败</li></ol></li></ul></li></ul><hr><p>使用递归的方式来实现即可，特别注意一点，虽然 <code>'.'</code> 可以匹配字符串的任意字符，但是结束符 <code>'\0'</code> 是不属于字符串的内容部分的，在写判断条件时必须把这一点加上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">NULL</span> || pattern == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> matchCore(str, pattern);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 字符串和模式同时到达尾部，匹配成功</span></span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模式已经到了最后，字符串还有未匹配的字符，匹配失败</span></span><br><span class="line">    <span class="keyword">if</span>(*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模式的下一位是*号</span></span><br><span class="line">    <span class="keyword">if</span>(*(pattern + <span class="number">1</span>) == <span class="string">'*'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 模式能匹配当前字符，则分三种情况：匹配一个，匹配多个，匹配零个</span></span><br><span class="line">        <span class="keyword">if</span>(*pattern == *str || (*pattern == <span class="string">'.'</span> &amp;&amp; *str != <span class="string">'\0'</span>))</span><br><span class="line">                   <span class="comment">// move on the next state</span></span><br><span class="line">            <span class="keyword">return</span> matchCore(str + <span class="number">1</span>, pattern + <span class="number">2</span>)</span><br><span class="line">                   <span class="comment">// stay on the current state</span></span><br><span class="line">                || matchCore(str + <span class="number">1</span>, pattern)</span><br><span class="line">                   <span class="comment">// ignore a '*'</span></span><br><span class="line">                || matchCore(str, pattern + <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 模式不能匹配当前字符，忽略*号</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                   <span class="comment">// ignore a '*'</span></span><br><span class="line">            <span class="keyword">return</span> matchCore(str, pattern + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模式的下一位不是*号，但是能匹配当前字符，就继续匹配</span></span><br><span class="line">    <span class="keyword">if</span>(*str == *pattern || (*pattern == <span class="string">'.'</span> &amp;&amp; *str != <span class="string">'\0'</span>))</span><br><span class="line">        <span class="keyword">return</span> matchCore(str + <span class="number">1</span>, pattern + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模式的下一位不是*号，而且匹配不了当前字符，直接返回匹配失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题54表示数值的字符串">面试题54：表示数值的字符串</h2><h3 id="题目">题目</h3><blockquote><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串<code>&quot;+100&quot;</code>、<code>&quot;5e2&quot;</code>、<code>&quot;-123&quot;</code>、<code>&quot;3.1416&quot;</code>及<code>&quot;-1E-16&quot;</code>都表示数值，但<code>&quot;12e&quot;</code>、<code>&quot;1a3.14&quot;</code>、<code>&quot;1.2.3&quot;</code>、<code>&quot;+-5&quot;</code>及<code>&quot;12e+5.4&quot;</code>都不是。</p></blockquote><h3 id="解析">解析</h3><p>我们首先弄清楚怎样的字符串才表示数值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[符号位] 整数部分 [.小数部分] [e|E [符号位] 指数部分]</span><br></pre></td></tr></table></figure><p>可以概括如下：</p><ul><li>最前面一位可以是符号位，但不是必需的；</li><li>整数部分是最基础的，但<strong>一些小数可以不需要整数部分</strong>（比如：<code>.5</code>）；</li><li>整数部分后可以接小数点和小数部分，它们不是必需的，但<strong>出现了小数点就必须有小数部分</strong>；</li><li>整数部分后可以接指数符号和指数部分，它们不是必需的，但<strong>出现了指数符号就必须有指数部分</strong>；</li><li>指数部分最前面一位可以是符号位，但不是必需的；</li><li>除了正负号、数字、小数点、大小写指数符号外不能出现其他字符；</li><li>小数点、大小写指数符号最多出现一次，正负号在整数部分和指数部分也各最多出现一次。</li></ul><p>没有什么诀窍，按着这些规则编写代码，仔细检查有没有漏掉的情况就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存在符号位就先跳过</span></span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">'+'</span> || *str == <span class="string">'-'</span>)</span><br><span class="line">        ++str;</span><br><span class="line">    <span class="comment">// 如果只有符号位，则不是数值</span></span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> numeric = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> hasDigits = scanDigits(&amp;str); <span class="comment">// 跳过整数部分</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*str != <span class="string">'\0'</span>) <span class="comment">// 如果整数部分后还有字符</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 检测到小数点</span></span><br><span class="line">        <span class="keyword">if</span> (*str == <span class="string">'.'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++str; <span class="comment">// 跳过小数点</span></span><br><span class="line">            <span class="keyword">if</span> (*str == <span class="string">'e'</span> || *str == <span class="string">'E'</span>) <span class="comment">// 小数点后直接接指数部分，非数值</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!hasDigits &amp;&amp; *str == <span class="string">'\0'</span>) <span class="comment">// 没有整数部分也没有小数部分，非数值</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            scanDigits(&amp;str); <span class="comment">// 跳过小数部分</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测到指数符号</span></span><br><span class="line">            <span class="keyword">if</span> (*str == <span class="string">'e'</span> || *str == <span class="string">'E'</span>)</span><br><span class="line">                numeric = isExponential(&amp;str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测到指数符号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*str == <span class="string">'e'</span> || *str == <span class="string">'E'</span>)</span><br><span class="line">            numeric = isExponential(&amp;str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测到非法字符</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            numeric = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一直到字符串最后都没有出现非法字符</span></span><br><span class="line">    <span class="comment">// 如果出现了非法字符必然不会扫描到结束符</span></span><br><span class="line">    <span class="keyword">return</span> numeric &amp;&amp; *str == <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">scanDigits</span><span class="params">(<span class="keyword">char</span>** str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* pBefore = *str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过数字部分</span></span><br><span class="line">    <span class="keyword">while</span> (**str != <span class="string">'\0'</span> &amp;&amp; **str &gt;= <span class="string">'0'</span> &amp;&amp; **str &lt;= <span class="string">'9'</span>)</span><br><span class="line">        ++(*str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回是否存在数字部分（如果指针发生了移动就说明存在）</span></span><br><span class="line">    <span class="keyword">return</span> *str &gt; pBefore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isExponential</span><span class="params">(<span class="keyword">char</span>** str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (**str != <span class="string">'e'</span> &amp;&amp; **str != <span class="string">'E'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    ++(*str); <span class="comment">// 跳过指数符号</span></span><br><span class="line">    <span class="comment">// 如果存在符号位就提哦啊过符号位</span></span><br><span class="line">    <span class="keyword">if</span> (**str == <span class="string">'+'</span> || **str == <span class="string">'-'</span>)</span><br><span class="line">        ++(*str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 符号位后没有数字，也即没有指数部分，非数值</span></span><br><span class="line">    <span class="keyword">if</span> (**str == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过指数部分</span></span><br><span class="line">    scanDigits(str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果指数部分后面还有其它字符则非数值</span></span><br><span class="line">    <span class="keyword">return</span> (**str == <span class="string">'\0'</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题55字符流中第一个不重复的字符">面试题55：字符流中第一个不重复的字符</h2><h3 id="题目">题目</h3><blockquote><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，但从字符流中制度处前两个字符 <code>&quot;go&quot;</code> 时，第一个只出现一次的字符是 <code>'g'</code>。当从该字符流中读出前六个字符 <code>&quot;gooogle&quot;</code> 时，第一个只出现一次的字符是 <code>'l'</code>。</p></blockquote><h3 id="解析">解析</h3><p>这题其实不难，输入是数据流，所以也可以把它看作是一道大数据的题目，非常有意思。</p><p>这里我们实现一个类，通过维护一个哈希表和索引来实现题目的功能。因为是字符流，而字符只有256种可能，所以我们开一个长度为256的哈希表就可以了，索引则用来记录当前流过的字符在字符流中的位置。</p><p>哈希表的每一个格子对应一个字符的不同状态，比如做以下设定：</p><ol><li>字符未出现过，则哈希值为-1；</li><li>字符出现超过一次，则哈希值为-2；</li><li>字符仅出现了一次，哈希值为它在字符流中的位置（大于0）。</li></ol><p>这样，当我们从字符流中取得一个字符时，我们可以用O(1)时间来检查一下字符的哈希值，哈希值为-2则不再关心，只对索引进行更新（索引加一）；哈希值为-1则把哈希值更新为当前索引，然后索引加一。</p><p>当我们要求第一个只出现一次的字符时，我们同样可以用O(1)时间找到答案（与输入规模，也即字符流的长度无关）。我们只需要遍历一次哈希表，找到只出现一次，且出现位置最前（索引值最小）的那个字符就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CharStatistics</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CharStatistics() : index (<span class="number">0</span>) <span class="comment">// 构造时index初始化为0</span></span><br><span class="line">    &#123;   <span class="comment">// 哈希表全部初始化为-1，即未出现过</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)</span><br><span class="line">            occurrence[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 未出现过则把哈希表对应的值更新为在字符串中出现的位置</span></span><br><span class="line">        <span class="keyword">if</span>(occurrence[ch] == <span class="number">-1</span>)</span><br><span class="line">            occurrence[ch] = index;</span><br><span class="line">        <span class="comment">// 已经出现过则更新为-2，不再关心</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(occurrence[ch] &gt;= <span class="number">0</span>)</span><br><span class="line">            occurrence[ch] = <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">        index++; <span class="comment">// 没插入一个字符，索引加一</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch = <span class="string">'\0'</span>; <span class="comment">// 初始化为终止符</span></span><br><span class="line">        <span class="comment">// 把最小索引初始化为int型能表示的最大整数</span></span><br><span class="line">        <span class="keyword">int</span> minIndex = numeric_limits&lt;<span class="keyword">int</span>&gt;::max();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i) <span class="comment">// 遍历一次整个哈希表</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 每次找到一个只出现一次的数并且在字符串中位置比最小索引前</span></span><br><span class="line">            <span class="comment">// 就更新字符和最小索引</span></span><br><span class="line">            <span class="keyword">if</span>(occurrence[i] &gt;= <span class="number">0</span> &amp;&amp; occurrence[i] &lt; minIndex)</span><br><span class="line">            &#123;</span><br><span class="line">                ch = (<span class="keyword">char</span>)i; <span class="comment">// 从ASCII码值转换回字符</span></span><br><span class="line">                minIndex = occurrence[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// occurrence[i]: A character with ASCII value i;</span></span><br><span class="line">    <span class="comment">// occurrence[i] = -1: The character has not found;</span></span><br><span class="line">    <span class="comment">// occurrence[i] = -2: The character has been found for mutlple times</span></span><br><span class="line">    <span class="comment">// occurrence[i] &gt;= 0: The character has been found only once</span></span><br><span class="line">    <span class="keyword">int</span> occurrence[<span class="number">256</span>]; <span class="comment">// 哈希表</span></span><br><span class="line">    <span class="keyword">int</span> index;           <span class="comment">// 索引，当前处于字符串的位置，或者说目前字符流的长度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="面试题56链表中环的入口结点">面试题56：链表中环的入口结点</h2><h3 id="题目">题目</h3><blockquote><p>一个链表中包含环，如何找出环的入口结点？例如，在图8.3的链表中，环的入口结点是结点3。</p></blockquote><p><img src="https://github.com/familyld/Coding_Interviews/blob/master/graph/56_EntryNodeInListLoop.jpg?raw=true" alt="ring"></p><h3 id="解析">解析</h3><p>这题可以分为三个步骤来完成：</p><ol><li>判断链表中有没有环</li><li>计算环的结点数</li><li>找到环的入口结点</li></ol><p>先分析第一步，判断链表中有没有环，可以用一快一慢两个指针来实现。为什么可以这样做不妨看看知乎上的一个问题：<a href="https://www.zhihu.com/question/23208893" target="_blank" rel="noopener">为什么用快慢指针找链表的环，快指针和慢指针一定会相遇？</a>，还是挺有意思的。如果链表中存在环，那么快指针必然会从后追上慢指针，发生相遇；如果链表中没有环，那么快指针就会走到尾结点。</p><p>接下来，如果存在环，我们就计算一下环中结点的数目。怎么办到呢？其实很简单，我们同样使用两个指针，一个指针固定不动在第一步快慢指针相遇的地方，另一个指针一边往前移动一边计数，那么当这两个指针再次相遇时，所得的计数就是环中结点的数目了。</p><p>最后，怎么找到环的入口结点呢？其实可能有人还没想明白第二步的作用，可以回忆一下<a href="https://github.com/familyld/Coding_Interviews/blob/master/C%2B%2B/15_KthNodeFromEnd/README.md" target="_blank" rel="noopener">面试题15：链表中的倒数第k个结点</a>。其实我们统计环中结点的数目就是为第三步服务的！要找到环的入口结点，实际上和这一题有异曲同工之妙。</p><p>假设我们把环的入口结点看作环的第一个结点（例子中的3），那么环的最后一个结点（例子中的6）就是环中连接到入口结点的那个结点，我们可以把它看作链表的最后一个结点。这时如果我们把环拿掉，其实这道题就变得跟面试题15一模一样了。</p><p>假设环中结点数为k，那么我们现在要找的就是整个链表的倒数第k个结点。同样使用两个指针，第一个指针先走k步，然后第二个指针再走，此时两个指针之间隔着k-1个结点。当第一个指针和第二个指针相遇时，它们指向的结点就是环的入口结点了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">MeetingNode</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ListNode* pSlow = pHead-&gt;m_pNext;</span><br><span class="line">    <span class="keyword">if</span>(pSlow == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ListNode* pFast = pSlow-&gt;m_pNext;</span><br><span class="line">    <span class="keyword">while</span>(pFast != <span class="literal">NULL</span> &amp;&amp; pSlow != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pFast == pSlow) <span class="comment">// 返回相遇的结点</span></span><br><span class="line">            <span class="keyword">return</span> pFast;</span><br><span class="line"></span><br><span class="line">        pSlow = pSlow-&gt;m_pNext; <span class="comment">// 慢指针走一步</span></span><br><span class="line"></span><br><span class="line">        pFast = pFast-&gt;m_pNext; <span class="comment">// 快指针走两步</span></span><br><span class="line">        <span class="keyword">if</span>(pFast != <span class="literal">NULL</span>)       <span class="comment">// 注意判断第二步是否能走</span></span><br><span class="line">            pFast = pFast-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不存在环，返回NULL</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* meetingNode = MeetingNode(pHead);</span><br><span class="line">    <span class="keyword">if</span>(meetingNode == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取环中结点的数目</span></span><br><span class="line">    <span class="keyword">int</span> nodesInLoop = <span class="number">1</span>;</span><br><span class="line">    ListNode* pNode1 = meetingNode;</span><br><span class="line">    <span class="keyword">while</span>(pNode1-&gt;m_pNext != meetingNode)</span><br><span class="line">    &#123;</span><br><span class="line">        pNode1 = pNode1-&gt;m_pNext;</span><br><span class="line">        ++nodesInLoop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让指针1先走nodesInLoop步</span></span><br><span class="line">    pNode1 = pHead;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodesInLoop; ++i)</span><br><span class="line">        pNode1 = pNode1-&gt;m_pNext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针1、2同时移动</span></span><br><span class="line">    ListNode* pNode2 = pHead;</span><br><span class="line">    <span class="keyword">while</span>(pNode1 != pNode2) <span class="comment">// 相遇时停止</span></span><br><span class="line">    &#123;</span><br><span class="line">        pNode1 = pNode1-&gt;m_pNext;</span><br><span class="line">        pNode2 = pNode2-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pNode1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题57删除链表中重复的结点">面试题57：删除链表中重复的结点</h2><h3 id="题目">题目</h3><blockquote><p>在一个排序的链表中，如何删除重复的结点？例如：</p></blockquote><p>删除前：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; 2 -&gt; 3 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5</span><br></pre></td></tr></table></figure><p>删除后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; 2 -&gt; 5</span><br></pre></td></tr></table></figure><h3 id="解析">解析</h3><p>这题我们需要注意的就是删除重复结点前，需要记住前面的那一个非重复结点，保证删除完毕后，前一个个非重复结点依然能连接到下一个非重复结点，链表不会发生锻炼。</p><p>另一个需要注意的点就是，头结点是有可能被删除的，所以调用函数时要按引用传递头结点指针，否则无法进行修改和删除。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteDuplication</span><span class="params">(ListNode** pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead == <span class="literal">NULL</span> || *pHead == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    ListNode* pPreNode = <span class="literal">NULL</span>; <span class="comment">// 前一结点初始为NULL，因为头结点没有前一结点</span></span><br><span class="line">    ListNode* pNode = *pHead;</span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>) <span class="comment">// 遍历链表直到到达尾部</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *pNext = pNode-&gt;m_pNext; <span class="comment">// 取得下一结点</span></span><br><span class="line">        <span class="keyword">bool</span> needDelete = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 如果下一结点和当前结点值相同，就说明需要删除</span></span><br><span class="line">        <span class="keyword">if</span>(pNext != <span class="literal">NULL</span> &amp;&amp; pNext-&gt;m_nValue == pNode-&gt;m_nValue)</span><br><span class="line">            needDelete = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不用删除的话就继续遍历下一结点</span></span><br><span class="line">        <span class="comment">// 把前一结点更新为当前结点</span></span><br><span class="line">        <span class="keyword">if</span>(!needDelete)</span><br><span class="line">        &#123;</span><br><span class="line">            pPreNode = pNode;</span><br><span class="line">            pNode = pNode-&gt;m_pNext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除结点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从当前结点开始删除值相同的结点</span></span><br><span class="line">            <span class="keyword">int</span> value = pNode-&gt;m_nValue;</span><br><span class="line">            ListNode* pToBeDel = pNode;</span><br><span class="line">            <span class="keyword">while</span>(pToBeDel != <span class="literal">NULL</span> &amp;&amp; pToBeDel-&gt;m_nValue == value)</span><br><span class="line">            &#123;</span><br><span class="line">                pNext = pToBeDel-&gt;m_pNext;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">delete</span> pToBeDel;</span><br><span class="line">                pToBeDel = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">                pToBeDel = pNext;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果发现是头结点被删除了，则把头结点改为（删除完重复结点后的）下一结点</span></span><br><span class="line">            <span class="keyword">if</span>(pPreNode == <span class="literal">NULL</span>)</span><br><span class="line">                *pHead = pNext;</span><br><span class="line">            <span class="comment">// 否则就把前一结点的next指针指向（删除完重复结点后的）下一结点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pPreNode-&gt;m_pNext = pNext;</span><br><span class="line"></span><br><span class="line">            pNode = pNext; <span class="comment">// 继续遍历下一结点，前一结点不需移动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题58二叉树的下一个结点">面试题58：二叉树的下一个结点</h2><h3 id="题目">题目</h3><blockquote><p>给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？树中的结点除了有两个分别指向左右子结点的指针以外，还有一个指向父结点的指针。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                    m_nValue;</span><br><span class="line">    BinaryTreeNode*        m_pLeft;</span><br><span class="line">    BinaryTreeNode*        m_pRight;</span><br><span class="line">    BinaryTreeNode*        m_pParent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析">解析</h3><p>所谓中序遍历，也即对于每个结点来说，首先访问左子树，然后再访问自身，最后访问右子树。在写代码时我们考虑一下三种情况：</p><ol><li>结点有右子树：下一结点为右子树的最左子结点</li><li>结点无右子树：<ul><li>该结点是父结点的左子结点：下一结点为父结点</li><li>该结点是父结点的右子结点：需要一直往上搜索，直到找到一个结点是其父结点的左子结点，则其父结点就是下一结点。若不存在则说明遍历结束。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">GetNext</span><span class="params">(BinaryTreeNode* pNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pNode == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    BinaryTreeNode* pNext = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(pNode-&gt;m_pRight != <span class="literal">NULL</span>)</span><br><span class="line">    &#123; <span class="comment">// 有右子树则下一结点为右子树的最左子结点</span></span><br><span class="line">        BinaryTreeNode* pRight = pNode-&gt;m_pRight;</span><br><span class="line">        <span class="keyword">while</span>(pRight-&gt;m_pLeft != <span class="literal">NULL</span>)</span><br><span class="line">            pRight = pRight-&gt;m_pLeft;</span><br><span class="line"></span><br><span class="line">        pNext = pRight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;m_pParent != <span class="literal">NULL</span>)</span><br><span class="line">    &#123; <span class="comment">// 没有右子树但是有父结点就说明仍然可以找到下一结点</span></span><br><span class="line">        BinaryTreeNode* pCurrent = pNode;</span><br><span class="line">        BinaryTreeNode* pParent = pNode-&gt;m_pParent;</span><br><span class="line">        <span class="keyword">while</span>(pParent != <span class="literal">NULL</span> &amp;&amp; pCurrent == pParent-&gt;m_pRight)</span><br><span class="line">        &#123; <span class="comment">// 往上找直到找到一个结点属于父结点的左子树，则下一结点为父结点</span></span><br><span class="line">            pCurrent = pParent;</span><br><span class="line">            pParent = pParent-&gt;m_pParent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pNext = pParent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题59对称的二叉树">面试题59：对称的二叉树</h2><h3 id="题目">题目</h3><blockquote><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。例如：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     8</span><br><span class="line">   /   \</span><br><span class="line">  6     6</span><br><span class="line"> / \   / \</span><br><span class="line">5   7 7   5</span><br></pre></td></tr></table></figure><blockquote><p>是一棵对称二叉树。</p></blockquote><h3 id="解析">解析</h3><p>前序遍历、中序遍历、后序遍历都是先访问左子结点再访问右子结点，而如果我们想要判断一棵树是否对称二叉树，我们可以创造一种遍历方式是先访问右子结点再访问左子结点的。如果使用两种对应遍历方式所得的遍历序列都相同，就说明这棵树是对称二叉树。</p><p>书中以前序遍历为例编写代码，但实际上中序遍历和后序遍历也是可以的~</p><p>特别注意，一种特殊情况如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">7</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">7</span>     <span class="number">7</span></span><br><span class="line"> / \   /</span><br><span class="line"><span class="number">7</span>   <span class="number">7</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><p>这种情况如果我们只是按上面的方式来比较是无法正确判断出的，怎么应对呢？我们只需要把NULL也考虑进来就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(BinaryTreeNode* pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isSymmetrical(pRoot, pRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 同为NULL，则仍然认为是一样的，并且因为到达底部而返回</span></span><br><span class="line">    <span class="keyword">if</span>(pRoot1 == <span class="literal">NULL</span> &amp;&amp; pRoot2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一方为NULL，而另一方不是，说明不对称，返回false</span></span><br><span class="line">    <span class="keyword">if</span>(pRoot1 == <span class="literal">NULL</span> || pRoot2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结点值不同，说明不对称，返回false</span></span><br><span class="line">    <span class="keyword">if</span>(pRoot1-&gt;m_nValue != pRoot2-&gt;m_nValue)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结点值相同，继续进行比较，树1先访问左结点再访问右结点，树2则相反</span></span><br><span class="line">    <span class="keyword">return</span> isSymmetrical(pRoot1-&gt;m_pLeft, pRoot2-&gt;m_pRight)</span><br><span class="line">        &amp;&amp; isSymmetrical(pRoot1-&gt;m_pRight, pRoot2-&gt;m_pLeft);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题60把二叉树打印成多行">面试题60：把二叉树打印成多行</h2><h3 id="题目">题目</h3><blockquote><p>从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印到一行。例如，打印下面的二叉树：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     8</span><br><span class="line">   /   \</span><br><span class="line">  6     10</span><br><span class="line"> / \   /  \</span><br><span class="line">5   7 9    11</span><br></pre></td></tr></table></figure><blockquote><p>结果是：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">6   10</span><br><span class="line">5   7   9   11</span><br></pre></td></tr></table></figure><h3 id="解析">解析</h3><p>这题思路很简单，就是考查BFS的，逐层遍历一棵树只需要用队列模拟就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(BinaryTreeNode* pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;BinaryTreeNode*&gt; nodes;</span><br><span class="line">    nodes.push(pRoot);</span><br><span class="line">    <span class="keyword">int</span> nextLevel = <span class="number">0</span>;   <span class="comment">// 下一层需要打印的结点数</span></span><br><span class="line">    <span class="keyword">int</span> toBePrinted = <span class="number">1</span>; <span class="comment">// 当前层需要打印的结点数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty()) <span class="comment">// 整棵树打印完毕时停止</span></span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* pNode = nodes.front();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, pNode-&gt;m_nValue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;m_pLeft != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nodes.push(pNode-&gt;m_pLeft);</span><br><span class="line">            ++nextLevel;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;m_pRight != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nodes.push(pNode-&gt;m_pRight);</span><br><span class="line">            ++nextLevel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首结点出队，当前层需要打印的结点数减一</span></span><br><span class="line">        nodes.pop();</span><br><span class="line">        --toBePrinted;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若当前层打印完毕，则进行换行，开始打印下一层</span></span><br><span class="line">        <span class="keyword">if</span>(toBePrinted == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            toBePrinted = nextLevel;</span><br><span class="line">            nextLevel = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题61按之字形顺序打印二叉树">面试题61：按之字形顺序打印二叉树</h2><h3 id="题目">题目</h3><blockquote><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三层再按照从左到右的顺序打印，其他行以此类推。</p></blockquote><h3 id="解析">解析</h3><p>这题和上一题比难度就上升了，显然这不是一个简单的BFS，我们要使用什么容器和往容器中存放结点的顺序都需要认真去考虑。</p><p>这里使用两个栈再加上一点小trick来实现，注意栈的特性的先进后出，后进先出。</p><p>我们注意当奇数层是顺着打印，偶数层是倒着打印。所以！<strong>奇数层应该倒着入栈，偶数层则顺着入栈</strong>。</p><p>明白这一点之后就好办了，我们使用两个栈来存放，一个栈用来存放当前打印的那一层，另一个栈用来存放下一层的结点值。如果只使用一个栈是不行的，当层数更高时会发生顺序的错乱。使用两个栈时我们只需要判断一下当前栈是否为空就知道这一层是否打印完毕要转换到另一个栈了。</p><p>具体来说，举个例子，比如下面这棵树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">         1</span><br><span class="line">      /      \</span><br><span class="line">    2          3</span><br><span class="line">  /  \       /   \</span><br><span class="line"> 4    5     6     7</span><br><span class="line">/ \  / \   / \   / \</span><br><span class="line">8 9 10 11 12 13 14 15</span><br></pre></td></tr></table></figure><p>| 步骤 | 操作 | Stack1中的结点 | Stack2中的结点 |<br>|: - :|: - :|: - :|: - :|<br>| 1 | 打印结点1 | 2,3 |  |<br>| 2 | 打印结点3 | 2 | 7,6 |<br>| 3 | 打印结点2 |  | 7,6,5,4 |<br>| 4 | 打印结点4 | 8,9 | 7,6,5 |<br>| 5 | 打印结点5 | 8,9,10,11 | 7,6 |<br>| 6 | 打印结点6 | 8,9,10,11,12,13 | 7 |<br>| 7 | 打印结点6 | 8,9,10,11,12,13,14,15 |  |</p><p>对于奇数层的结点而言，下一层要逆着打，所以先存左子结点，再存右子结点，这样下一层就会先打印右子结点再打印左子结点；</p><p>对于偶数层的结点而言，下一层要顺着打，所以先存右子结点，再存左子结点，这样下一层就会先打印左子结点再打印右子结点；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(BinaryTreeNode* pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用两个栈，0号栈存的必然是奇数层结点，1号栈存的必然是偶数层结点</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;BinaryTreeNode*&gt; levels[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> current = <span class="number">0</span>; <span class="comment">// 指示存放当前层结点值的栈</span></span><br><span class="line">    <span class="keyword">int</span> next = <span class="number">1</span>;    <span class="comment">// 指示存放下一层结点值的栈</span></span><br><span class="line"></span><br><span class="line">    levels[current].push(pRoot);</span><br><span class="line">    <span class="comment">// 两个栈都为空时，说明整棵树已经打印完毕</span></span><br><span class="line">    <span class="keyword">while</span>(!levels[<span class="number">0</span>].empty() || !levels[<span class="number">1</span>].empty())</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* pNode = levels[current].top();</span><br><span class="line">        levels[current].pop();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, pNode-&gt;m_nValue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(current == <span class="number">0</span>)</span><br><span class="line">        &#123; <span class="comment">// 当前打印的是0号栈，则下一层为偶数层，先存左子结点，再存右子结点</span></span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;m_pLeft != <span class="literal">NULL</span>)</span><br><span class="line">                levels[next].push(pNode-&gt;m_pLeft);</span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;m_pRight != <span class="literal">NULL</span>)</span><br><span class="line">                levels[next].push(pNode-&gt;m_pRight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">// 当前打印的是1号栈，则下一层为奇数层，先存右子结点，再存左子结点</span></span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;m_pRight != <span class="literal">NULL</span>)</span><br><span class="line">                levels[next].push(pNode-&gt;m_pRight);</span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;m_pLeft != <span class="literal">NULL</span>)</span><br><span class="line">                levels[next].push(pNode-&gt;m_pLeft);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前层打印完毕，打印下一层</span></span><br><span class="line">        <span class="keyword">if</span>(levels[current].empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            current = <span class="number">1</span> - current;</span><br><span class="line">            next = <span class="number">1</span> - next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题62序列化二叉树">面试题62：序列化二叉树</h2><h3 id="题目">题目</h3><blockquote><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p></blockquote><h3 id="解析">解析</h3><p>首先要理解一下什么是序列化，什么是反序列化？</p><p>其实，我们谈论到的很多数据结构比方说树，甚至一些更复杂的自定定义的对象，是没法直接保存或传输的，只有程序运行时可以用。当我们需要保存到硬盘或者进行传输时就必须进行序列化，然后要放入程序时就要重新反序列化解析出来。可以如下定义：</p><ul><li>序列化： 将数据结构或对象转换成二进制串的过程。</li><li>反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。</li></ul><p>不过这题我们在程序中只需要把二叉树转换为字符串就可以了。</p><p>前面有一道题是通过前序遍历序列和中序遍历序列构造出一棵二叉树的，这里其实也可以用这样的思路，把二叉树序列化成前序遍历序列和中序遍历序列这两个序列来存储，然后反序列化时按这两个序列重新构造二叉树就可以了。但这种思路有两个很大的缺点就是：（1）不能有数值重复的结点；（2）要整个序列读出来才可以进行反序列化。</p><p>事实上不用这么复杂，我们只需要选择一种遍历方式就可以了，关键是用一个特殊的符号来表示NULL，这样在反序列化时我们就可以知道什么时候到达底部了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Serialize</span><span class="params">(BinaryTreeNode* pRoot, ostream&amp; stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>) <span class="comment">// 使用$标识NULL</span></span><br><span class="line">    &#123;</span><br><span class="line">        stream &lt;&lt; <span class="string">"$,"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    stream &lt;&lt; pRoot-&gt;m_nValue &lt;&lt; <span class="string">','</span>; <span class="comment">// 序列化当前结点，以逗号为分隔</span></span><br><span class="line">    Serialize(pRoot-&gt;m_pLeft, stream);</span><br><span class="line">    Serialize(pRoot-&gt;m_pRight, stream);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从输入流中每次读出一个结点的值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ReadStream</span><span class="params">(istream&amp; stream, <span class="keyword">int</span>* number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stream.eof())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">32</span>];</span><br><span class="line">    buffer[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    stream &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stream.eof() &amp;&amp; ch != <span class="string">','</span>)</span><br><span class="line">    &#123; <span class="comment">// 遇到EOF表示序列已读完，而遇到逗号则说明这个结点的值读完了</span></span><br><span class="line">        buffer[i++] = ch;</span><br><span class="line">        stream &gt;&gt; ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断读出的是否数字，并进行相应的转换</span></span><br><span class="line">    <span class="keyword">bool</span> isNumeric = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; buffer[<span class="number">0</span>] != <span class="string">'$'</span>)</span><br><span class="line">    &#123; <span class="comment">// i大于0说明上一步有读出过内容，读出内容不为$即结点是数值，进行转换</span></span><br><span class="line">        *number = atoi(buffer);</span><br><span class="line">        isNumeric = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isNumeric;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Deserialize</span><span class="params">(BinaryTreeNode** pRoot, istream&amp; stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">if</span>(ReadStream(stream, &amp;number))</span><br><span class="line">    &#123; <span class="comment">// 如果读出数字就构造结点，否则表示已到达底部，递归返回</span></span><br><span class="line">        *pRoot = <span class="keyword">new</span> BinaryTreeNode();</span><br><span class="line">        (*pRoot)-&gt;m_nValue = number;</span><br><span class="line">        (*pRoot)-&gt;m_pLeft = <span class="literal">NULL</span>;</span><br><span class="line">        (*pRoot)-&gt;m_pRight = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        Deserialize(&amp;((*pRoot)-&gt;m_pLeft), stream);</span><br><span class="line">        Deserialize(&amp;((*pRoot)-&gt;m_pRight), stream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题特别注意一下传参的方式，一些参数是需要使用指针传递/引用传递的（修改实参而非形参的值），否则会无法正确修改它在内存中的值，从而导致错误。不妨看看这篇文章：<a href="http://www.cnblogs.com/Romi/archive/2012/08/09/2630014.html" target="_blank" rel="noopener">C/C++中函数参数传递详解</a>。参数中带<code>&amp;</code>表示按引用传递。</p><h2 id="面试题63二叉树搜索树的第k个结点">面试题63：二叉树搜索树的第k个结点</h2><h3 id="题目">题目</h3><blockquote><p>给定一棵二叉搜索树，请找出其中的第k大的结点。例如：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     5</span><br><span class="line">   /   \</span><br><span class="line">  3     7</span><br><span class="line"> / \   / \</span><br><span class="line">2   4 6   8</span><br></pre></td></tr></table></figure><blockquote><p>这棵二叉搜索树里，按结点数值大小顺序第三个结点是4。</p></blockquote><h3 id="解析">解析</h3><p>这题思路很简单，对于一棵BST搜索第k大的结点，只需要用前序遍历来检索就可以了，前序遍历访问到的第k个结点就是题目所求。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">KthNode</span><span class="params">(BinaryTreeNode* pRoot, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span> || k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> KthNodeCore(pRoot, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BinaryTreeNode* <span class="title">KthNodeCore</span><span class="params">(BinaryTreeNode* pRoot, <span class="keyword">unsigned</span> <span class="keyword">int</span>&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinaryTreeNode* target = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pRoot-&gt;m_pLeft != <span class="literal">NULL</span>) <span class="comment">// 先访问左子结点</span></span><br><span class="line">        target = KthNodeCore(pRoot-&gt;m_pLeft, k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(target == <span class="literal">NULL</span>) <span class="comment">// 然后访问当前结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="comment">// 若此时k已为1，则当前结点为所求</span></span><br><span class="line">            target = pRoot;</span><br><span class="line"></span><br><span class="line">        k--;       <span class="comment">// 每次访问完后k值减一</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(target == <span class="literal">NULL</span> &amp;&amp; pRoot-&gt;m_pRight != <span class="literal">NULL</span>) <span class="comment">// 若当前结点不是，继续访问右子结点</span></span><br><span class="line">        target = KthNodeCore(pRoot-&gt;m_pRight, k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题64数据流中的中位数">面试题64：数据流中的中位数</h2><h3 id="题目">题目</h3><blockquote><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p></blockquote><h3 id="解析">解析</h3><p>这条题目其实和第5章的 面试题30：最小的k个数 有一点联系，面试题30通过维持一个大小为k的最大堆来实现从数据流中确定最小k个数的功能。而这一题要求得到数据流的中位数，这要更难一些。一是我们没有办法确定堆的大小；二是有可能从数据流中读出了偶数个数值，此时需要所有数值排序之后中间两个数的平均值。</p><p>无法确定堆的大小，其实更准确一点来说，假设我们要找出从数据流中读取k个数时的中位数，我们必须把前面的k-1个数都保存下来因为我们并不知道k的取值，任意一个数字都可能会是取某个k值时的中位数，不能丢掉。</p><p>而为了更有效地插入新数字（O(log n)复杂度）和查询中位数（O(1)复杂度），我们可以同时维护两个堆，一个最大堆，一个最小堆，以中位数划分，最大堆保存排序后数组的前半部分，最小堆则保存后半部分。我们要注意保持数据平均地分到这两个堆中，也即堆的大小相差不超过1。当从数据流中读取了奇数个数值时，取最小堆的顶部为中位数；当从数据流中读取了偶数个数值时，取最大堆顶部和最小堆顶部两个数值的平均值为中位数。</p><p>为了保证正确取得中位数我们要保证最大堆里的数都比最小堆里的小，这就对插入操作有所要求。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">DynamicArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(T num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(((min.size() + max.size()) &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123; <span class="comment">// 此时从数据流中读取了奇数个数值</span></span><br><span class="line">            <span class="keyword">if</span>(max.size() &gt; <span class="number">0</span> &amp;&amp; num &lt; max[<span class="number">0</span>])</span><br><span class="line">            &#123; <span class="comment">// 保证要加入最小堆的数字比最大堆的所有数字都更大</span></span><br><span class="line">                max.push_back(num);</span><br><span class="line">                push_heap(max.begin(), max.end(), less&lt;T&gt;());</span><br><span class="line"></span><br><span class="line">                num = max[<span class="number">0</span>]; <span class="comment">// 如果新数字没有堆顶大，就会交换两者的值</span></span><br><span class="line"></span><br><span class="line">                pop_heap(max.begin(), max.end(), less&lt;T&gt;());</span><br><span class="line">                max.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把新数字加入最小堆</span></span><br><span class="line">            min.push_back(num);</span><br><span class="line">            push_heap(min.begin(), min.end(), greater&lt;T&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">// 此时从数据流中读取了偶数个数值</span></span><br><span class="line">            <span class="keyword">if</span>(min.size() &gt; <span class="number">0</span> &amp;&amp; min[<span class="number">0</span>] &lt; num)</span><br><span class="line">            &#123;</span><br><span class="line">                min.push_back(num);</span><br><span class="line">                push_heap(min.begin(), min.end(), greater&lt;T&gt;());</span><br><span class="line"></span><br><span class="line">                num = min[<span class="number">0</span>]; <span class="comment">// 如果新数字没有堆顶小，就会交换两者的值</span></span><br><span class="line"></span><br><span class="line">                pop_heap(min.begin(), min.end(), greater&lt;T&gt;());</span><br><span class="line">                min.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把新数字加入最大堆</span></span><br><span class="line">            max.push_back(num);</span><br><span class="line">            push_heap(max.begin(), max.end(), less&lt;T&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">GetMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = min.size() + max.size();</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> exception(); <span class="comment">//"No numbers are available"</span></span><br><span class="line"></span><br><span class="line">        T median = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>((size &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            median = min[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            median = (min[<span class="number">0</span>] + max[<span class="number">0</span>]) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> median;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; min;</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意这里实现堆结构的方式和第30题不同，这里使用STL的 <code>push_heap</code>，<code>pop_heap</code> 函数以及vector来实现堆，并且以比较仿函数less和greater来实现最大堆和最小堆。</p><h2 id="面试题65滑动窗口的最大值">面试题65：滑动窗口的最大值</h2><h3 id="题目">题目</h3><blockquote><p>给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。例如，如果输入数组 <code>{2,3,4,2,6,2,5,1}</code> 及滑动窗口的大小3，那么一共存在6个滑动窗口，它们的最大值分别为 <code>{4,4,6,6,6,5}</code>。</p></blockquote><h3 id="解析">解析</h3><p>这题其实也挺有意思的，稍微修改一下题目就可以用来考查数据流、大数据处理这样的问题了。这题的关键其实是要我们明白哪些数字有可能成为滑动窗口里的最大值（应当保存），哪些数字则不会（应当舍弃）。简单来说，有以下几个问题需要考虑：</p><ol><li>使用什么数据结构进行存储？（方便删除，插入和比较）</li><li>一个在当前滑动窗口非最大值的数字是否仍有可能成为另一个滑动窗口的最大值？</li><li>新加入滑动窗口的数字可能对已存储的数字带来什么影响？</li><li>怎样确定数字超出了滑动窗口的范围？</li></ol><p>针对问题1，我们可以使用一个两端开口的队列（deque）来存储那些滑动窗口内可能的最大值，前后都可以pop，并且可以使用 <code>front()</code> 函数和 <code>back()</code> 函数容易地取得队首和队尾，非常方便。注意，这个队列存储的是<strong>可能的最大值</strong>，也可以理解为它是一个中转站。我们还需要用另一个数据结构来存储<strong>真正的每个滑动窗口的最大值</strong>，这个数据结构要求就没有那么高，用vector就可以了。</p><p>针对问题2，当前滑动窗口非最大值的数字是有可能成为另一个滑动窗口的最大值的。举个例子，序列 <code>{6,5,4}</code>，窗口大小为2，那么第一个滑动窗口 <code>{6,5}</code> 里面最大值是6，但5也应当被存储下来，因为在下一个滑动窗口 <code>{5,4}</code> 中5就是最大值。</p><p>针对问题3，可以分两种情况讨论，一是窗口内存在比新数字小的数；二是窗口内存在的数都比新数字大。在情况一中，那些比新数字小的数我们可以都pop掉，因为它们比新数字小所以肯定不可能是当前窗口的最大值了，而往后滑动时，它们存在于窗口时新数字也一定在，所以依然不可能成为窗口内的最大值，因此可以把它们都扔掉；但在情况二中，尽管新数字比当前窗口内的数字都小，在窗口往后滑动时，新数字依然有可能成为窗口内的最大值，比方说上一段举出的例子，因此这种情况下依然要把新数字入队。考虑好这两种情况就能<strong>保证队列的队首永远是当前窗口的最大值</strong>。</p><p>针对问题4，我们在队列中存储时可以不要存数值，而是存储它在数组中的索引。这样当往后移动窗口，加入新数字时，我们只需要把队列中索引值小于 新数字索引-窗口大小 的索引值出队就可以了。</p><p>想清楚以上四个问题后，不难写出以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows;</span><br><span class="line">    <span class="keyword">if</span>(num.size() &gt;= size &amp;&amp; size &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; index;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 索引队列的初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!index.empty() &amp;&amp; num[i] &gt;= num[index.back()])</span><br><span class="line">                index.pop_back();</span><br><span class="line"></span><br><span class="line">            index.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 往后移动滑动窗口，直到到达数组尾部，i为新加入数字（窗口尾部）的索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = size; i &lt; num.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 索引队列的队首是当前窗口的最大值，存入maxInWindows数组中</span></span><br><span class="line">            maxInWindows.push_back(num[index.front()]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把索引队列里比窗口尾部数字小的都pop掉，它们不可能成为最大值了</span></span><br><span class="line">            <span class="keyword">while</span>(!index.empty() &amp;&amp; num[i] &gt;= num[index.back()])</span><br><span class="line">                index.pop_back();</span><br><span class="line">            <span class="comment">// 把滑出了滑动窗口的也pop掉</span></span><br><span class="line">            <span class="keyword">if</span>(!index.empty() &amp;&amp; index.front() &lt;= (<span class="keyword">int</span>)(i - size))</span><br><span class="line">                index.pop_front();</span><br><span class="line"></span><br><span class="line">            index.push_back(i); <span class="comment">// 把新数字（当前窗口尾部）的索引加入索引队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        maxInWindows.push_back(num[index.front()]); <span class="comment">// 最后一个滑动窗口的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxInWindows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题66矩阵中的路径">面试题66：矩阵中的路径</h2><h3 id="题目">题目</h3><blockquote><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如下面的矩阵：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a    b    c    e</span><br><span class="line">s    f    c    s</span><br><span class="line">a    d    e    e</span><br></pre></td></tr></table></figure><blockquote><p>包含了一条字符串 <code>&quot;bcced&quot;</code> 的路径。但矩阵中不包含字符串 <code>&quot;abcb&quot;</code> 的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p></blockquote><h3 id="解析">解析</h3><p>这题其实思路相当简单，我们可以直接枚举以矩阵的每一个格子作为路径开头进行深搜的情况，直到能完整匹配字符串就停止。特别注意要使用和输入矩阵同规模的visited矩阵来标记走过的路径，避免重复走过一个格子两次的情况。</p><p>使用一个二重循环来实现枚举就可以了，注意每一次深搜时除了要注意是否匹配，还要注意边界的判断。当发现路径不合适要递归返回时，必须把路径长度减一并且设置好visited矩阵对应的值，这样才算把当前格子移出了路径。另外，搜索的时候，我们是往上下左右四个方向搜索，只要其中一个方向能成功匹配就算找到了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="literal">NULL</span> || rows &lt; <span class="number">1</span> || cols &lt; <span class="number">1</span> || str == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows * cols];</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, rows * cols);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pathLength = <span class="number">0</span>; <span class="comment">// 初始路径长度为0</span></span><br><span class="line">    <span class="comment">// 使用一个二重循环来枚举以矩阵的每一个格子作为路径开头进行深搜的情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; ++row)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; ++col)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hasPathCore(matrix, rows, cols, row, col, str,</span><br><span class="line">                pathLength, visited))</span><br><span class="line">            &#123; <span class="comment">// 只要有一次找到了就算成功，直接返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span>* str, <span class="keyword">int</span>&amp; pathLength, <span class="keyword">bool</span>* visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str[pathLength] == <span class="string">'\0'</span>) <span class="comment">// 字符串匹配完成，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> hasPath = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols</span><br><span class="line">            &amp;&amp; matrix[row * cols + col] == str[pathLength]</span><br><span class="line">            &amp;&amp; !visited[row * cols + col])</span><br><span class="line">    &#123; <span class="comment">// 前四个判断条件用于防止溢出边界，后两个判断条件则是当前格子</span></span><br><span class="line">      <span class="comment">// 与当前字符是否匹配，当前格子是否未使用</span></span><br><span class="line">        ++pathLength;</span><br><span class="line">        visited[row * cols + col] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只要有一个方向匹配完整就算成功</span></span><br><span class="line">        hasPath = hasPathCore(matrix, rows, cols, row, col - <span class="number">1</span>,</span><br><span class="line">                    str, pathLength, visited)</span><br><span class="line">                || hasPathCore(matrix, rows, cols, row - <span class="number">1</span>, col,</span><br><span class="line">                    str, pathLength, visited)</span><br><span class="line">                || hasPathCore(matrix, rows, cols, row, col + <span class="number">1</span>,</span><br><span class="line">                    str, pathLength, visited)</span><br><span class="line">                || hasPathCore(matrix, rows, cols, row + <span class="number">1</span>, col,</span><br><span class="line">                    str, pathLength, visited);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!hasPath)</span><br><span class="line">        &#123; <span class="comment">// 匹配失败时要把格子移出路径，以便进行下一次搜索</span></span><br><span class="line">            --pathLength;</span><br><span class="line">            visited[row * cols + col] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hasPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题67机器人的运动范围">面试题67：机器人的运动范围</h2><h3 id="题目">题目</h3><blockquote><p>地上有一个m行n列的方格。一个机器人从坐标(0,0)的格子开始移动，它每一次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格(35,37)，因为 <code>3+5+3+7=18</code>。但它不能进入方格(35,38)，因为 <code>3+5+3+8=19</code>。请问该机器人能够到达多少个格子？</p></blockquote><h3 id="解析">解析</h3><p>这题比上一题稍微简单一些，不需要枚举矩阵的所有格子，只需要从(0,0)开始，进行一次深搜就可以了。要注意好不能重复计算同一个格子，所以同样使用一个和输入矩阵同规模的visited矩阵来标记。过程主要用递归来实现就可以了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算一个数字的各数位之和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDigitSum</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(number &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += number % <span class="number">10</span>;</span><br><span class="line">        number /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断机器人能否进入坐标为(row,col)的方格</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">bool</span>* visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row &gt;=<span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols      <span class="comment">// 满足四个边界条件</span></span><br><span class="line">        &amp;&amp; getDigitSum(row) + getDigitSum(col) &lt;= threshold <span class="comment">// 行列坐标数位之和小于阈值</span></span><br><span class="line">        &amp;&amp; !visited[row* cols + col])                       <span class="comment">// 并且未计算过</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">movingCountCore</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">bool</span>* visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(check(threshold, rows, cols, row, col, visited))</span><br><span class="line">    &#123; <span class="comment">// 当前格子满足条件，标记并继续往四个方向进行移动</span></span><br><span class="line">        visited[row * cols + col] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        count = <span class="number">1</span> + movingCountCore(threshold, rows, cols,</span><br><span class="line">                    row - <span class="number">1</span>, col, visited)</span><br><span class="line">                + movingCountCore(threshold, rows, cols,</span><br><span class="line">                    row, col - <span class="number">1</span>, visited)</span><br><span class="line">                + movingCountCore(threshold, rows, cols,</span><br><span class="line">                    row + <span class="number">1</span>, col, visited)</span><br><span class="line">                + movingCountCore(threshold, rows, cols,</span><br><span class="line">                    row, col + <span class="number">1</span>, visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows * cols];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows * cols; ++i)</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = movingCountCore(threshold, rows, cols,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer</title>
      <link href="/2020/07/06/%E5%89%91%E6%8C%87offer/6_%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E5%90%84%E9%A1%B9%E8%83%BD%E5%8A%9B/"/>
      <url>/2020/07/06/%E5%89%91%E6%8C%87offer/6_%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E5%90%84%E9%A1%B9%E8%83%BD%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="面试中的各项能力">面试中的各项能力</h1><h2 id="面试题38数字在排序数组中出现的次数">面试题38：数字在排序数组中出现的次数</h2><h3 id="题目">题目</h3><blockquote><p>统计一个数字在排序数组中出现的次数。例如输入排序数组 <code>{1,2,3,3,3,3,4,5}</code> 和数字3，由于3在这个数组中出现了4次，因此输出4。</p></blockquote><h3 id="解析">解析</h3><p>最简单的方法就是顺序查找，然后计数了，这种方法的时间复杂度是O(n)。但是既然题目给定的是一个排序数组，那么就要充分利用好这个优势，我们可以基于<strong>二分查找</strong>来做。</p><p>具体来说我们使用二分查找的方式来分别找到输入数字第一次出现的索引和最后一次出现的索引，然后继续差值就是了。注意数字可能根本没有出现在数组中，这时应返回0。</p><p>实现很简单，修改一下递归二分查找的判定条件就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> length, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(data != <span class="literal">NULL</span> &amp;&amp; length &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> first = GetFirstK(data, length, k, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> last = GetLastK(data, length, k, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(first &gt; <span class="number">-1</span> &amp;&amp; last &gt; <span class="number">-1</span>)</span><br><span class="line">            number = last - first + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到数组中第一个k的下标。如果数组中不存在k，返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFirstK</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> length, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt; end)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> middleIndex = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> middleData = data[middleIndex];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(middleData == k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((middleIndex &gt; <span class="number">0</span> &amp;&amp; data[middleIndex - <span class="number">1</span>] != k)</span><br><span class="line">            || middleIndex == <span class="number">0</span>) <span class="comment">// 前面没有k了，或者当前索引为0没有更前面了</span></span><br><span class="line">            <span class="keyword">return</span> middleIndex;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 前面还有k，继续搜索前半段</span></span><br><span class="line">            end  = middleIndex - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(middleData &gt; k) <span class="comment">// 中位数大于k，继续搜索前半段</span></span><br><span class="line">        end = middleIndex - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>                    <span class="comment">// 中位数小于k，搜索后半段</span></span><br><span class="line">        start = middleIndex + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> GetFirstK(data, length, k, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到数组中最后一个k的下标。如果数组中不存在k，返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLastK</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> length, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt; end)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> middleIndex = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> middleData = data[middleIndex];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(middleData == k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((middleIndex &lt; length - <span class="number">1</span> &amp;&amp; data[middleIndex + <span class="number">1</span>] != k)</span><br><span class="line">            || middleIndex == length - <span class="number">1</span>) <span class="comment">// 后面没有k了，或者当前索引已是最后</span></span><br><span class="line">            <span class="keyword">return</span> middleIndex;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 后面还有k，继续搜索后半段</span></span><br><span class="line">            start  = middleIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(middleData &lt; k) <span class="comment">// 中位数小于k，继续搜索后半段</span></span><br><span class="line">        start = middleIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>                    <span class="comment">// 中位数大于k，搜索前半段</span></span><br><span class="line">        end = middleIndex - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> GetLastK(data, length, k, start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题39_1二叉树的深度">面试题39_1：二叉树的深度</h2><h3 id="题目">题目</h3><blockquote><p>输入一棵二叉树的根节点，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。二叉树结点的定义如下：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                    m_nValue;</span><br><span class="line">    BinaryTreeNode*        m_pLeft;</span><br><span class="line">    BinaryTreeNode*        m_pRight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析">解析</h3><p>第一次看到这题，可能还有点迷茫，需要所有路径都走一次然后取最长路径的长度吗？并不是这样的，其实这题很简单，我们可以从另一个角度来理解树的深度：</p><ul><li>如果树只有一个根结点，则深度为1；</li><li>如果根结点只有左子树，则深度为左子树深度+1；</li><li>如果根结点只有右子树，则深度为右子树深度+1；</li><li>如果根结点既有左子树，又有右子树，则深度为左右子树深度的较大值+1；</li></ul><p>就是这么四种情况，我们可以非常容易地写出递归实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(BinaryTreeNode* pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nLeft = TreeDepth(pRoot-&gt;m_pLeft);</span><br><span class="line">    <span class="keyword">int</span> nRight = TreeDepth(pRoot-&gt;m_pRight);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (nLeft &gt; nRight) ? (nLeft + <span class="number">1</span>) : (nRight + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题39_2判断是否平衡二叉树">面试题39_2：判断是否平衡二叉树</h2><h3 id="题目">题目</h3><blockquote><p>输入一棵二叉树的根结点，判断该树是不是平衡二叉树。如果某二叉树中任意结点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p></blockquote><h3 id="解析">解析</h3><p>有了上一题的思路，我们很容易想到这一题可以逐个结点来判断是否平衡二叉树，也即对每个结点都检查左右子树的深度是否相差1，但是这个做法并不够好，因为它需要多次遍历同一结点，比如二叉树：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      <span class="number">10</span></span><br><span class="line">     /  \</span><br><span class="line">    <span class="number">7</span>    <span class="number">8</span></span><br><span class="line">   /    / \</span><br><span class="line">  <span class="number">5</span>    <span class="number">4</span>   <span class="number">3</span></span><br><span class="line"> /</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>我们在检查根结点10时，需要计算以7和8为根结点的左右子树的深度，按照递归的方式，我们需要先计算出以5，4，3为根结点的这几棵子树的深度。由于以7和8为根结点的左右子树的深度不超过1，所以继续检查。这时我们需要根结点7了，此时又需要再计算一次以5为根结点的子树的深度，所以说<strong>产生了重复计算，效率不高</strong>。</p><p>这里介绍一种只需要遍历每个结点1次的方法。在上面的方法中，我们是由上到下逐层检查，所以每次都需要对当前层下面的层计算一次。只要我们转换一下思路，<strong>由下往上逐层检查，并且把树深作为参数传递然后累加</strong>，就不需要作重复的计算了，所有结点都只需访问1次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution2</span><span class="params">(BinaryTreeNode* pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> IsBalanced(pRoot, &amp;depth);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced</span><span class="params">(BinaryTreeNode* pRoot, <span class="keyword">int</span>* pDepth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *pDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">    <span class="keyword">if</span>(IsBalanced(pRoot-&gt;m_pLeft, &amp;left)</span><br><span class="line">        &amp;&amp; IsBalanced(pRoot-&gt;m_pRight, &amp;right))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = left - right;</span><br><span class="line">        <span class="keyword">if</span>(diff &lt;= <span class="number">1</span> &amp;&amp; diff &gt;= <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *pDepth = <span class="number">1</span> + (left &gt; right ? left : right);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题40数组中只出现一次的数字">面试题40：数组中只出现一次的数字</h2><h3 id="题目">题目</h3><blockquote><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p></blockquote><h3 id="解析">解析</h3><p>第一次看这条题，一点思路都没有，看书中给出的解法时真的被惊艳到了。</p><p>首先，我们要明白题目所说的<strong>只出现一次到底意味着什么</strong>？如果我们把题目换成只有一个出现一次的数字，可以怎么找出来呢？</p><p>这里利用的是<strong>异或的特性</strong>，<strong>两个相同的数异或结果为0，两个不同的数异或结果的二进制表示至少有一位为1</strong>。举个例子，比方说要在数组 <code>20,10,20,30,30</code> 中找出只出现一次的10，那么我们只需要求整个数组异或的结果就可以了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span> xor <span class="number">10</span> xor <span class="number">20</span> xor <span class="number">30</span> xor <span class="number">30</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>结果就是只出现一次的数字。</p><p>但数组中有两个只出现一次的数字，这要怎么找呢？</p><ol><li>首先对整个数组进行异或，所得结果就是那两个只出现一次的数的异或结果，因为这两个数字是不同的，所以结果的二进制表示至少有一位为1；</li><li>从异或结果的二进制表示中找到从右往左第一个为1的位置，它表明<strong>两个只出现一次的数字的二进制表示在这一位上是不同的</strong>；</li><li>按照步骤2中第一个为1的位置将数组分为两部分，一部分在该位置为1，另一部分在该位置为0；</li><li>因为同一个数字的二进制表示也是相同的，所以步骤3划分的数组中，同一个数字会被分到同一边，也即划分后，<strong>问题变成数组中只有一个出现一次的数字，其他数字都出现两次，如何找出那个只出现一次的数字</strong>。</li><li>分别对两个数组求异或结果，得到问题的解。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> length, <span class="keyword">int</span>* num1, <span class="keyword">int</span>* num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span> || length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对整个数组求异或结果</span></span><br><span class="line">    <span class="keyword">int</span> resultExclusiveOR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++ i)</span><br><span class="line">        resultExclusiveOR ^= data[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出异或结果二进制表示中第一个1出现的位置</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> indexOf1 = FindFirstBitIs1(resultExclusiveOR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照indexOf1划分数组并分别求异或结果（也即两个只出现一次的数字）</span></span><br><span class="line">    *num1 = *num2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(IsBit1(data[j], indexOf1))</span><br><span class="line">            *num1 ^= data[j];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *num2 ^= data[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到num从右边数起第一个是1的位</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">FindFirstBitIs1</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> indexBit = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 数字的二进制表示最右边为0，且当前位数不超过int型表示的范围（8*4bytes = 32bits）</span></span><br><span class="line">    <span class="keyword">while</span> (((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &amp;&amp; (indexBit &lt; <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        num = num &gt;&gt; <span class="number">1</span>; <span class="comment">//右移一位</span></span><br><span class="line">        ++ indexBit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> indexBit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断数字num的第indexBit位是不是1</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBit1</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">unsigned</span> <span class="keyword">int</span> indexBit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num = num &gt;&gt; indexBit;</span><br><span class="line">    <span class="keyword">return</span> (num &amp; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题41_1和为s的两个数字">面试题41_1：和为s的两个数字</h2><h3 id="题目">题目</h3><blockquote><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，输出任意一对即可。</p></blockquote><h3 id="解析">解析</h3><p>因为可以输出任意一对，所以只要找到一对就可以了。又因为这是一个递增数组，所以我们只需要维护两个指针behind和ahead，前者从数组开头（最小数字）开始往后扫描，后者从数组末尾（最大数字）开始往前扫描。每一次我们比较两个指针所指数字之和与s的大小关系，如果比s大，我们就往前移动ahead；如果比s小，我们就往后移动behind；如果和s相等，就进行输出。</p><p>这个算法的时间复杂度是O(n)，当ahead与behind相遇时，搜索就结束了，最多也只是扫描一次整个数组。如果数组中确实有和为s的一对数字，这个算法是必然能找到的。因为移动指针时，选择的指针和移动的方向都是必然的，并不需要ahead往后或者behind往前，因为外侧的数字都是已经排除掉，不可能构成指定的和的，这需要自己分析理解一下。</p><p>还是不偷懒了，简单举个例子吧… 比方说有数组 <code>1,2,4,7,11,15</code>，指定s为15。</p><ol><li><code>1+15=16 &gt; 15</code>，往前移动ahead，这很好理解，因为behind已经在最前了，自然不可能再往前移动它来减少和值；</li><li><code>1+11=12 &lt; 15</code>，往后移动behind。为什么不往后移动ahead呢？很简单，因为前面第一步已经验证了<code>1+15=16 &gt; 15</code>，正是因为这样才把ahead往前移的，自然就没有理由又把它移回去了；</li><li><code>2+11=13 &lt; 15</code>，往后移动behind。为什么不往后移动ahead呢？也很简单，因为比2小的1和15加起来都超过s了，那么2加上15的和就更大了，所以不可能往后移动ahead；</li><li><code>4+11=15 = 15</code>，找到了，完成查找。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> length, <span class="keyword">int</span> sum,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span>* num1, <span class="keyword">int</span>* num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">1</span> || num1 == <span class="literal">NULL</span> || num2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ahead = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> behind = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(ahead &gt; behind)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curSum = data[ahead] + data[behind];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(curSum == sum)</span><br><span class="line">        &#123;</span><br><span class="line">            *num1 = data[behind];</span><br><span class="line">            *num2 = data[ahead];</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(curSum &gt; sum)</span><br><span class="line">            ahead --;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            behind ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题41_2和为s的连续正数序列">面试题41_2：和为s的连续正数序列</h2><h3 id="题目">题目</h3><blockquote><p>输入一个正数s，打印出所有和为s的连续正数序列（至少会有两个数）。例如输入15，由于 <code>1+2+3+4+5 = 4+5+6 = 7+8 = 15</code>，所以结果打印出3个连续序列 <code>1~5</code>、<code>4~6</code>和<code>7~8</code>。</p></blockquote><h3 id="解析">解析</h3><p>首先审审题，这里不再给出数组，而是说找出<strong>连续正数数列</strong>，也即从 <code>1,2,3,4,.....</code> 这个正数序列中找。而所谓“序列”，指的是至少要包含两个数字。还有一点就是题目要求<strong>打印出所有</strong>符合要求的序列。</p><p>因为正数序列延伸到正无穷，我们自然没有办法说从序列最大值开始减少。我们转换一种思路，维护small和big两个指针来指向当前序列最小和最大的数，从和最小的序列开始找起，也即只包含两个整数的序列 <code>1,2</code>（small初始化为1，big初始化为2）。</p><ul><li>当前序列和小于s时，通过往后移动big来把新的数字补充进序列，使得序列的和能更接近s。</li><li>当前序列和大于s时，通过往后移动small来把小的数字丢掉，使得序列的和能更接近s。</li><li>当前序列和为s时，打印序列，并往后移动big来把新的数字补充进序列来打破平衡，使得small可以往后移动，从而有机会找到符合要求的新序列。</li></ul><p>注意了，什么时候停止移动呢？我们不难发现，当small大于 <code>(1 + s) / 2</code> 之后，任意两个数和都必定大于s，所以终止条件就是small大于等于 <code>(1 + s) / 2</code>。</p><p>还有一个小trick，计算序列和是一件挺麻烦的事（虽然可以用公式，但是乘除法还是开销蛮大的）。这里我们不需要这样做，因为新序列和旧序列只是相差一个元素而已。我们维护一个变量curSum，在删除/补充数字时，把curSum更新一下就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindContinuousSequence</span><span class="params">(<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum &lt; <span class="number">3</span>) <span class="comment">// 不存在和小于3的连续正数序列，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> small = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> big = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> middle = (<span class="number">1</span> + sum) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> curSum = small + big;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// small超过middle以后就不可能再有符合要求的序列产生了</span></span><br><span class="line">    <span class="comment">// 因为此后的任意两个数和都必定大于sum</span></span><br><span class="line">    <span class="keyword">while</span>(small &lt; middle)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(curSum == sum)</span><br><span class="line">            PrintContinuousSequence(small, big);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curSum &gt; sum &amp;&amp; small &lt; middle)</span><br><span class="line">        &#123;</span><br><span class="line">            curSum -= small;</span><br><span class="line">            small ++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curSum == sum)</span><br><span class="line">                PrintContinuousSequence(small, big);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加大big有两个意义</span></span><br><span class="line">        <span class="comment">// 一是curSum小于sum时补充序列，使得序列的和能更接近sum</span></span><br><span class="line">        <span class="comment">// 二是curSum等于sum时打破平衡，使得small可以往后移动，找到符合要求的新序列</span></span><br><span class="line">        big ++;</span><br><span class="line">        curSum += big;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintContinuousSequence</span><span class="params">(<span class="keyword">int</span> small, <span class="keyword">int</span> big)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = small; i &lt;= big; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题42_1翻转单词顺序">面试题42_1：翻转单词顺序</h2><h3 id="题目">题目</h3><blockquote><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串 <code>&quot;I am a student.&quot;</code>，则输出 <code>&quot;student. a am I&quot;</code>。</p></blockquote><h3 id="解析">解析</h3><p>这条题我们可以分为两步处理：</p><ol><li>翻转整个句子</li><li>以空格和结束符 <code>'\0'</code> 划分，逐个单词翻转</li></ol><p>写成代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 翻转两个字符指针之间的内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">char</span> *pBegin, <span class="keyword">char</span> *pEnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pBegin == <span class="literal">NULL</span> || pEnd == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pBegin &lt; pEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> temp = *pBegin;</span><br><span class="line">        *pBegin = *pEnd;</span><br><span class="line">        *pEnd = temp;</span><br><span class="line"></span><br><span class="line">        pBegin ++, pEnd --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">ReverseSentence</span><span class="params">(<span class="keyword">char</span> *pData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pData == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *pBegin = pData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *pEnd = pData;</span><br><span class="line">    <span class="keyword">while</span>(*pEnd != <span class="string">'\0'</span>)</span><br><span class="line">        pEnd ++;</span><br><span class="line">    pEnd--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 翻转整个句子</span></span><br><span class="line">    Reverse(pBegin, pEnd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 翻转句子中的每个单词</span></span><br><span class="line">    pBegin = pEnd = pData;</span><br><span class="line">    <span class="keyword">while</span>(*pBegin != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*pBegin == <span class="string">' '</span>) <span class="comment">// 处理连续空格，末字符为空格的情形</span></span><br><span class="line">        &#123;</span><br><span class="line">            pBegin ++;</span><br><span class="line">            pEnd ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*pEnd == <span class="string">' '</span> || *pEnd == <span class="string">'\0'</span>) <span class="comment">// 找到了划分单词的地方</span></span><br><span class="line">        &#123;</span><br><span class="line">            Reverse(pBegin, --pEnd); <span class="comment">// 翻转整个单词</span></span><br><span class="line">            pBegin = ++pEnd;         <span class="comment">// 令pBegin跳到下一个单词的开头</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pEnd ++; <span class="comment">// 单词未结束，继续找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题42_2左旋转字符串">面试题42_2：左旋转字符串</h2><h3 id="题目">题目</h3><blockquote><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如输入字符串 <code>&quot;abcdefg&quot;</code> 和数字2，该函数将返回左旋转2位得到的结果 <code>&quot;cdefgab&quot;</code>。</p></blockquote><h3 id="解析">解析</h3><p>这题很有意思，我们先再分析一下上一题翻转单词顺序，比方说有一个句子 <code>Hello world</code>，上一题就是把这个句子处理为 <code>world Hello</code>。不看空格的话，这实际上可以看作是把一部分字符转移到字符串的尾部，也即对这个字符串左旋了5位。</p><p>有了这样的启发，不难发现，我们可以先按左旋的位数把数组分割为两部分，然后分别翻转这两部分，最后翻转整个数组就完成左旋转这个操作了。</p><p>书中给出的代码是按照这样的思路实现的，和上一题有一点点差别，因为上一题是先翻转整个字符串，再分别翻转各个部分。这个顺序调转一下其实也是可以的，这里先翻转部分，再翻转整体的原因是先翻转整体之后，左旋位数所指的位置就不是划分两个部分的地方了。</p><p>还是举个例子吧~避免自己再看到的时候会懵圈。还是 <code>helloworld</code>，左旋2位，那么划分两部分的位置就在e和l之间，正确答案是 <code>lloworldhe</code>。</p><ul><li><p>如果先翻转整个字符串，字符串变为 <code>dlrowolleh</code>，2指向的地方就变成了l和r之间了，根据这个划分来翻转部分得到的是错误答案 <code>ldhellowor</code>。当然，其实真要算出正确的划分位置也不难…就是字符串长度10-左旋位数2=8嘛…可以解出答案 <code>lloworldhe</code>，所以还是可以正确划分的，改改就好了。</p></li><li><p>如果先翻转部分，按左旋位数2划分出两个部分，分别翻转后，字符串变为 <code>ehdlrowoll</code>，这时再翻转整个字符串，就得到了正确答案 <code>lloworldhe</code>。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 翻转两个字符指针之间的内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">char</span> *pBegin, <span class="keyword">char</span> *pEnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pBegin == <span class="literal">NULL</span> || pEnd == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pBegin &lt; pEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> temp = *pBegin;</span><br><span class="line">        *pBegin = *pEnd;</span><br><span class="line">        *pEnd = temp;</span><br><span class="line"></span><br><span class="line">        pBegin ++, pEnd --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">LeftRotateString</span><span class="params">(<span class="keyword">char</span>* pStr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pStr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nLength = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">strlen</span>(pStr));</span><br><span class="line">        <span class="keyword">if</span>(nLength &gt; <span class="number">0</span> &amp;&amp; n &gt; <span class="number">0</span> &amp;&amp; n &lt; nLength)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span>* pFirstStart = pStr;</span><br><span class="line">            <span class="keyword">char</span>* pFirstEnd = pStr + n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span>* pSecondStart = pStr + n;</span><br><span class="line">            <span class="keyword">char</span>* pSecondEnd = pStr + nLength - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 翻转字符串的前面n个字符</span></span><br><span class="line">            Reverse(pFirstStart, pFirstEnd);</span><br><span class="line">            <span class="comment">// 翻转字符串的后面部分</span></span><br><span class="line">            Reverse(pSecondStart, pSecondEnd);</span><br><span class="line">            <span class="comment">// 翻转整个字符串</span></span><br><span class="line">            Reverse(pFirstStart, pSecondEnd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题43n个骰子的点数">面试题43：n个骰子的点数</h2><h3 id="题目">题目</h3><blockquote><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p></blockquote><h3 id="解析">解析</h3><p>n个骰子朝上一面的点数之和最小是n，最大是6n，一共有6n-n+1种可能。而n个骰子中每个骰子在一次投掷中可能的取值都为1~6，因此将它们的点数排成序列的话有6^n种不同的排列组合。</p><p>最简单的做法是使用递归来把这6^n种排列组合都试一次，每次排列完毕得到和值就在计数数组中为这个和值对应的计数加一。最后把计数数组每个计数除以6^n就得到出现的概率了。</p><p>上面这种做法的代码实现比较简单，但是当n变大时，递归实现的效率会变得相当低。<strong>因为这种做法其实有很多重复的计算</strong>，怎么理解呢？举个例子，假设加入一个新骰子时，我们想计算得到和为s的次数，它实际上等于和为s-1，s-2，s-3，s-4，s-5，s-6的次数的和，因为新骰子为和值贡献的只可能是1~6中的一个。如果按照递归的思路，我们要从第一个骰子开始算；但如果我们能保证和值生成的顺序就能有效地利用之前计算出的结果，从而把重复计算节省下来。</p><p>具体来说，代码实现的时候还是有不少需要注意的地方。可以简单分为以下几点：</p><ol><li><p><strong>新加入骰子能产生的和值和未加入之前可能会有重叠</strong>，比方说一个骰子时和值可以取2，两个骰子时和值也可以取2，那么怎样去更新和值的计数呢？要注意！新加入骰子后和值为3是基于未加入前和值为1和2的计数来计算的，如果我们把和值为2的计数更新为加入新骰子的情况，然后再计算和值为3的计数就会得到了错误的结果；</p></li><li><p>计数数组需要初始化，只有第一个骰子加入后才可以使用上面提到的形式来计算和值的出现次数；</p></li><li><p>并不是每一个和值s都可以分拆为s-1，s-2，s-3，s-4，s-5，s-6这六项，比如和值为3就只可分拆为和值为2（即s-1）以及1（即s-2）这两项；</p></li><li><p>新加入骰子可能会令和值的出现次数为0，比方说加入第二个骰子时，和的最小值变为2，此时和值1的出现次数就要更新为0了。</p></li></ol><p>这里第1点比较重要，为了不会发生更新覆盖导致错误结果的情况，我们不妨<strong>使用两个数组来存储和值的计数</strong>。可以看代码注释加深理解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintProbability_Solution2</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number &lt; <span class="number">1</span>) <span class="comment">// 至少也要有1个骰子</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用两个数组来存储和值的计数</span></span><br><span class="line">    <span class="keyword">int</span>* pProbabilities[<span class="number">2</span>];</span><br><span class="line">    pProbabilities[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[g_maxValue * number + <span class="number">1</span>];</span><br><span class="line">    pProbabilities[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[g_maxValue * number + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数数组初始化为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g_maxValue * number + <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pProbabilities[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        pProbabilities[<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">// 用于标志使用哪一个计数数组</span></span><br><span class="line">    <span class="comment">// 加入第一个骰子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g_maxValue; ++i)</span><br><span class="line">        pProbabilities[flag][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次加入其它骰子，k为当前骰子数目</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= number; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 加入第k个骰子时，最小值更新为k，所以和值 `0~k-1` 的出现次数变为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">            pProbabilities[<span class="number">1</span> - flag][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加入第k个骰子时，产生的和值范围是[k, 6*k]，依次计算出它们的出现次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= g_maxValue * k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pProbabilities[<span class="number">1</span> - flag][i] = <span class="number">0</span>; <span class="comment">//初始化为0</span></span><br><span class="line">            <span class="comment">// 分拆和值，注意不是所有和值都能分拆出6项，所以要设置j&lt;=i。</span></span><br><span class="line">            <span class="comment">// 特别注意j=i这种状况，可以举例分析一下</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i &amp;&amp; j &lt;= g_maxValue; ++j)</span><br><span class="line">                pProbabilities[<span class="number">1</span> - flag][i] += pProbabilities[flag][i - j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 改变标志位，使加入新骰子后计数不会覆盖未加入前的结果</span></span><br><span class="line">        flag = <span class="number">1</span> - flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> total = <span class="built_in">pow</span>((<span class="keyword">double</span>)g_maxValue, number);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = number; i &lt;= g_maxValue * number; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> ratio = (<span class="keyword">double</span>)pProbabilities[flag][i] / total;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: %e\n"</span>, i, ratio);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] pProbabilities[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] pProbabilities[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能有人还会疑惑，使用两个数组来计数，那最后输出那个数组是否就包含了所有和值的计数呢？会不会有遗漏呢？其实，确实是包含了全部的，因为每次用于赋值的那个计数数组，计数都包含了和值0~加入新骰子后的最大和值，没有遗漏。另外，我们最后输出应该用什么标志位也应该很清楚，应该使用对应于最后一次用于赋值的数组的那个标志位。</p><h2 id="面试题44扑克牌的顺子">面试题44：扑克牌的顺子</h2><h3 id="题目">题目</h3><blockquote><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2~10为数字本身，A为1，J为11，Q为12，K为13，而大、小王可以看成任意数字。</p></blockquote><h3 id="解析">解析</h3><p>这题还挺有意思的，在转换为计算机语言时，手牌其实就是一个数组，为了方便，不妨把大、小王先看作数字0。要判断是否顺子，我们可以先对数组排序，然后分别统计以下0的数目，以及需要填补的间隔大小。最后判断间隔能否被填补好就可以了。</p><p>在数组排序这一步，书中给出的是使用qsort快排函数以及自定义的比较函数实现O(n logn)d的排序，我们也可以基于哈希表来实现O(n)的排序。不过鉴于n的规模并不大，所以这两种排序算法相差不大。基于O(n)的排序可以看一下这篇文章：<a href="http://www.cnblogs.com/hellogiser/p/sort-ages-with-hashtable.html" target="_blank" rel="noopener">特殊的O(n)时间排序[sort ages with hashtable]</a>。其实就是先扫一遍数组用哈希表计数，然后扫一遍哈希表重排数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个参数分别是手牌和手牌数（题目中是5 ）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsContinuous</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">NULL</span> || length &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    qsort(numbers, length, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), compare);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numberOfZero = <span class="number">0</span>; <span class="comment">// 大、小王的张数</span></span><br><span class="line">    <span class="keyword">int</span> numberOfGap = <span class="number">0</span>;  <span class="comment">// 需要填补的牌数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计数组中0的个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length &amp;&amp; numbers[i] == <span class="number">0</span>; ++i)</span><br><span class="line">        ++ numberOfZero;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计数组中的间隔数目</span></span><br><span class="line">    <span class="keyword">int</span> small = numberOfZero;</span><br><span class="line">    <span class="keyword">int</span> big = small + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(big &lt; length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 两个数相等，有对子，不可能是顺子</span></span><br><span class="line">        <span class="keyword">if</span>(numbers[small] == numbers[big])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个数不等，计算间隔，两张牌相差1也即相邻时间隔为0</span></span><br><span class="line">        numberOfGap += numbers[big] - numbers[small] - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 继续比较下两张牌</span></span><br><span class="line">        small = big;</span><br><span class="line">        ++big;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若大、小王能把间隔都填补上或者不需要填补间隔就会返回true</span></span><br><span class="line">    <span class="keyword">return</span> (numberOfGap &gt; numberOfZero) ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *arg1, <span class="keyword">const</span> <span class="keyword">void</span> *arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> *(<span class="keyword">int</span>*)arg1 - *(<span class="keyword">int</span>*)arg2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题45圆圈中最后剩下的数字">面试题45：圆圈中最后剩下的数字</h2><h3 id="题目">题目</h3><blockquote><p><code>0,1,...,n-1</code> 这n个数字排成一个圆圈，从数字0开始每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p></blockquote><h3 id="解析">解析</h3><p>最简单的做法，用一个环形链表来模拟就好了，每走m-1步删除一个元素，若干轮后就能得到最后一个数字了。在c++中，我们可以用标准库提供的list容器来实现，list是双向循环链表，插入删除等操作都封装好了，使用很方便。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法1====================</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化环形链表</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; numbers;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        numbers.push_back(i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator current = numbers.begin();</span><br><span class="line">    <span class="keyword">while</span>(numbers.size() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++ i)</span><br><span class="line">        &#123;<span class="comment">// 先走m-1步，找到这一轮的第m个数</span></span><br><span class="line">            current ++;</span><br><span class="line">            <span class="comment">// 如果到底了尾部就返回头部，保证环形链表的遍历顺序</span></span><br><span class="line">            <span class="comment">// 注意list.end()指向的是最后一个元素后面的一个位置</span></span><br><span class="line">            <span class="keyword">if</span>(current == numbers.end())</span><br><span class="line">                current = numbers.begin();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记住这一轮第m+1个数的位置</span></span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator next = ++ current;</span><br><span class="line">        <span class="keyword">if</span>(next == numbers.end())</span><br><span class="line">            next = numbers.begin();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除这一轮的第m个数</span></span><br><span class="line">        -- current;</span><br><span class="line">        numbers.erase(current);</span><br><span class="line">        current = next; <span class="comment">// 从第m+1个数开始新的一轮</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的就是我们使用迭代器来遍历数组，其实就是用一个指针来走list上的结点，走到list.end()就证明已经到达最后了，此时指向的不是最后一个元素（我猜指的应该是NULL），我们需要把迭代器移动回链表头。</p><p>另外，在删除时，其实是把指针指向的内存空间释放掉，封装好的erase函数会帮我们把断开的链表接好，但是我们还是需要用一个指针预先记住下一个数的位置，不能删除之后就找不到它了。</p><p>假设链表长为n，每m个数删除一个，那么上面的解法复杂度就是O(mn)，因为每删除一个数字都要经历m个操作。而且这种解法还要借助一个O(n)的环形链表来辅助。有没有更好的方法呢？</p><p>这里给出一种时间复杂度为O(n)，空间复杂度为O(1)的解法。</p><hr><p>给定n，把数列 <code>0,1,2,3,...,n-2,n-1</code> 这n个数字围成一圈，从0开始走，每次删除第m个数字，求最后剩下的数字。那么第一个被删除的数字就是 <code>(m-1)%n</code>。</p><p>为了方便，先把数字 <code>(m-1)%n</code> 记为k，删除k以后数列剩下n-1个数字。在下一轮中，k+1成为第一个被遍历的数字，k-1则成为最后一个。我们不妨做个映射p：<code>p(x) = (x-k-1)%n</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">k+<span class="number">1</span> -&gt; <span class="number">0</span></span><br><span class="line">k+<span class="number">2</span> -&gt; <span class="number">1</span></span><br><span class="line">...</span><br><span class="line">n<span class="number">-1</span> -&gt; n-k<span class="number">-2</span></span><br><span class="line"><span class="number">0</span>   -&gt; n-k<span class="number">-1</span></span><br><span class="line"><span class="number">1</span>   -&gt; n-k</span><br><span class="line">...</span><br><span class="line">k<span class="number">-2</span> -&gt; n<span class="number">-3</span></span><br><span class="line">k<span class="number">-1</span> -&gt; n<span class="number">-2</span></span><br></pre></td></tr></table></figure><p>此时，问题变为了： 给定n-1，把数列 <code>0,1,2,3,...,n-3,n-2</code> 这n-1个数字围成一圈，从0开始走，每次删除第m个数字，求最后剩下的数字。也即<strong>映射后，问题变为了相同的形式</strong>！这样我们就可以很简单地利用递归或者循环来求解了！</p><p>进一步分析一下，假设原问题的解是 <code>f(n,m)</code>，映射后问题的解是 <code>f(n-1,m)</code>，我们只要<strong>对映射后问题的解进行逆映射就能得到和原文题同样的解</strong>！也即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n,m) = p^(<span class="number">-1</span>)[f(n<span class="number">-1</span>,m)]</span><br></pre></td></tr></table></figure><p>其中逆映射 <code>p^(-1)(x) = (x+k+1)%n</code>。而且有 <code>k=(m-1)%n</code>，因此：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(n,m) = p^(<span class="number">-1</span>)[f(n<span class="number">-1</span>,m)]</span><br><span class="line">       = [f(n<span class="number">-1</span>,m)+(m<span class="number">-1</span>)%n+<span class="number">1</span>]%n</span><br><span class="line">       = [f(n<span class="number">-1</span>,m)+m]%n</span><br></pre></td></tr></table></figure><p>得到通项公式后，我们可以基于循环来实现，注意初项的设置（即n为1时问题的解）：</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法2====================</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>; <span class="comment">// 当n为1，数列中只有0，问题的解就是0</span></span><br><span class="line">    <span class="comment">// 从长度为1的数列开始算，i=数列长度+1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)</span><br><span class="line">        last = (last + m) % i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题46求12n">面试题46：求1+2+…+n</h2><h3 id="题目">题目</h3><blockquote><p>求 <code>1+2+...+n</code>，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（<code>A?B:C</code>）。</p></blockquote><h3 id="解析">解析</h3><p>这题目不属于数据结构和算法的范畴，我不是太关心，它更偏向于对C++语言特性的考查。不过其他编程语言也有共性，所以这里还是简单地进行一下解析。</p><p>方法一借助构造函数和静态变量求解，把累加逻辑隐藏在构造函数中，然后创建n个实例来达到累加的目的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法一====================</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Temp() &#123; ++ N; Sum += N; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123; N = <span class="number">0</span>; Sum = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">GetSum</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Sum; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> Sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> Temp::N = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> Temp::Sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Sum_Solution1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Temp::Reset();</span><br><span class="line"></span><br><span class="line">    Temp *a = <span class="keyword">new</span> Temp[n];</span><br><span class="line">    <span class="keyword">delete</span> []a;</span><br><span class="line">    a = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Temp::GetSum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二借助两个虚函数实现递归功能，类A的Sum用于终止条件，类B的Sum用于不断累加和递归：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法二====================</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line">A* Array[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Sum</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Sum</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// n是数值变量，!!n可以把它转换为布尔类型，非零-&gt;true，0-&gt;false</span></span><br><span class="line">        <span class="comment">// 所以当n未到0时，会调用类B的Sum累加，这就类似递归的逻辑</span></span><br><span class="line">        <span class="comment">// 最后n减至0时调用类A返回0，终止递归。</span></span><br><span class="line">        <span class="keyword">return</span> Array[!!n]-&gt;Sum(n<span class="number">-1</span>) + n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    Array[<span class="number">0</span>] = &amp;a;</span><br><span class="line">    Array[<span class="number">1</span>] = &amp;b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> value = Array[<span class="number">1</span>]-&gt;Sum(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三与二的思路是类似的，在纯C环境中没有虚函数，可以用函数指针来模拟：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法三====================</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*fun)</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Solution3_Teminator</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Sum_Solution3</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> fun f[<span class="number">2</span>] = &#123;Solution3_Teminator, Sum_Solution3&#125;;</span><br><span class="line">    <span class="keyword">return</span> n + f[!!n](n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法四也是模拟递归，但借助的是模版类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法四====================</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">unsigned</span> <span class="keyword">int</span> n&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Sum_Solution4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> Value &#123; N = Sum_Solution4&lt;n - <span class="number">1</span>&gt;::N + n&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Sum_Solution4</span>&lt;1&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> Value &#123; N = <span class="number">1</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Sum_Solution4</span>&lt;0&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> Value &#123; N = <span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="面试题47不用加减乘除做加法">面试题47：不用加减乘除做加法</h2><h3 id="题目">题目</h3><blockquote><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、×、÷四则运算符号。</p></blockquote><h3 id="解析">解析</h3><p>不能用四则运算符号，那么剩下的选择就是位运算了。<strong>怎么用位运算模拟加法</strong>呢？</p><p>我们先不急着分析基于二进制的位运算，从十进制的角度来看，加法可以怎样分解呢？不妨举个例子，计算 <code>915+87</code>：</p><ol><li>首先不管进位，对915和87逐位相加，百位9+0=9，十位1+8=9，个位5+7=2（不管进位）；</li><li>然后我们处理进位1，它由个位产生，我们需要把它<strong>左移</strong>一位，加到十位上，十位9+1=0（不管进位）；</li><li>因为还是有进位，所以要继续处理。这次进位1由十位产生，我们同样把它左移一位，加到百位上，百位9+1=0（不管进位）；</li><li>因为还是有进位，所以要继续处理。这次进位1由百位产生，我们同样把它左移一位，加到千位上，千位0+1=1；</li><li>没有进位，结束运算，得到结果1002。</li></ol><p>简单来说，<strong>每一次加法可以分成（1）不管进位相加、（2）获得进位 和 （3）处理进位 这三步</strong>，其中第三步其实又是一次加法，所以其实是重复第一步和第二步，直到第二步获得的进位为0，也即不需再进位时结束。还有注意一点，上面例子中每次加法只有一个进位，实际上可能有多个进位，这时流程也是一样的。</p><p>好了，有了以上分析，在使用位运算模拟时怎么做呢？</p><p>首先看步骤1，不管进位相加，那么对应二进制就是 <code>1和0得1</code>，<code>0和1得1</code>，<code>0和0得0</code>，<code>1和1得0</code>。是的，这一步对应于<strong>异或操作</strong>。</p><p>然后看步骤2，怎么获得进位，并且把它们放在正确的位置上呢？其实很简单，因为二进制只有两个数字这一位都是1才会进位，所以我们可以<strong>用位与获得产生进位的位置</strong>，注意了，<strong>产生进位的位置和进位要作用到的位置是不同的</strong>，所以还要对位与结果<strong>左移一位</strong>。</p><p>最后我们判断一下步骤2获得的进位是否为0，为0就结束；不为0就继续对步骤1和步骤2的结果做加法，也即继续重复步骤1和步骤2。</p><p>写成代码也非常简洁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum, carry;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum = num1 ^ num2;</span><br><span class="line">        carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        num1 = sum;</span><br><span class="line">        num2 = carry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(num2 != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题48不能被继承的类">面试题48：不能被继承的类</h2><h3 id="题目">题目</h3><blockquote><p>用C++设计一个不能被继承的类。</p></blockquote><h3 id="解析">解析</h3><p>这题目也不属于数据结构和算法的范畴，我不是太关心，更偏向于对C++对象设计语法的考查。</p><p>方法一把构造函数设为私有函数，当别的类试图继承它时，会自动调用它的构造函数和析构函数，从而导致编译出错。因此这样设计的类是无法被继承的。我们可以通过一个公有函数来获取它的实例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法一====================</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SealedClass1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> SealedClass1* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SealedClass1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeleteInstance</span><span class="params">( SealedClass1* pInstance)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> pInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SealedClass1() &#123;&#125;</span><br><span class="line">    ~SealedClass1() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法二利用虚拟继承和友元类型，就不详细解释了。想要深入探究的话自己查找资料就好了~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法二====================</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">MakeSealed</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MakeSealed() &#123;&#125;</span><br><span class="line">    ~MakeSealed() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SealedClass2</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> MakeSealed&lt;SealedClass2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SealedClass2() &#123;&#125;</span><br><span class="line">    ~SealedClass2() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer</title>
      <link href="/2020/07/06/%E5%89%91%E6%8C%87offer/5_%E4%BC%98%E5%8C%96%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E6%95%88%E7%8E%87/"/>
      <url>/2020/07/06/%E5%89%91%E6%8C%87offer/5_%E4%BC%98%E5%8C%96%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E6%95%88%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<h1 id="优化时间和空间效率">优化时间和空间效率</h1><h2 id="面试题29数组中出现次数超过一半的数字">面试题29：数组中出现次数超过一半的数字</h2><blockquote><p>题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组 <code>{1，2，3，2，2，2，5，4，2}</code>。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。</p></blockquote><h3 id="解析">解析</h3><p>其实对于一个排序数组来说，要找出这个数字是很简单的，只用遍历一次数组来计数就可以了。但是要排序的话时间复杂度至少也是O(n*logn)，有没有O(n)的方法呢？</p><p>有的，首先介绍一种基于partition函数的方法。partition函数用于在快排中把一个数字放到合适的位置上，使得这个数字的左边都比它小，右边都比它大。题目要求找出出现次数超过一半的数字，那么这个数字在排序数组中有什么特点呢？答案是<strong>出现次数超过数组长度的一半的数字必然会是中位数</strong>。</p><p>于是，我们就可以通过多次调用partition函数来找这个数。partition函数随机选取范围内的一个数放到合适的位置，如果位置比中位数前，那就缩小范围到这个数和数组末尾之间；如果比中位数后，那就缩小范围到数组开头到这个数之间；如果这个位置恰是中位数的位置，那就成功找到了。</p><p>注意，上面只是一种<strong>快速找到中位数</strong>的方法，出现次数有没有超过数组长度的一半，还得遍历一次数组对这个数的出现次数进行计数。</p><p>基于partition函数的方法算法复杂度分析有一定困难，但总的来说还是可以认为是O(n)的算法。有一个缺点是<strong>需要改变数组</strong>，这在实际任务中不一定被允许。</p><p>下面再介绍另一种更直观的O(n)解法。</p><p>所谓“出现的次数超过数组长度的一半”，其实可以理解为<strong>这个数字出现的次数比其他全部数字出现次数的总和还要多</strong>。基于这个思路，我们可以想出下面的解法：</p><ol><li>初始化变量result为数组的第一个元素，初始化变量times为1</li><li>遍历数组<ul><li>如果times为0，把result换为当前数字</li><li>如果result不等于当前数字，则times-1</li><li>如果result等于当前数字，则times+1</li></ul></li><li>检查result出现次数是否超过数组长度的一半</li></ol><p>如果数组中真的存在一个数出现的次数超过数组长度的一半，那么它必定会是最后的result。但是，注意了，是不是最后的result一定就是题目要求的数字呢？并不是的！有可能数组根本就没有这样的数字，所以类似上一种解法，我们最后要进行一次遍历检查。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> g_bInputInvalid = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckInvalidArray</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_bInputInvalid = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">NULL</span> &amp;&amp; length &lt;= <span class="number">0</span>)</span><br><span class="line">        g_bInputInvalid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> g_bInputInvalid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckMoreThanHalf</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> length, <span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] == number)</span><br><span class="line">            times++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isMoreThanHalf = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(times * <span class="number">2</span> &lt;= length)</span><br><span class="line">    &#123;</span><br><span class="line">        g_bInputInvalid = <span class="literal">true</span>;</span><br><span class="line">        isMoreThanHalf = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isMoreThanHalf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题30最小的k个数">面试题30：最小的k个数</h2><blockquote><p>题目：输入n个整数，找出其中最小的k个数。例如输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p></blockquote><h3 id="解析">解析</h3><p>和上一题那样，我们可以使用O(n)的基于partition函数的解法，因为题目只要求找出最小的k个数，没有说这k个数还得排序好返回。所以只要partition函数返回的下标是k-1就结束了，如果不是就根据情况缩小范围即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法1====================</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetLeastNumbers_Solution1</span><span class="params">(<span class="keyword">int</span>* input, <span class="keyword">int</span> n, <span class="keyword">int</span>* output, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(input == <span class="literal">NULL</span> || output == <span class="literal">NULL</span> || k &gt; n || n &lt;= <span class="number">0</span> || k &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = Partition(input, n, start, end);</span><br><span class="line">    <span class="keyword">while</span>(index != k - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; k - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            end = index - <span class="number">1</span>;</span><br><span class="line">            index = Partition(input, n, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            start = index + <span class="number">1</span>;</span><br><span class="line">            index = Partition(input, n, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">        output[i] = input[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于partition函数求解一个不好的地方就是会改变数组。有没有一种不改变数组但又时间复杂度相对小的解法呢？有的，就是<strong>基于最大堆</strong>的算法，复杂度为O(n logk)，k设定为堆的大小。</p><p>具体来说，我们依次读入数组的n个整数。如果最大堆中已有的数字少于k个，则直接把这次读入的整数放入容器中；如果最大堆中已经满了，则把堆顶（最大元素）和这次读入的整数作比较，如果堆顶较小则不需修改，堆顶较大则删除堆顶，并且插入这次读入的整数。</p><p>这里不讨论怎样实现最大堆，直接使用C++中的multiset来实现（multiset与set都是<strong>基于红黑树实现</strong>的，区别在于<strong>multiset允许有重复元素</strong>），可以把它看成一个序列，插入/删除都能在O(logk)的时间内完成，而且<strong>能时刻保证序列中的数是有序的</strong>。</p><p>基于最大堆的解法比基于partition的解法要慢一些，但是！这种解法不仅不需要改变原数组（所有操作都在堆里进行），而且<strong>适合处理海量数据</strong>。因为数据太多时无法一次载入内存，只能从辅助存储空间（比如硬盘）分批读入，而基于最大堆的解法就允许我们每次读入一个数字，直到遍历完毕也就处理完了（当然，k还是不能超出内存的限制的）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法2====================</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt; &gt;            intSet;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt; &gt;::iterator  setIterator;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetLeastNumbers_Solution2</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, intSet&amp; leastNumbers, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    leastNumbers.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k &lt; <span class="number">1</span> || data.size() &lt; k)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator iter = data.begin();</span><br><span class="line">    <span class="keyword">for</span>(; iter != data.end(); ++ iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((leastNumbers.size()) &lt; k)</span><br><span class="line">            leastNumbers.insert(*iter);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            setIterator iterGreatest = leastNumbers.begin();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(*iter &lt; *(leastNumbers.begin()))</span><br><span class="line">            &#123;</span><br><span class="line">                leastNumbers.erase(iterGreatest);</span><br><span class="line">                leastNumbers.insert(*iter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题31连续子数组的最大和">面试题31：连续子数组的最大和</h2><h3 id="题目">题目</h3><blockquote><p>输入一个整型数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。</p></blockquote><h3 id="解析">解析</h3><p>这题初看之下，似乎有些难度。但实际上思路是很简单的，使用两个变量存储当前子数组的和（初始化为0）以及最大的和（初始化为0x80000000，即int类型的最小负数），求解的过程可以分为以下几种情况：</p><ol><li><p>当前和为负，此时如果把新的数字并入连续子数组，所得的和还没有这个数字本身大。所以后续再并入其它数字组成数组的和要比单独这个数字并入后续数字组成数组的和小。于是把当前连续子数组舍弃掉，然后往空数组并入新的数字即可（也即把当前子数组的和设为新数字的值）；</p></li><li><p>当前和非负，这时直接累加新数字就可以了，即使新数字是负数，后续加入其它数字连成的数组也有可能产生更大的和；</p></li><li><p>如果新产生的和比最大和要大，那就更新最大和。</p></li></ol><p>最后，应该注意，<strong>输入不合法时应返回什么</strong>。这里设定返回0，并且为了和最大和为0的情况区分开，采用了一个全局标志来进行标识。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> g_InvalidInput = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span> *pData, <span class="keyword">int</span> nLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((pData == <span class="literal">NULL</span>) || (nLength &lt;= <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        g_InvalidInput = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_InvalidInput = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nCurSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nGreatestSum = <span class="number">0x80000000</span>; <span class="comment">// 初始化为最小负数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nCurSum &lt;= <span class="number">0</span>)</span><br><span class="line">            nCurSum = pData[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nCurSum += pData[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nCurSum &gt; nGreatestSum)</span><br><span class="line">            nGreatestSum = nCurSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nGreatestSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题32从1到n整数中1出现的次数">面试题32：从1到n整数中1出现的次数</h2><h3 id="题目">题目</h3><blockquote><p>输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。例如输入12，从1到12这些整数中包含1的数字有1，10，11和12，1一共出现了5次。</p></blockquote><h3 id="解析">解析</h3><p>不考虑时间复杂度，最简单的方法就是逐个数字判断，每次判断完各位是否1之后把数字除以10，当数字变为0时结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法一====================</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        number += NumberOf1(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n) <span class="comment">// 当n不为0时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">10</span> == <span class="number">1</span>)</span><br><span class="line">            number ++;</span><br><span class="line"></span><br><span class="line">        n = n / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里介绍一种考虑数字规律的O(log n)方法，也即复杂度视输入数字n的位数（等于log10(n)+1下取整）而定。</p><p>将求从1到n这n个整数的十进制表示中1出现的次数这个任务分为三个子任务来完成：</p><ol><li>统计 n去掉最高位+1 ~ n 这段范围内最高位出现的1</li><li>统计 n去掉最高位+1 ~ n 这段范围内除最高位之外出现的1</li><li>统计 1 ~ n去掉最高位 这段范围内出现的1</li></ol><p>那么具体来说怎么完成呢？</p><p>首先，对于 n去掉最高位+1 ~ n 这段范围内最高位出现的1，有两种情况：</p><ol><li>最高位大于1，此时所有最高位为1的情况都包含了，最高位为1的次数等于 <code>10^(位数-1)</code><ul><li>比如22，十位为1的10~19全部都被包含了，十位为1的次数是 <code>10^(2-1)=10（次）</code></li></ul></li><li>最高位等于1，此时最高位为1的次数等于 <code>n去掉最高位+1</code><ul><li>比如12，去掉十位是2，十位为1的次数是 <code>2+1=3（次）</code></li></ul></li></ol><p>然后，对于 n去掉最高位+1 ~ n 这段范围内除最高位之外出现的1，我们使用公式 <code>最高位*（位数-1）*10^(位数-2)</code> 次方。</p><p>首先，假设最高位数字为k，则 n去掉最高位+1 ~ n 这段范围可以被等分为k份。例如n=3721，则k=3，此时 722~3721 可以等分为3份，也即 722~1721，1722~2721 以及 2722~3721。又因为对于这3段范围来说，除最高位外出现1的次数都是相同的（最高位已经在第一个子任务中算好了，这里不用管），所以我们只需要算出其中一段就可以了，这是公式第一项的意义。</p><p>然后，假设n是一个d位数，则在去掉最高位后剩下的就是d-1位数字，我们在d-1位数字中选择一位固定为1，有d-1种选择，这是公式第二项的意义。</p><p>最后，在固定了其中一位数字为1之后，剩余的d-2位数字按照排列组合，每位数字都可以选择0~9中的一个，所以一共有 <code>10^(d-2)</code> 中组合，这是公式第三项的意义。</p><p>看到这里可能还有小小的迷糊，按照上面排列组合的方法计算，那么3111这个数在子任务2中不就被计算了3次吗？事实上，这并没有错，因为题目求得是1出现的次数，而不是出现1的数字有多少个？所以，除最高位外3111出现了3个1，在子任务2中计数为3是正确的。</p><p>最后的最后，我们还要求子任务3，统计 1 ~ n去掉最高位 这段范围内出现的1，这个使用递归求解就可以了，也即把n去掉最高位作为下一次递归传入的n。注意设置好终止条件，最好到达个位数时就停止了。若个位为0，则返回0；若各位大于0，则返回1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法二====================</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* strN)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PowerBase10</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> strN[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(strN, <span class="string">"%d"</span>, n); <span class="comment">//int转字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NumberOf1(strN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* strN)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!strN || *strN &lt; <span class="string">'0'</span> || *strN &gt; <span class="string">'9'</span> || *strN == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> first = *strN - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> length = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(<span class="built_in">strlen</span>(strN));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">1</span> &amp;&amp; first == <span class="number">0</span>) <span class="comment">// 个位为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">1</span> &amp;&amp; first &gt; <span class="number">0</span>) <span class="comment">// 个位为1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设strN是"21345"</span></span><br><span class="line">    <span class="comment">// numFirstDigit是数字10000-19999的第一个位中1的数目</span></span><br><span class="line">    <span class="keyword">int</span> numFirstDigit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(first &gt; <span class="number">1</span>)</span><br><span class="line">        numFirstDigit = PowerBase10(length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(first == <span class="number">1</span>)</span><br><span class="line">        numFirstDigit = atoi(strN + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// numOtherDigits是01346-21345除了第一位之外的数位中1的数目</span></span><br><span class="line">    <span class="keyword">int</span> numOtherDigits = first * (length - <span class="number">1</span>) * PowerBase10(length - <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// numRecursive是1-1345中1的数目</span></span><br><span class="line">    <span class="keyword">int</span> numRecursive = NumberOf1(strN + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numFirstDigit + numOtherDigits + numRecursive;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PowerBase10</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        result *= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题33把数组排成最小的数">面试题33：把数组排成最小的数</h2><h3 id="题目">题目</h3><blockquote><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接处的所有数字中最小的一个。例如输入数组 <code>{3,32,321}</code>，则打印出这3个数字能排成的最小数字321323.</p></blockquote><h3 id="解析">解析</h3><p>这题如果我们采用全排列的方式，n个数字就有n!个排列，时间复杂度相当大。</p><p>那么这条题目实际我们做什么呢？其实是希望我们<strong>实现一个比较函数</strong>。</p><p>在这里我们并不是简单地比较两个数字的大小，而是要比较它们拼接的时候谁排在前面能产生更小的数。要实现这样的功能，我们可以先将两个数字转换为字符串，然后使用strcat来进行拼接，使用strcmp来进行比较。</p><p>实现了比较函数之后，我们可以使用qsort快速排序在O(n logn)的时间内完成排序，此时按顺序输出数组的数字得到的就是最小的数。</p><p>在这里简单再减少以下几个函数：</p><ol><li><code>sprintf(a, &quot;%d&quot;, b)</code> 将int<em>类型的b转换为char</em>类型的a，也即整数数组转字符串；</li><li><code>strcpy(a,b)</code> 将b复制到a；</li><li><code>strcat(a,b)</code> 将b拼接到a后面；</li><li><code>strcmp(a,b)</code> 对a和b两个字符串从左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇’\0’为止。若a&gt;b则返回正数，a&lt;b则返回负数，相同则返回0。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int型整数用十进制表示最多只有10位</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_MaxNumberLength = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* g_StrCombine1 = <span class="keyword">new</span> <span class="keyword">char</span>[g_MaxNumberLength * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span>* g_StrCombine2 = <span class="keyword">new</span> <span class="keyword">char</span>[g_MaxNumberLength * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>** strNumbers = (<span class="keyword">char</span>**)(<span class="keyword">new</span> <span class="keyword">int</span>[length]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        strNumbers[i] = <span class="keyword">new</span> <span class="keyword">char</span>[g_MaxNumberLength + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(strNumbers[i], <span class="string">"%d"</span>, numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qsort(strNumbers, length, <span class="keyword">sizeof</span>(<span class="keyword">char</span>*), compare);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, strNumbers[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">        <span class="keyword">delete</span>[] strNumbers[i];</span><br><span class="line">    <span class="keyword">delete</span>[] strNumbers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果[strNumber1][strNumber2] &gt; [strNumber2][strNumber1], 返回值大于0</span></span><br><span class="line"><span class="comment">// 如果[strNumber1][strNumber2] = [strNumber2][strNumber1], 返回值等于0</span></span><br><span class="line"><span class="comment">// 如果[strNumber1][strNumber2] &lt; [strNumber2][strNumber1], 返回值小于0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* strNumber1, <span class="keyword">const</span> <span class="keyword">void</span>* strNumber2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// [strNumber1][strNumber2]</span></span><br><span class="line">    <span class="built_in">strcpy</span>(g_StrCombine1, *(<span class="keyword">const</span> <span class="keyword">char</span>**)strNumber1);</span><br><span class="line">    <span class="built_in">strcat</span>(g_StrCombine1, *(<span class="keyword">const</span> <span class="keyword">char</span>**)strNumber2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [strNumber2][strNumber1]</span></span><br><span class="line">    <span class="built_in">strcpy</span>(g_StrCombine2, *(<span class="keyword">const</span> <span class="keyword">char</span>**)strNumber2);</span><br><span class="line">    <span class="built_in">strcat</span>(g_StrCombine2, *(<span class="keyword">const</span> <span class="keyword">char</span>**)strNumber1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(g_StrCombine1, g_StrCombine2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题34丑数">面试题34：丑数</h2><h3 id="题目">题目</h3><blockquote><p>我们把只包含因子2、3和5的数称作丑数（Ugly Number）。求按小到大的顺序的第1500个丑数。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当做第一个丑数。</p></blockquote><h3 id="解析">解析</h3><p>最简单的解法，写一个函数用于判断是否丑数（需要求模和做除法），然后从1开始依次判断是否丑数，直到得到1500个丑数时停止。这种方法的时间开销很大，因为即使一个数不是丑数，我们仍然要对它进行判断，做求模和除法这些开销较大的操作。</p><p>在允许使用额外空间时，我们不妨<strong>用空间换时间</strong>。按照丑数的定义，<strong>丑数应该是另一个丑数乘以2、3或者5的结果（1除外）</strong>。所以我们可以创建一个数组，里面的数字是排好序的丑数，每个丑数都是前面的丑数乘以2、3或者5得到的。</p><p>现在关键在于<strong>怎么确保数组里的丑数是排好序的</strong>？</p><p>假设我们有一个排好序的丑数数组，最大的一个丑数为M，则我们在生成下一个丑数时，我们会把已有丑数都乘2，乘3和乘5，这会产生一些小于等于M的数字，但由于我们是按序生成的，所以我们并不care这些数字。要继续有序生成，我们需要找到第一个比M大的数字。对于乘2操作来说，把第一个比M大的数字的数字记为M2；对于乘3操作来说，把第一个比M大的数字的数字记为M3；对于乘5操作来说，把第一个比M大的数字的数字记为M5。那么数组的下一个丑数必然是M2，M3，M5这三个数中的最小者。</p><p>在实现的时候，我们可以用三个指针来分别记录M2/2，M3/3和M5/5的坐标，在下一次产生丑数时，我们就不需要再从1开始逐个数乘2，乘3和乘5了，因为下一个丑数必然是这三个指针以后的数乘2，乘3或乘5产生的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution2</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *pUglyNumbers = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">    pUglyNumbers[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nextUglyIndex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *pMultiply2 = pUglyNumbers;</span><br><span class="line">    <span class="keyword">int</span> *pMultiply3 = pUglyNumbers;</span><br><span class="line">    <span class="keyword">int</span> *pMultiply5 = pUglyNumbers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(nextUglyIndex &lt; index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min = Min(*pMultiply2 * <span class="number">2</span>, *pMultiply3 * <span class="number">3</span>, *pMultiply5 * <span class="number">5</span>);</span><br><span class="line">        pUglyNumbers[nextUglyIndex] = min;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(*pMultiply2 * <span class="number">2</span> &lt;= pUglyNumbers[nextUglyIndex])</span><br><span class="line">            ++pMultiply2;</span><br><span class="line">        <span class="keyword">while</span>(*pMultiply3 * <span class="number">3</span> &lt;= pUglyNumbers[nextUglyIndex])</span><br><span class="line">            ++pMultiply3;</span><br><span class="line">        <span class="keyword">while</span>(*pMultiply5 * <span class="number">5</span> &lt;= pUglyNumbers[nextUglyIndex])</span><br><span class="line">            ++pMultiply5;</span><br><span class="line"></span><br><span class="line">        ++nextUglyIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ugly = pUglyNumbers[nextUglyIndex - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] pUglyNumbers;</span><br><span class="line">    <span class="keyword">return</span> ugly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> number1, <span class="keyword">int</span> number2, <span class="keyword">int</span> number3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = (number1 &lt; number2) ? number1 : number2;</span><br><span class="line">    min = (min &lt; number3) ? min : number3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题35第一个只出现一次的字符">面试题35：第一个只出现一次的字符</h2><h3 id="题目">题目</h3><blockquote><p>在字符串中找出第一个只出现一次的字符。如输入 <code>&quot;abaccdeff&quot;</code>，则输出 <code>'b'</code>。</p></blockquote><h3 id="解析">解析</h3><p>对于统计次数的题目，我们很容易想到使用哈希表来实现。c++的标准模版库中并没有哈希表的实现，当我们可以利用一个int型数组来实现，因为char类型中每个字符是8bits的，也即有256种可能，我们可以用一个长度为256的数组来模拟。</p><p>有了哈希表，我们只需要扫描2次字符串就可以实现题目要求了，也即时间复杂度为O(n)。具体来说，第一次扫描，我们统计每个字符的次数；第二次扫描则搜索哈希表中的次数，第一次出现次数为1时就代表找到了。</p><p>特别注意一下，哈希表要进行初始化，另外，如果没有只出现1次的字符，要明确该返回什么。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="keyword">char</span>* pString)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pString == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> tableSize = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hashTable[tableSize];</span><br><span class="line">    <span class="comment">// 初始化哈希表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i&lt;tableSize; ++ i)</span><br><span class="line">        hashTable[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次扫描字符串</span></span><br><span class="line">    <span class="comment">// 统计各字符的出现数目</span></span><br><span class="line">    <span class="keyword">char</span>* pHashKey = pString;</span><br><span class="line">    <span class="keyword">while</span>(*(pHashKey) != <span class="string">'\0'</span>)</span><br><span class="line">        hashTable[*(pHashKey++)] ++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二次扫描字符串</span></span><br><span class="line">    <span class="comment">// 依次把字符作为key检索哈希表</span></span><br><span class="line">    pHashKey = pString;</span><br><span class="line">    <span class="keyword">while</span>(*pHashKey != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hashTable[*pHashKey] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> *pHashKey;</span><br><span class="line"></span><br><span class="line">        pHashKey++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题36数组中的逆序对">面试题36：数组中的逆序对</h2><h3 id="题目">题目</h3><blockquote><p>在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p></blockquote><h3 id="解析">解析</h3><p>最简单的解法是逐个扫描数组的数字，对每个数字都检查其后的所有数字来统计逆序对，复杂度是O(n^2)。</p><p>但是，这种解法显然太过耗费时间。有没有更快的方法呢？有的，采用<strong>归并排序</strong>的思想，我们可以借助一个和原数组等长的辅助数组来实现O(n logn)时间复杂度的解法。</p><p>具体来说，过程如下：</p><ol><li><p>把原数组对半分为两个子数组，对子数组继续对半分，直到子数组只包含单个数字，然后开始对相邻的子数组进行合并。</p></li><li><p>在合并时，我们从两个子数组的最后一位开始往前扫描（两个子数组都是递增数组），每次选择较大的一位放入辅助数组（从辅助数组的最后开始赋值，保证生成的也是递增数组）。</p><ul><li>如果靠前的子数组数字较大，那就代表这合并后它会和靠后子数组剩余的数字（都比它小）构成逆序对，此时总逆序对数目应加上靠后子数组剩余数字的数目。</li><li>如果靠后的子数组数字较大，就代表不构成逆序对，直接合并到辅助数组就可以了。</li></ul></li><li><p>如此经过多轮的分拆和合并，最后就能得到一个递增排序的辅助数组，同时统计好了逆序对的数目。</p></li></ol><p>再举个简单例子来捋顺思路吧，假设我们要统计数组 <code>7,5,6,4</code> 的逆序对数目，步骤如下：</p><ol><li>对半分数组 <code>7,5,6,4</code>，得到子数组 <code>7,5</code> 和 <code>6,4</code>；</li><li>对半分数组 <code>7,5</code>，得到子数组 <code>7</code> 和 <code>5</code>；</li><li>合并子数组 <code>7</code> 和 <code>5</code>，7比5大，逆序对加一，7放入辅助数组，子数组1空了，把子数组2的数字也放入辅助数组，得到辅助数组 <code>5,7</code>；</li><li>对半分数组 <code>6,4</code>，得到子数组 <code>6</code> 和 <code>4</code>；</li><li>合并子数组 <code>6</code> 和 <code>4</code>，6比4大，逆序对加一，6放入辅助数组，子数组1空了，把子数组2的数字也放入辅助数组，得到辅助数组 <code>4,6</code>；</li><li>子数组 <code>5,7</code> 和 <code>4,6</code>，7比6大，<strong>逆序对加二</strong>，7放入辅助数组。5比6小，6放入辅助数组。5比4大，逆序对加一，5放入辅助 数组，子数组1空了，把子数组2的数字也放入辅助数组，得到辅助数组 <code>4,5,6,7</code>；</li><li>合并完成，得到递增数组 <code>4,5,6,7</code>，逆序对数目为 <code>1+1+2+1=5（个）</code>。</li></ol><p>当然最好还是自己拿着纸举例分析来体验一下。假设我们把每一次归并中，用于合并的两个子数组称为数据数组，合并好的数组称为辅助数组。那么在转化为代码的过程中，<strong>合并出这一轮辅助数组用的是在获取这一轮两个数据数组时用的辅助数组</strong>。比方说上面例子中，步骤6用的两个数据数组其实就是步骤3和步骤5中得到的辅助数组 <code>5,7</code> 和辅助数组 <code>4,6</code>。</p><p><strong>那我们是否需要使用多个长度不一的辅助数组呢</strong>？不是的，我们用一个和输入数组等长的辅助数组就够了，只是用的方式有一点巧妙。在传递参数时，把子数组在原数组中start和end的索引也作为参数传递就可以了，这样相当于截取了原数组的一段。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">NULL</span> || length &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* copy = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++ i)</span><br><span class="line">        copy[i] = data[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = InversePairsCore(data, copy, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">delete</span>[] copy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InversePairsCore</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span>* copy, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 当分割到子数组只剩1个数字时，直接合并入辅助数组，逆序对数目为0</span></span><br><span class="line">    <span class="keyword">if</span>(start == end)</span><br><span class="line">    &#123;</span><br><span class="line">        copy[start] = data[start];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把当前数组分割成两部分</span></span><br><span class="line">    <span class="comment">// 注意data和copy作为参数的位置是换过来的</span></span><br><span class="line">    <span class="comment">// 因为这一轮用于归并的数据数组是两个子数组归并好的的结果（它们那一轮的辅助数组）</span></span><br><span class="line">    <span class="keyword">int</span> length = (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> left = InversePairsCore(copy, data, start, start + length);</span><br><span class="line">    <span class="keyword">int</span> right = InversePairsCore(copy, data, start + length + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i初始化为前半段最后一个数字的下标</span></span><br><span class="line">    <span class="keyword">int</span> i = start + length;</span><br><span class="line">    <span class="comment">// j初始化为后半段最后一个数字的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助数组的指针初始化在最后</span></span><br><span class="line">    <span class="keyword">int</span> indexCopy = end;</span><br><span class="line">    <span class="comment">// 逆序对数目初始化为0</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 合并两个子数组到辅助数组，从末尾开始比较，到达其中一方的头部时停止</span></span><br><span class="line">    <span class="keyword">while</span>(i &gt;= start &amp;&amp; j &gt;= start + length + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[i] &gt; data[j])</span><br><span class="line">        &#123;</span><br><span class="line">            copy[indexCopy--] = data[i--];</span><br><span class="line">            count += j - start - length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            copy[indexCopy--] = data[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把另一方余下的数字也合并到辅助数组中</span></span><br><span class="line">    <span class="keyword">for</span>(; i &gt;= start; --i)</span><br><span class="line">        copy[indexCopy--] = data[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(; j &gt;= start + length + <span class="number">1</span>; --j)</span><br><span class="line">        copy[indexCopy--] = data[j];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逆序对总数由三部分组成，两个子数组各自的逆序对数目加上合并它们产生的逆序对数目</span></span><br><span class="line">    <span class="keyword">return</span> left + right + count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题37两个链表的第一个公共结点">面试题37：两个链表的第一个公共结点</h2><h3 id="题目">题目</h3><blockquote><p>输入两个链表，找出它们的第一个公共结点。链表结点定义如下：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>       m_nValue;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析">解析</h3><p>最呆萌的做法就是依次遍历其中一个链表的结点，每访问一个结点就遍历一次另一个链表，知道找到两个链表的公共结点。如果两个链表长度分别为m和n，这种方法的时间复杂度就是O(mn)。</p><p>当然不用这么笨的方法… 我们先观察一下两个有公共结点的链表有什么特点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span></span><br><span class="line">           \</span><br><span class="line">            <span class="number">6</span> -&gt; <span class="number">7</span></span><br><span class="line">           /</span><br><span class="line">     <span class="number">4</span> -&gt; <span class="number">5</span></span><br></pre></td></tr></table></figure><p>不难发现，<strong>两个有公共结点的链表从第一个公共结点到链表尾都是一样的</strong>。而且，如果两个链表相差k步，我们在长链表上先走k步，然后再同时遍历两个链表，就能很容易地找到第一个公共结点（如果没有则会一起走到链表尾的NULL）。</p><p>基于这个思路，实现代码并不难：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode *pHead1, ListNode *pHead2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 得到两个链表的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nLength1 = GetListLength(pHead1);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nLength2 = GetListLength(pHead2);</span><br><span class="line">    <span class="keyword">int</span> nLengthDif = nLength1 - nLength2;</span><br><span class="line"></span><br><span class="line">    ListNode* pListHeadLong = pHead1;</span><br><span class="line">    ListNode* pListHeadShort = pHead2;</span><br><span class="line">    <span class="keyword">if</span>(nLength2 &gt; nLength1)</span><br><span class="line">    &#123;</span><br><span class="line">        pListHeadLong = pHead2;</span><br><span class="line">        pListHeadShort = pHead1;</span><br><span class="line">        nLengthDif = nLength2 - nLength1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先在长链表上走几步，再同时在两个链表上遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLengthDif; ++ i)</span><br><span class="line">        pListHeadLong = pListHeadLong-&gt;m_pNext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((pListHeadLong != <span class="literal">NULL</span>) &amp;&amp;</span><br><span class="line">        (pListHeadShort != <span class="literal">NULL</span>) &amp;&amp;</span><br><span class="line">        (pListHeadLong != pListHeadShort))</span><br><span class="line">    &#123;</span><br><span class="line">        pListHeadLong = pListHeadLong-&gt;m_pNext;</span><br><span class="line">        pListHeadShort = pListHeadShort-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到第一个公共结点</span></span><br><span class="line">    ListNode* pFisrtCommonNode = pListHeadLong;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pFisrtCommonNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">GetListLength</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nLength = <span class="number">0</span>;</span><br><span class="line">    ListNode* pNode = pHead;</span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ++ nLength;</span><br><span class="line">        pNode = pNode-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer</title>
      <link href="/2020/07/06/%E5%89%91%E6%8C%87offer/4_%E8%A7%A3%E5%86%B3%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF/"/>
      <url>/2020/07/06/%E5%89%91%E6%8C%87offer/4_%E8%A7%A3%E5%86%B3%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="解决面试题的思路">解决面试题的思路</h1><h2 id="面试题19二叉树的镜像">面试题19：二叉树的镜像</h2><h3 id="题目">题目</h3><blockquote><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。二叉树结点的定义如下：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                    m_nValue;</span><br><span class="line">    BinaryTreeNode*        m_pLeft;</span><br><span class="line">    BinaryTreeNode*        m_pRight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析">解析</h3><p>如果画图分析过，很容易就会发现，其实要得到一棵二叉树的镜像，只需要把每个结点的左右子结点都进行交换就可以了。</p><p>在每一轮交换中，我们先记住原来的左子结点，然后把当前结点的左子结点指针改为指向右子结点，最后把当前结点的右子结点指针改为指向原来的左子结点就可以了。</p><p>使用递归的话，注意结束条件是到达叶结点。特别地，要记得处理输入为空指针的状况。处理完当前结点后，若左子结点不为NULL，就继续处理左子结点，右子结点同理；</p><p>使用迭代的话，其实也很类似，可以用栈来模拟，递归本身就是一种栈结构。</p><p>递归解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MirrorRecursively</span><span class="params">(BinaryTreeNode *pNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((pNode == <span class="literal">NULL</span>) || (pNode-&gt;m_pLeft == <span class="literal">NULL</span> &amp;&amp; pNode-&gt;m_pRight))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    BinaryTreeNode *pTemp = pNode-&gt;m_pLeft;</span><br><span class="line">    pNode-&gt;m_pLeft = pNode-&gt;m_pRight;</span><br><span class="line">    pNode-&gt;m_pRight = pTemp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pNode-&gt;m_pLeft)</span><br><span class="line">        MirrorRecursively(pNode-&gt;m_pLeft);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pNode-&gt;m_pRight)</span><br><span class="line">        MirrorRecursively(pNode-&gt;m_pRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MirrorIteratively</span><span class="params">(BinaryTreeNode* pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;BinaryTreeNode*&gt; stackTreeNode;</span><br><span class="line">    stackTreeNode.push(pRoot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(stackTreeNode.size() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode *pNode = stackTreeNode.top();</span><br><span class="line">        stackTreeNode.pop();</span><br><span class="line"></span><br><span class="line">        BinaryTreeNode *pTemp = pNode-&gt;m_pLeft;</span><br><span class="line">        pNode-&gt;m_pLeft = pNode-&gt;m_pRight;</span><br><span class="line">        pNode-&gt;m_pRight = pTemp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;m_pLeft)</span><br><span class="line">            stackTreeNode.push(pNode-&gt;m_pLeft);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;m_pRight)</span><br><span class="line">            stackTreeNode.push(pNode-&gt;m_pRight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题20顺时针打印矩阵">面试题20：顺时针打印矩阵</h2><h3 id="题目">题目</h3><blockquote><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。例如：如果输入如下矩阵</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1   2   3   4</span><br><span class="line">5   6   7   8</span><br><span class="line">9   10  11  12</span><br><span class="line">13  14  15  16</span><br></pre></td></tr></table></figure><blockquote><p>则依次打印出数字 <code>1、2、3、4、8、12、16、15、14、13、9、5、6、7、11、10</code>。</p></blockquote><h3 id="解析">解析</h3><p>题目要求从外向里顺时针打印一个矩阵，其实可以把这个矩阵从外向里分为若干层，每一层从左上角开始（比如上面例子中的1和6）。这样题目的要求就变为依次顺时针打印每一层的数字。我们会发现，<strong>每一层左上角的行坐标和列坐标都是相等的</strong>。</p><p>那么我们可以用一个循环来打印出所有的层，但是到底有多少层呢？或者会说，每一层左上角的坐标 <code>(start, start)</code> 最大可以是多少呢？通过举例分析，我们会发现，<strong>给定任意一个矩阵，层数是行数的一半和列数的一半这两者中的较小者</strong>。具体来说，写为代码就是 <code>columns &gt; start * 2 &amp;&amp; rows &gt; start * 2</code>（注意坐标从0开始），不满足这个条件时退出循环即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMatrixClockwisely</span><span class="params">(<span class="keyword">int</span>** numbers, <span class="keyword">int</span> columns, <span class="keyword">int</span> rows)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">NULL</span> || columns &lt;= <span class="number">0</span> || rows &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(columns &gt; start * <span class="number">2</span> &amp;&amp; rows &gt; start * <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PrintMatrixInCircle(numbers, columns, rows, start);</span><br><span class="line"></span><br><span class="line">        ++start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了某一层左上角的坐标之后，怎么顺时针打印这一层的数字呢？可以分为四个操作。</p><ol><li>从左到右打印一行</li><li>从上到下打印一列</li><li>从右到左打印一行</li><li>从下到上打印一列</li></ol><p>但是，必须注意到，<strong>不是所有情况下都能完整地进行这四个操作的</strong>。当行列数不同时，<strong>最内层的矩阵有可能退化为只有一行/一列甚至只有一个数字</strong>。那么进行每个操作的前提条件是什么呢？</p><p>操作1是必然会进行的，如果只有一行或一个数字，那么操作1结束后其他操作就不需要了；</p><p>进行操作2的前提是终止行号大于起始行号，即至少要有两行；</p><p>进行操作3的前提是至少有两行两列。只有1列的话，完成操作1和2就打印完了；</p><p>进行操作4的前提是至少有三行两列；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMatrixInCircle</span><span class="params">(<span class="keyword">int</span>** numbers, <span class="keyword">int</span> columns, <span class="keyword">int</span> rows, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> endX = columns - <span class="number">1</span> - start; <span class="comment">// 所在层的最大横坐标</span></span><br><span class="line">    <span class="keyword">int</span> endY = rows - <span class="number">1</span> - start;    <span class="comment">// 所在列的最大纵坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从左到右打印一行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= endX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> number = numbers[start][i];</span><br><span class="line">        printNumber(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从上到下打印一列</span></span><br><span class="line">    <span class="keyword">if</span>(start &lt; endY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= endY; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> number = numbers[i][endX];</span><br><span class="line">            printNumber(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从右到左打印一行</span></span><br><span class="line">    <span class="keyword">if</span>(start &lt; endX &amp;&amp; start &lt; endY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = endX - <span class="number">1</span>; i &gt;= start; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> number = numbers[endY][i];</span><br><span class="line">            printNumber(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从下到上打印一列</span></span><br><span class="line">    <span class="keyword">if</span>(start &lt; endX &amp;&amp; start &lt; endY - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = endY - <span class="number">1</span>; i &gt;= start + <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> number = numbers[i][start];</span><br><span class="line">            printNumber(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNumber</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题21包含min函数的栈">面试题21：包含min函数的栈</h2><h3 id="题目">题目</h3><blockquote><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min、push及pop的时间复杂度都是O(1)。</p></blockquote><h3 id="解析">解析</h3><p>要实现带min函数的栈，难度不仅在于每次入栈，最小元素都会变动；还在于每次出栈一个元素，最小元素也会变动。如果我们只用一个int类型来记录最小元素，那么出栈时我们就不得不把所有剩余元素都检查一遍才能更新最小元素。</p><p>更好的方法是在数据栈之外再维护一个辅助栈。每次把新元素压入数据栈，如果新元素比辅助栈的栈顶（当前最小元素）小，就把新元素也压入辅助栈；如果新元素较大，就把辅助栈栈顶元素再一次压入辅助栈。</p><p>出栈时，同时把数据栈和辅助栈的栈顶出栈即可。按照前面入栈的操作，此时辅助栈栈顶的元素必然也是数据栈中最小的元素。</p><p>要获取最小元素的值只需要访问辅助栈的栈顶就可以了。</p><p>以上三个操作的时间复杂度都是O(1)，符合题目要求。还有一个小细节需要注意一下，就是在调用pop和min时应检查一下栈是否非空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">StackWithMin</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StackWithMin(<span class="keyword">void</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~StackWithMin(<span class="keyword">void</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T&amp; <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T&amp; <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">size_t</span> size() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;T&gt;   m_data;     <span class="comment">// 数据栈，存放栈的所有元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;T&gt;   m_min;      <span class="comment">// 辅助栈，存放栈的最小元素</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> StackWithMin&lt;T&gt;::push(<span class="keyword">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 把新元素添加到辅助栈</span></span><br><span class="line">    m_data.push(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当辅助栈为空或者新元素比之前的最小元素小时，把新元素插入辅助栈里；</span></span><br><span class="line">    <span class="comment">// 否则把之前的最小元素重复插入辅助栈里</span></span><br><span class="line">    <span class="keyword">if</span>(m_min.size() == <span class="number">0</span> || value &lt; m_min.top())</span><br><span class="line">        m_min.push(value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        m_min.push(m_min.top());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> StackWithMin&lt;T&gt;::pop()</span><br><span class="line">&#123;</span><br><span class="line">    assert(m_data.size() &gt; <span class="number">0</span> &amp;&amp; m_min.size() &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    m_data.pop();</span><br><span class="line">    m_min.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">const</span> T&amp; StackWithMin&lt;T&gt;::min() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(m_data.size() &gt; <span class="number">0</span> &amp;&amp; m_min.size() &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m_min.top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T&amp; StackWithMin&lt;T&gt;::top()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_data.top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">const</span> T&amp; StackWithMin&lt;T&gt;::top() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_data.top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> StackWithMin&lt;T&gt;::empty() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_data.empty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">size_t</span> StackWithMin&lt;T&gt;::size() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_data.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题22栈的压入-弹出序列">面试题22：栈的压入、弹出序列</h2><h3 id="题目">题目</h3><blockquote><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的数字均不想等。例如序列 <code>1、2、3、4、5</code> 是某栈的压栈序列，序列 <code>4、5、3、2、1</code> 是该压栈序列对应的一个弹出序列，但 <code>4、3、5、1、2</code> 就不可能是该压栈序列的弹出序列。</p></blockquote><h3 id="解析">解析</h3><p>要实现题目要求，其实思路还是蛮清晰的。我们每次检查弹出序列的头部元素，如果此时栈内没有该元素，就按照压栈序列的顺序将数字压入辅助栈，直到辅助栈的栈顶和弹出序列的头部元素相同。这时可以从辅助栈弹出一个元素，而弹出序列的头部也往后移动一位，继续下一次检查。</p><p>要注意循环的终止条件和匹配成功的条件。当匹配完弹出序列最后一位时顺利退出，但此时还应检查压栈序列的数是否已全部用完，否则仍然不算成功匹配；另外，在压栈的过程中，有可能压入了所有数字后仍然无法匹配到弹出序列，此时也应退出循环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* pPush, <span class="keyword">const</span> <span class="keyword">int</span>* pPop, <span class="keyword">int</span> nLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> bPossible = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pPush != <span class="literal">NULL</span> &amp;&amp; pPop != <span class="literal">NULL</span> &amp;&amp; nLength &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>* pNextPush = pPush;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>* pNextPop = pPop;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stackData;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 全部pop完就停止</span></span><br><span class="line">        <span class="keyword">while</span>(pNextPop - pPop &lt; nLength)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当辅助栈的栈顶元素不是要弹出的元素</span></span><br><span class="line">            <span class="comment">// 先压入一些数字入栈</span></span><br><span class="line">            <span class="keyword">while</span>(stackData.empty() || stackData.top() != *pNextPop)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果所有数字都压入辅助栈了，退出循环</span></span><br><span class="line">                <span class="keyword">if</span>(pNextPush - pPush == nLength)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                stackData.push(*pNextPush);</span><br><span class="line"></span><br><span class="line">                pNextPush ++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 所有数字都已压入辅助栈却无法与弹出序列匹配就直接退出</span></span><br><span class="line">            <span class="keyword">if</span>(stackData.top() != *pNextPop)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            stackData.pop();</span><br><span class="line">            pNextPop ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 辅助栈空了，并且弹出序列也匹配到了最后，就说明匹配成功</span></span><br><span class="line">        <span class="keyword">if</span>(stackData.empty() &amp;&amp; pNextPop - pPop == nLength)</span><br><span class="line">            bPossible = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bPossible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题23从上往下打印二叉树">面试题23：从上往下打印二叉树</h2><h3 id="题目">题目</h3><blockquote><p>从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。例如输入下面的二叉树，则依次打印出 <code>8、6、10、5、7、9、11</code>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     8</span><br><span class="line">   /   \</span><br><span class="line">  6     10</span><br><span class="line"> / \    / \</span><br><span class="line">5   7  9  11</span><br></pre></td></tr></table></figure><blockquote><p>二叉树结点的定义如下：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                    m_nValue;</span><br><span class="line">    BinaryTreeNode*        m_pLeft;</span><br><span class="line">    BinaryTreeNode*        m_pRight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析">解析</h3><p>这题比较简单，其实就是BFS遍历二叉树，我们可以用队列进行模拟。每次出队队首元素，打印该元素，如果它有子结点，就把子结点放到队列尾部。然后继续下一次出队即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintFromTopToBottom</span><span class="params">(BinaryTreeNode* pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;BinaryTreeNode *&gt; dequeTreeNode;</span><br><span class="line"></span><br><span class="line">    dequeTreeNode.push_back(pRoot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(dequeTreeNode.size())</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode *pNode = dequeTreeNode.front();</span><br><span class="line">        dequeTreeNode.pop_front();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, pNode-&gt;m_nValue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;m_pLeft)</span><br><span class="line">            dequeTreeNode.push_back(pNode-&gt;m_pLeft);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;m_pRight)</span><br><span class="line">            dequeTreeNode.push_back(pNode-&gt;m_pRight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题24二叉搜索树的后序遍历序列">面试题24：二叉搜索树的后序遍历序列</h2><h3 id="题目">题目</h3><blockquote><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true，否则返回false。假设输入的数组的任意两个数字都互不相同。</p></blockquote><h3 id="解析">解析</h3><p>先举个例子吧，给定一棵BST：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     8</span><br><span class="line">   /   \</span><br><span class="line">  6     10</span><br><span class="line"> / \    / \</span><br><span class="line">5   7  9  11</span><br></pre></td></tr></table></figure><p>可以看到，它的特点就是：<strong>对于任意一个有子结点的结点来说，左子树上的元素都比它小，右子树上的元素都比它大</strong>。</p><p>它的后序遍历序列是 <code>5,7,6,9,11,10,8</code>，我们发现最后一个点对应着BST的根结点，而前面的序列可以分为两部分，<strong>由第一个大于根结点的数开始是右子树，前面的部分是左子树</strong>。</p><p>题目要求的是判断一个序列是否BST的后序遍历序列，我们可以基于上面说到的规律利用递归的方式来实现：</p><ol><li>每次接收到一个序列，首先取出根结点（序列的最后一个元素）；</li><li>然后在除根结点外的序列中找出第一个比根结点大的元素（有可能没有，也即右子树为空），把序列分割为左子树部分和右子树部分；</li><li>然后检查右子树部分是否所有元素都比根结点大（左子树在步骤2已经完成检验了）；</li><li>通过步骤3，则递归判断左右子树两个序列是否BST，注意检查是否有左右子树；</li><li>未通过步骤3，则返回错误。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BST：Binary Search Tree，二叉搜索树</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> sequence[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sequence == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> root = sequence[length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在二叉搜索树中左子树的结点小于根结点</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; length - <span class="number">1</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence[i] &gt; root)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在二叉搜索树中右子树的结点大于根结点</span></span><br><span class="line">    <span class="keyword">int</span> j = i;</span><br><span class="line">    <span class="keyword">for</span>(; j &lt; length - <span class="number">1</span>; ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence[j] &lt; root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断左子树是不是二叉搜索树</span></span><br><span class="line">    <span class="keyword">bool</span> left = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">        left = VerifySquenceOfBST(sequence, i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断右子树是不是二叉搜索树</span></span><br><span class="line">    <span class="keyword">bool</span> right = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; length - <span class="number">1</span>)</span><br><span class="line">        right = VerifySquenceOfBST(sequence + i, length - i - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (left &amp;&amp; right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题25二叉树中和为某一值的路径">面试题25：二叉树中和为某一值的路径</h2><h3 id="题目">题目</h3><blockquote><p>输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。二叉树结点的定义如下：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                    m_nValue;</span><br><span class="line">    BinaryTreeNode*        m_pLeft;</span><br><span class="line">    BinaryTreeNode*        m_pRight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析">解析</h3><p>由于题目要求打印出所有符合要求的路径，所以我们需要遍历整棵树。而且我们需要对每条路径上的点进行求和。有没有办法可以同时实现这两点呢？</p><p>我们可以使用DFS进行前序遍历，这样就能对单条路径上的点进行求和了，当需要计算另外一条路径时，我们只需要把不属于另一路径的点丢掉就可以了。</p><p>具体来说：我们用前序遍历访问到某一结点时，把该结点添加到路径上，并累加它的值。</p><ul><li>如果当前结点是叶结点，并且路径中结点值的和为输入的整数，则将路径打印出来；</li><li>如果当前结点不是叶结点，则继续访问它的左右子结点。</li></ul><p>在访问完当前结点后，递归函数会自动返回到它的父结点处，我们需要做的就是在返回之前把它从路径中拿走，并且从结点和中减去该结点的值。</p><p>我们可以使用vector来存储路径，迭代器允许我们输出vector的每一个点。此外，一定要特别注意哪些参数需使用引用传递，哪些采用值传递。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindPath</span><span class="params">(BinaryTreeNode* pRoot, <span class="keyword">int</span> expectedSum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">int</span> currentSum = <span class="number">0</span>;</span><br><span class="line">    FindPath(pRoot, expectedSum, path, currentSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindPath</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BinaryTreeNode*   pRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>               expectedSum,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>&amp;              currentSum</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    currentSum += pRoot-&gt;m_nValue;</span><br><span class="line">    path.push_back(pRoot-&gt;m_nValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是叶结点，并且路径上结点的和等于输入的值</span></span><br><span class="line">    <span class="comment">// 打印出这条路径</span></span><br><span class="line">    <span class="keyword">bool</span> isLeaf = pRoot-&gt;m_pLeft == <span class="literal">NULL</span> &amp;&amp; pRoot-&gt;m_pRight == <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(currentSum == expectedSum &amp;&amp; isLeaf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"A path is found: "</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = path.begin();</span><br><span class="line">        <span class="keyword">for</span>(; iter != path.end(); ++ iter)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, *iter);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是叶结点，则遍历它的子结点</span></span><br><span class="line">    <span class="keyword">if</span>(pRoot-&gt;m_pLeft != <span class="literal">NULL</span>)</span><br><span class="line">        FindPath(pRoot-&gt;m_pLeft, expectedSum, path, currentSum);</span><br><span class="line">    <span class="keyword">if</span>(pRoot-&gt;m_pRight != <span class="literal">NULL</span>)</span><br><span class="line">        FindPath(pRoot-&gt;m_pRight, expectedSum, path, currentSum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在返回到父结点之前，在路径上删除当前结点，</span></span><br><span class="line">    <span class="comment">// 并在currentSum中减去当前结点的值</span></span><br><span class="line">    currentSum -= pRoot-&gt;m_nValue;</span><br><span class="line">    path.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题26复杂链表的复制">面试题26：复杂链表的复制</h2><h3 id="题目">题目</h3><blockquote><p>请实现函数 <code>ComplexListNode* Clone(ComplexListNode* pHead)</code>，复制一个复杂链表。在复杂链表中，每个结点除了有一个 <code>m_pNext</code> 指针指向下一个结点外，还有一个 <code>m_pSibling</code> 指向链表中的任意结点或者NULL。结点的C++定义如下：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ComplexListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                 m_nValue;</span><br><span class="line">    ComplexListNode*    m_pNext;</span><br><span class="line">    ComplexListNode*    m_pSibling;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析">解析</h3><p>首先要清楚复制的意思，不是简单的声明一个头结点，然后赋值为给出链表的头结点就可以了。这样操作时依然会影响到原链表。要真的实现复制，就必须另外构造一个新的链表。</p><p>最简单的做法是分两个步骤，第一步先逐个构造新链表的结点，赋值为原链表中对应的值；第二步，根据原链表中每个结点的指向，对新链表各结点的sibling指针复制。第二步的时间复杂度是O(n^2)，因为每次找新链表中的sibling，都需要遍历一次新链表。</p><p>有没有O(n)的解法呢？有的。</p><p>这个方法具体来说分为三步，要充分理解整个流程最好是画图出来对照着看：</p><ol><li><p>在原链表上复制每个结点，把复制结点的next指针指向对应原结点的next结点，对应原结点的next指针指向复制结点。比如：<br><br>复制前：<code>1 -&gt; 2 -&gt; 3 -&gt; 4</code><br><br>复制后：<code>1 -&gt; 1 -&gt; 2 -&gt; 2 -&gt; 3 -&gt; 3 -&gt; 4 -&gt; 4</code></p></li><li><p>遍历一次复制后的链表，为每个复制结点设置sibling指针，因为复制的sibling结点就在原链表sibling结点的后面，所以可以在O(1)时间内找到。</p></li><li><p>把链表分割为原链表和复制链表，只需要遍历一遍链表，重新设置next指针即可。</p></li></ol><p>以上三个步骤都只需遍历一次链表，因此它的时间复杂度是O(n)的。一定要注意对空指针的处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ComplexListNode* <span class="title">Clone</span><span class="params">(ComplexListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CloneNodes(pHead);</span><br><span class="line">    ConnectSiblingNodes(pHead);</span><br><span class="line">    <span class="keyword">return</span> ReconnectNodes(pHead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CloneNodes</span><span class="params">(ComplexListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ComplexListNode* pNode = pHead;</span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ComplexListNode* pCloned = <span class="keyword">new</span> ComplexListNode();</span><br><span class="line">        pCloned-&gt;m_nValue = pNode-&gt;m_nValue;</span><br><span class="line">        pCloned-&gt;m_pNext = pNode-&gt;m_pNext;</span><br><span class="line">        pCloned-&gt;m_pSibling = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        pNode-&gt;m_pNext = pCloned;</span><br><span class="line"></span><br><span class="line">        pNode = pCloned-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConnectSiblingNodes</span><span class="params">(ComplexListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ComplexListNode* pNode = pHead;</span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ComplexListNode* pCloned = pNode-&gt;m_pNext;</span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;m_pSibling != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pCloned-&gt;m_pSibling = pNode-&gt;m_pSibling-&gt;m_pNext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pNode = pCloned-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ComplexListNode* <span class="title">ReconnectNodes</span><span class="params">(ComplexListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ComplexListNode* pNode = pHead;</span><br><span class="line">    ComplexListNode* pClonedHead = <span class="literal">NULL</span>;</span><br><span class="line">    ComplexListNode* pClonedNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先分割出复制链表的链表头</span></span><br><span class="line">    <span class="keyword">if</span>(pNode != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pClonedHead = pClonedNode = pNode-&gt;m_pNext;</span><br><span class="line">        pNode-&gt;m_pNext = pClonedNode-&gt;m_pNext;</span><br><span class="line">        pNode = pNode-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐步把复制链表和原链表分割开来</span></span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pClonedNode-&gt;m_pNext = pNode-&gt;m_pNext;</span><br><span class="line">        pClonedNode = pClonedNode-&gt;m_pNext;</span><br><span class="line"></span><br><span class="line">        pNode-&gt;m_pNext = pClonedNode-&gt;m_pNext;</span><br><span class="line">        pNode = pNode-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pClonedHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题27二叉搜索树与双向链表">面试题27：二叉搜索树与双向链表</h2><h3 id="题目">题目</h3><blockquote><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整书中结点指针的指向。比如二叉搜索树：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     10</span><br><span class="line">   /    \</span><br><span class="line">  6      14</span><br><span class="line"> / \    /  \</span><br><span class="line">4   8  12  16</span><br></pre></td></tr></table></figure><p>转换为双向链表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 ⇆ 6 ⇆ 8 ⇆ 10 ⇆ 12 ⇆ 14 ⇆ 16</span><br></pre></td></tr></table></figure><blockquote><p>二叉树结点的定义如下：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                    m_nValue;</span><br><span class="line">    BinaryTreeNode*        m_pLeft;</span><br><span class="line">    BinaryTreeNode*        m_pRight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析">解析</h3><p>我们可以首先观察一下BST和对应双向链表的关系，不难发现双向链表的顺序其实就是BST的中序遍历顺序。在转换的时候，我们按着中序遍历的顺序来走，把BST中每个结点的左子结点设置为遍历的上一个结点，右子结点设置为遍历的下一个结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">Convert</span><span class="params">(BinaryTreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinaryTreeNode *pLastNodeInList = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 注意这里是按引用传递指针，因为我们希望它在函数中</span></span><br><span class="line">    <span class="comment">// 的修改能够保留下来。</span></span><br><span class="line">    ConvertNode(pRootOfTree, &amp;pLastNodeInList);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pLastNodeInList指向双向链表的尾结点，</span></span><br><span class="line">    <span class="comment">// 我们需要返回头结点，一路往左即可</span></span><br><span class="line">    BinaryTreeNode *pHeadOfList = pLastNodeInList;</span><br><span class="line">    <span class="keyword">while</span>(pHeadOfList != <span class="literal">NULL</span> &amp;&amp; pHeadOfList-&gt;m_pLeft != <span class="literal">NULL</span>)</span><br><span class="line">        pHeadOfList = pHeadOfList-&gt;m_pLeft;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pHeadOfList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConvertNode</span><span class="params">(BinaryTreeNode* pNode, BinaryTreeNode** pLastNodeInList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pNode == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    BinaryTreeNode *pCurrent = pNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 中序遍历BST ***/</span></span><br><span class="line">    <span class="comment">// 先访问左子树，把左子树转换为有序链表</span></span><br><span class="line">    <span class="keyword">if</span> (pCurrent-&gt;m_pLeft != <span class="literal">NULL</span>)</span><br><span class="line">        ConvertNode(pCurrent-&gt;m_pLeft, pLastNodeInList);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把左子结点设置为中序遍历的上一个结点</span></span><br><span class="line">    <span class="comment">// 左子结点非空时，把左子结点的右子结点设置为当前结点</span></span><br><span class="line">    pCurrent-&gt;m_pLeft = *pLastNodeInList;</span><br><span class="line">    <span class="keyword">if</span>(*pLastNodeInList != <span class="literal">NULL</span>)</span><br><span class="line">        (*pLastNodeInList)-&gt;m_pRight = pCurrent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问当前结点，链表尾变为当前结点</span></span><br><span class="line">    *pLastNodeInList = pCurrent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后访问右子树，把右子树也转换为有序链表</span></span><br><span class="line">    <span class="keyword">if</span> (pCurrent-&gt;m_pRight != <span class="literal">NULL</span>)</span><br><span class="line">        ConvertNode(pCurrent-&gt;m_pRight, pLastNodeInList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对为什么要传递指针变量的地址还有疑惑，不妨看看下面这个程序的效果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> b, <span class="keyword">int</span>* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    c = &amp;b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2: "</span>  &lt;&lt; *c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> b, <span class="keyword">int</span>** c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *c = &amp;b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"4: "</span>  &lt;&lt; **c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *c = &amp;a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1: "</span> &lt;&lt; *c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    func1(b, c);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3: "</span>  &lt;&lt; *c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    func2(b,&amp;c);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"5: "</span>  &lt;&lt; *c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="number">5</span></span><br><span class="line"><span class="number">2</span>: <span class="number">4</span></span><br><span class="line"><span class="number">3</span>: <span class="number">5</span></span><br><span class="line"><span class="number">4</span>: <span class="number">4</span></span><br><span class="line"><span class="number">5</span>: <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>只有按引用传递指针变量时，在函数中修改指针指向才会生效</strong>。</p><h2 id="面试题28字符串的排列">面试题28：字符串的排列</h2><h3 id="题目">题目</h3><blockquote><p>输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出有字符a、b、c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。</p></blockquote><h3 id="解析">解析</h3><p>这题有一定难度，最好还是举例来分析，并检验代码是否能得到正确结果。</p><p>思路是这样的：</p><ol><li>依次选择字符串中一个字符作为首字符固定下来</li><li>从余下字符中依次选择一个字符作为第2个字符固定下来</li><li>从余下字符中依次选择一个字符作为第3个字符固定下来<br><br>… …</li><li>当余下字符只剩下结束符<code>'\0'</code>时，整个字符串已经固定好，可以打印。</li><li>回到上一层中，尝试另一个字符</li></ol><p>采用递归的方式来实现就可以了。注意！在递归中，我们采取的方式是把固定部分以外的字符串的第一个字符依次替换为剩余字符中的一个，这就改变了原来的字符串，如果我们尝试完这一轮（即固定替换字符时的所有排列组合）递归后没有把字符换回来，回溯时就会发生错乱，从而影响到下一层（即固定部分最后一个字符的下一种可能）的递归（这里需要自己举例分析一下）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="keyword">char</span>* pStr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pStr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Permutation(pStr, pStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="keyword">char</span>* pStr, <span class="keyword">char</span>* pBegin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*pBegin == <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, pStr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 固定pBegin前的字符串，尝试pBegin处字符的所有可能取值</span></span><br><span class="line">        <span class="comment">// 注意取值只能从pBegin及其后的字符中选取，否则就会和出现</span></span><br><span class="line">        <span class="comment">// 重复打印。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span>* pCh = pBegin; *pCh != <span class="string">'\0'</span>; ++ pCh)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将字符交换到pBegin处</span></span><br><span class="line">            <span class="keyword">char</span> temp = *pCh;</span><br><span class="line">            *pCh = *pBegin;</span><br><span class="line">            *pBegin = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 固定新的字符，继续递归直到固定所有字符</span></span><br><span class="line">            Permutation(pStr, pBegin + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把pBegin换回来，否则会影响到下一轮的递归</span></span><br><span class="line">            <span class="comment">// 从而造成重复打印字符串。</span></span><br><span class="line">            temp = *pCh;</span><br><span class="line">            *pCh = *pBegin;</span><br><span class="line">            *pBegin = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer</title>
      <link href="/2020/07/06/%E5%89%91%E6%8C%87offer/2_%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/07/06/%E5%89%91%E6%8C%87offer/2_%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="面试需要的基础知识">面试需要的基础知识</h1><h2 id="面试题1赋值运算符函数">面试题1：赋值运算符函数</h2><h3 id="题目">题目</h3><blockquote><p>如下为类型CMyString的声明，请为该类型添加赋值运算符函数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CMyString(<span class="keyword">char</span>* pData = <span class="literal">NULL</span>);</span><br><span class="line">    CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">    ~CMyString(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">    CMyString&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析">解析</h3><p>乍一看，好像这个题目还挺简单的。但要注意的地方也不少。最基本的有以下几个需要考虑的点：</p><ol><li><p>返回值设置为<strong>该类型的引用</strong>，只有返回引用，才能够进行<strong>连续赋值</strong>。</p></li><li><p>传入参数设置为<strong>常量引用</strong>。如果直接传入实例（按值传递）的话，从形参到实参就需要调用一次复制构造函数，造成一些不必要的开销。又因为赋值运算中传入参数不需要被修改，所以声明为常量。</p></li><li><p>释放当前实例本身（等号左方）的内存。如果没有释放，又分配了新的空间，就会发生<strong>内存泄漏</strong>（未释放的部分一直占据着内存单元，直到程序结束）。</p></li><li><p>判断<strong>传入参数和当前实例是否同一个实例</strong>，如果是的话，直接返回当前实例。如果不做这个判断，那么释放当前实例内存时，就会把传入参数的内存也释放掉了，要赋值的内容就丢失了。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span> = (<span class="keyword">const</span> CMyString&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> []m_pData;</span><br><span class="line">    m_pData = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>]; <span class="comment">//注意+1，用于字符串的结尾字符'\0'</span></span><br><span class="line">    <span class="built_in">strcpy</span>(m_pData, str.m_pData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更进一步的话，针对<strong>内存不足</strong>的情况，可以在释放实例本身内存之前，检查一下，余下的内存空间是否足以分配所需的新空间。</p><p>具体来说，书中用了临时实例来实现，创建成功就交换当前实例和临时实例的值，在赋值完成后，临时实例被销毁，也即调用了析构函数把原本当前实例的内存释放了。</p><h2 id="面试题2实现singleton模式">面试题2：实现Singleton模式</h2><h3 id="题目">题目</h3><blockquote><p>设计一个类，我们只能生成该类的一个实例。</p></blockquote><p>题目要求实现单例这种设计模式，这个需求还是挺常见的。由于书中采用c#语言去实现，而且这题和语言本身的特性关系比较大，所以我不在这里进行详细解析了。网上也有用c++实现单例的代码，感兴趣的话可以查找一下相关资料。</p><h2 id="面试题3二维数组中的查找">面试题3：二维数组中的查找</h2><h3 id="题目">题目</h3><blockquote><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><h3 id="解析">解析</h3><p>按照这个二维数组的规律，要找出数组中是否包含目标数字，我们需要进行若干次比较操作。</p><p>如果是一个完全无序的数组，就需要逐个元素进行比较。</p><p>但对于这样有规律的数组，我们可以只跟对角线上的元素比较。比方说从左对角线（二维数组的左上角到右下角）的第一个元素（左上角）开始比较。当比较到上一个对角线元素比目标数字小，而下一个对角线元素比目标数字大时，只需要检查上一对角线元素的所在行的右边所有元素和所在列的下边所有元素就可以了。</p><p>能不能再减少一些比较次数呢？能！</p><p>如果从右对角线的第一个元素开始比较，只要该数比目标数字小，我们就可以删除掉它所在的行；只要该数比目标数字大，我们就可以删除掉它所在的列；如果相等，就查找结束。相比起上一种方法，这种方法需要查找的次数更少！（另外，从右对角线的最后一个元素开始也是可行的）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> columns, <span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(matrix != <span class="literal">NULL</span> &amp;&amp; rows &gt; <span class="number">0</span> &amp;&amp; columns &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> column = columns - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row &lt; rows &amp;&amp; column &gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row * columns + column] == number)</span><br><span class="line">            &#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row * columns + column] &gt; number)</span><br><span class="line">                -- column;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++ row;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题4替换空格">面试题4：替换空格</h2><h3 id="题目">题目</h3><blockquote><p>请实现一个函数，把字符串中的每个空格替换成&quot;%20&quot;，例如输入 “We are happy.”，则输出 “We%20are%20ha</p></blockquote><h3 id="解析">解析</h3><p>如果我们每替换一次都往后挪后面的所有字符，那么时间复杂度就是O(n^2)的，这样做了很多无用功，因为每个字符重复移动了多次。</p><p>更好的做法是先计算后新字符串的长度，然后从字符串的后部开始检查并赋值，这样每个需要移动的字符只需要移动一次就完成了，总得时间复杂度是O(n)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReplaceBlank</span><span class="params">(<span class="keyword">char</span> <span class="built_in">string</span>[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">string</span> == <span class="literal">NULL</span> &amp;&amp; length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*originalLength 为字符串string的实际长度*/</span></span><br><span class="line">    <span class="keyword">int</span> originalLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> numberOfBlank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">string</span>[i] != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ++ originalLength;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">string</span>[i] == <span class="string">' '</span>)</span><br><span class="line">            ++ numberOfBlank;</span><br><span class="line"></span><br><span class="line">        ++ i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*newLength 为把空格替换成'%20'之后的长度*/</span></span><br><span class="line">    <span class="keyword">int</span> newLength = originalLength + numberOfBlank * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(newLength &gt; length)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> indexOfOriginal = originalLength;</span><br><span class="line">    <span class="keyword">int</span> indexOfNew = newLength;</span><br><span class="line">    <span class="keyword">while</span>(indexOfOriginal &gt;= <span class="number">0</span> &amp;&amp; indexOfNew &gt; indexOfOriginal)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">string</span>[indexOfOriginal] == <span class="string">' '</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>[indexOfNew --] = <span class="string">'0'</span>;</span><br><span class="line">            <span class="built_in">string</span>[indexOfNew --] = <span class="string">'2'</span>;</span><br><span class="line">            <span class="built_in">string</span>[indexOfNew --] = <span class="string">'%'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>[indexOfNew --] = <span class="built_in">string</span>[indexOfOriginal];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        -- indexOfOriginal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题5从尾到头打印链表">面试题5：从尾到头打印链表</h2><h3 id="题目">题目</h3><blockquote><p>输入一个链表的头结点，从尾到头反过来打印出每个结点的值。链表结点定义如下：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>       m_nValue;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析">解析</h3><p>两种想法：</p><ol><li><p>要反过来输出的话，可以首先顺着遍历链表并且将每个结点的值放入栈中，<strong>利用栈后进先出的特性</strong>来逐个pop出再输出；</p></li><li><p>利用递归，递归本质上就是一个栈结构。但是当链表很长的时候，使用递归有可能导致函数调用的层级很深，从而发生函数调用栈溢出的问题。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintListReversingly_Iteratively</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;ListNode*&gt; nodes;</span><br><span class="line"></span><br><span class="line">    ListNode* pNode = pHead;</span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nodes.push(pNode);</span><br><span class="line">        pNode = pNode-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        pNode = nodes.top();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, pNode-&gt;m_nValue);</span><br><span class="line">        nodes.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintListReversingly_Recursively</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead-&gt;m_pNext != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            PrintListReversingly_Recursively(pHead-&gt;m_pNext);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, pHead-&gt;m_nValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题6重建二叉树">面试题6：重建二叉树</h2><h3 id="题目">题目</h3><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列 <code>{1,2,4,7,3,5,6,8}</code> 和中序遍历序列 <code>{4,7,2,1,5,3,8,6}</code>，则重建出如下所示的二叉树:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> /   / \</span><br><span class="line">4   5   6</span><br><span class="line"> \     /</span><br><span class="line">  7   8</span><br></pre></td></tr></table></figure><blockquote><p>二叉树结点的定义如下：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                    m_nValue;</span><br><span class="line">    BinaryTreeNode*        m_pLeft;</span><br><span class="line">    BinaryTreeNode*        m_pRight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析">解析</h3><p>由中序遍历和前序遍历序列重建树，我们可以每次取出前序遍历序列的第一个点，它对应当前树的根节点。</p><p>而在中序遍历序列中，这个点将序列分为左右两部分，左边就是根节点的左子树，右边的右子树。</p><p>并且，假设左边有m个点，右边有n个点。那么在前序遍历序列中，第一个点接下来的m个点必然就是左子树，再往后的n个点必然就是右子树。</p><p>因此，我们可以利用递归来完成重建，每次都按前序遍历序列的第一个点来划分中序遍历序列，进而划分前序遍历序列，然后分别重建根节点的左右子树即可。</p><p>特别要注意<strong>结束条件的设置</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">Construct</span><span class="params">(<span class="keyword">int</span>* preorder, <span class="keyword">int</span>* inorder, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preorder == <span class="literal">NULL</span> || inorder == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ConstructCore(preorder, preorder + length - <span class="number">1</span>,</span><br><span class="line">        inorder, inorder + length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinaryTreeNode* ConstructCore</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">int</span>* startPreorder, <span class="keyword">int</span>* endPreorder,</span><br><span class="line">    <span class="keyword">int</span>* startInorder, <span class="keyword">int</span>* endInorder</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 前序遍历序列的第一个数字是根结点的值</span></span><br><span class="line">    <span class="keyword">int</span> rootValue = startPreorder[<span class="number">0</span>];</span><br><span class="line">    BinaryTreeNode* root = <span class="keyword">new</span> BinaryTreeNode();</span><br><span class="line">    root-&gt;m_nValue = rootValue;</span><br><span class="line">    root-&gt;m_pLeft = root-&gt;m_pRight = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归到前序遍历的最后一个点</span></span><br><span class="line">    <span class="keyword">if</span>(startPreorder == endPreorder)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 递归到中序遍历的最后一个点，并且这个点和前序遍历的最后一个点相同</span></span><br><span class="line">        <span class="keyword">if</span>(startInorder == endInorder &amp;&amp; *startPreorder == *startInorder)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> exception();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在中序遍历中找到根结点的值</span></span><br><span class="line">    <span class="keyword">int</span>* rootInorder = startInorder;</span><br><span class="line">    <span class="keyword">while</span>(rootInorder &lt;= endInorder &amp;&amp; *rootInorder != rootValue)</span><br><span class="line">        ++ rootInorder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历到最后还是找不到根节点就说明两个遍历序列是不相容的，属于异常输入</span></span><br><span class="line">    <span class="keyword">if</span>(rootInorder == endInorder &amp;&amp; *rootInorder != rootValue)</span><br><span class="line">        <span class="keyword">throw</span> exception();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftLength = rootInorder - startInorder;</span><br><span class="line">    <span class="keyword">int</span>* leftPreorderEnd = startPreorder + leftLength;</span><br><span class="line">    <span class="keyword">if</span>(leftLength &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构建左子树</span></span><br><span class="line">        root-&gt;m_pLeft = ConstructCore(startPreorder + <span class="number">1</span>, leftPreorderEnd,</span><br><span class="line">            startInorder, rootInorder - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(leftLength &lt; endPreorder - startPreorder)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构建右子树</span></span><br><span class="line">        root-&gt;m_pRight = ConstructCore(leftPreorderEnd + <span class="number">1</span>, endPreorder,</span><br><span class="line">            rootInorder + <span class="number">1</span>, endInorder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题7用两个栈实现队列">面试题7：用两个栈实现队列</h2><h3 id="题目">题目</h3><blockquote><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead，分别完成在队列尾部插入结点和在队列头部删除结点的功能。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">CQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CQueue(<span class="keyword">void</span>);</span><br><span class="line">    ~CQueue(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在队列末尾添加一个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">const</span> T&amp; node)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除队列的头结点</span></span><br><span class="line">    <span class="function">T <span class="title">deleteHead</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;T&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;T&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析">解析</h3><p>思路其实很简单，使用两个栈来模拟。每次要往队尾插入一个数，就放到栈1里面。当需要出队，也即删除队首时，只需要把栈1的数依次出栈（顺序是队尾到队首）再放入栈2，这时从栈2pop出的数就是队首了。</p><p>注意，并不是每次出队都需要这样操作，我们首先做个判断，如果栈2空了再做。如果栈2没空，那么现在的队首就应该是栈2的栈顶元素了~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> CQueue&lt;T&gt;::appendTail(<span class="keyword">const</span> T&amp; element)</span><br><span class="line">&#123;</span><br><span class="line">    stack1.push(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T CQueue&lt;T&gt;::deleteHead()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(stack2.size()&lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(stack1.size()&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            T&amp; data = stack1.top();</span><br><span class="line">            stack1.pop();</span><br><span class="line">            stack2.push(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(stack2.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> exception();</span><br><span class="line"></span><br><span class="line">    T head = stack2.top();</span><br><span class="line">    stack2.pop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题8旋转数组的最小数字">面试题8：旋转数组的最小数字</h2><h3 id="题目">题目</h3><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组 <code>{3,4,5,1,2}</code> 为 <code>{1,2,3,4,5}</code> 的一个旋转，该数组的最小值为1。</p></blockquote><h3 id="解析">解析</h3><p>这道题其实有点类似于有序数组查找一个数的情况，还是可以<strong>用二分查找的思路</strong>。</p><p>旋转数组其实可以分两成两个递增子数组A1和A2，而最小元素就是数组A2的第一个元素。</p><p>具体来说，我们使用两个指针p1和p2，分别指向A1的第一个元素和A2的最后一个元素。p1右移，p2左移，不断缩小需要比较的范围。当p1和p2相差1时，p2所指的就是数组的最小元素，这就是终止条件。</p><p>怎样使用二分查找的思路缩小范围呢？很简单。假设当前序列的中间序列为m，我们比较一下m和p1所指的元素谁比较大。如果m更大或者与p1相等，就说明m位于A1中，那么p1和m之间的元素我们都不再需要比较了，它们都比p1大，肯定不是最小元素，此时我们可以令p1指向m，得到新的序列，并继续下一次查找。</p><p>反过来，如果m比p1所指的元素小，那就说明m位于A2中，此时最小元素在p1和m之间，我们可以令p2指向m来缩小查找范围。</p><p>注意了！既然是比大小，那就很有可能出现相等的情况。当p1，p2和m都相等时，我们无法判断m到底属于A1还是A2，也就无法缩小范围。比方说数组 <code>{1,0,1,1,1}</code>，如果我们按照先比较p1和m的方式，下一步就变成搜索数组 <code>{1,1,1}</code> 了，显然是不对的。</p><p>怎样处理这种情况呢？很可惜，没有取巧的方法，遇到这样的情况，我们只能顺序查找当前数组了。</p><p>注意，在初始化中间元素时，不应直接初始化为0，而应初始化为p1所指的元素。因为旋转数组有可能是将0个数字旋转到尾部，也即整个数组依然是一个递增数组。如果我们将p1大于等于p2作为循环查找的条件，那就要特别注意这个点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> exception();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index2 = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> indexMid = index1; <span class="comment">// 如果旋转了0个元素，那么最小元素就是index1所指的，所以这样初始化</span></span><br><span class="line">    <span class="keyword">while</span>(numbers[index1] &gt;= numbers[index2])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果index1和index2指向相邻的两个数，</span></span><br><span class="line">        <span class="comment">// 则index1指向第一个递增子数组的最后一个数字，</span></span><br><span class="line">        <span class="comment">// index2指向第二个子数组的第一个数字，也就是数组中的最小数字</span></span><br><span class="line">        <span class="keyword">if</span>(index2 - index1 == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            indexMid = index2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果下标为index1、index2和indexMid指向的三个数字相等，</span></span><br><span class="line">        <span class="comment">// 则只能顺序查找</span></span><br><span class="line">        indexMid = (index1 + index2) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers[index1] == numbers[index2] &amp;&amp; numbers[indexMid] == numbers[index1])</span><br><span class="line">            <span class="keyword">return</span> MinInOrder(numbers, index1, index2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缩小查找范围</span></span><br><span class="line">        <span class="keyword">if</span>(numbers[indexMid] &gt;= numbers[index1])</span><br><span class="line">            index1 = indexMid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[indexMid] &lt;= numbers[index2])</span><br><span class="line">            index2 = indexMid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numbers[indexMid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinInOrder</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = numbers[index1];</span><br><span class="line">    <span class="comment">// 按顺序查找</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = index1 + <span class="number">1</span>; i &lt;= index2; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(result &gt; numbers[i])</span><br><span class="line">            result = numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题9斐波拉契数列">面试题9：斐波拉契数列</h2><h3 id="题目">题目</h3><blockquote><p>写一个函数，输入n，求斐波拉契（Fibonacci）数列的第n项。斐波拉契数列的定义如下：</p></blockquote><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f00c4321176b6522fe148a11a80a8e5fca9e88da" alt="fib1">，初始值：<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6890c552b2226e339520693a236386ed2346a63a" alt="fib1"></p><h3 id="解析">解析</h3><p>求斐波拉契数列最简单的一种思路是使用递归，但是递归其实是一种效率非常低的解法，举个例子，求数列的第10项，过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">             f(10)</span><br><span class="line">            /    \</span><br><span class="line">        f(9)      f(8)</span><br><span class="line">       /    \    /    \</span><br><span class="line">    f(8)  f(7) f(7)  f(6)</span><br><span class="line">...  ...  ...  ...  ...  ...</span><br></pre></td></tr></table></figure><p>每一项都被分解为左右两棵子树来求，可以看到左右两棵子树会有很多重复的结点，这些都是冗余的。当n相当大时，会有大量的冗余结点，造成求解的效率非常低。</p><p>更好的思路是采用O(n)的解法，从f(2)开始逐步往上算，这样每一项只求一次就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Fibonacci_Solution2</span><span class="params">(<span class="keyword">unsigned</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> result[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span>  fibNMinusOne = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span>  fibNMinusTwo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span>  fibN = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        fibN = fibNMinusOne + fibNMinusTwo; <span class="comment">// f(n) = f(n-1) + f(n-2)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新f(n-1) 和 f(n-2)</span></span><br><span class="line">        fibNMinusTwo = fibNMinusOne;</span><br><span class="line">        fibNMinusOne = fibN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> fibN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外还有基于矩阵乘法的O(log n)解法，这里暂不深入探索，感兴趣的话可以在代码文件中查看。</p><h2 id="面试题10二进制中1的个数">面试题10：二进制中1的个数</h2><h3 id="题目">题目</h3><blockquote><p>请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。</p></blockquote><h3 id="解析">解析</h3><p>最简单的一个思路，每次将这个整数的二进制表示右移一位，统计个位是1的次数，数字变为0时结束。</p><p>二进制右移一位这个操作其实相当于将整数除以2，但这里我们不使用除法，因为除法效率很低，<strong>在实际任务中，应尽量使用位运算</strong>。另外，判断各位是不是1，只要和1相与就可以了，整数1的二进制表示是31个0并上一个1，因此只有各位是1时，两数相与才会得到1。</p><p>但是！上面的思路有一个很严重的问题，题目说的是整数，而不是正整数。c++中整数的表示范围是 <code>[-2147483648,2147483647]</code>，用32个bit表示，并且最高位是符号位（正数为0，负数为1）。在右移的时候，因为要保证移位前后符号相同，所以负数高位补的是1。这样数字永远都不会是0，程序会陷入死循环中。</p><p>这里补充一点，负数的二进制表示是将对应的正数所有位取反，然后加一。举个例子：</p><p>32位的int类型中，</p><ul><li><p>正数5的二进制表示为 <code>00000000000000000000000000000101</code>；</p></li><li><p>而负数-5的二进制表示就是 <code>11111111111111111111111111111011</code>。</p></li><li><p>最大整数2147483647的二进制表示是    <code>01111111111111111111111111111111</code>；</p></li><li><p>对应负数-2147483647的二进制表示则是 <code>10000000000000000000000000000001</code>。</p></li></ul><p>特别地，最小负数-2147483648的二进制表示是 <code>10000000000000000000000000000000</code>。</p><p>注意了，这些表示是要看数值类型所用的位数来定的。</p><p>在了解了这些情况之后，可以想到一个新的思路。设定unsigned int类型的变量flag为1，我们可以把对输入的整数进行右移改为对flag进行左移，每一次相与之后就把flag左移一位，对于flag来说，左移32位后就变为0了，我们可以利用这点作为循环结束的条件。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1_Solution1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; flag)</span><br><span class="line">            count ++;</span><br><span class="line"></span><br><span class="line">        flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现，上面的解法是根据数值类型来决定循环次数的，一个int类型的数就需要循环32次。有没有办法再减少次数呢？有的！</p><p>我们先做个分析，一个数减去1之后，它的二进制表示有两种可能的变化：</p><ul><li>最右边一位是1，则最右边一位变0，其他位不变；</li><li>最右边一位没有1，则最靠右的1（只要一个数不为0，则至少存在一位是1）变0，该位的右边都变为1。</li></ul><p>如果我们把减去1之后的数和原来的数相与，会发生什么呢？可以发现，这样操作实质是<strong>把原来数字最靠右的1变为0，其余位不变</strong>！于是，一个整数的二进制表示<strong>有多少个1就可以进行多少次这样的操作</strong>，大大减少了循环的次数！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1_Solution2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        ++ count;</span><br><span class="line">        n = (n - <span class="number">1</span>) &amp; n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer</title>
      <link href="/2020/07/06/%E5%89%91%E6%8C%87offer/7_%E4%B8%A4%E4%B8%AA%E9%9D%A2%E8%AF%95%E6%A1%88%E4%BE%8B/"/>
      <url>/2020/07/06/%E5%89%91%E6%8C%87offer/7_%E4%B8%A4%E4%B8%AA%E9%9D%A2%E8%AF%95%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="两个面试案例">两个面试案例</h1><h2 id="面试题49把字符串转换成整数">面试题49：把字符串转换成整数</h2><h3 id="题目">题目</h3><blockquote><p>写一个函数StrToInt，实现把字符串转换为整数这个功能。不能使用atoi或者其他类似的库函数。</p></blockquote><h3 id="解析">解析</h3><p>这条题看似简单，要把数字字符转为int型数值，只需要减去字符0就可以了。但是实际上这里有很多需要考虑的状况，这里简单地概括一下：</p><ol><li>能检测出非法的输入，包括空指针、空字符串、只有正号/负号没有数字、数字部分出现非数字字符。</li><li>输入非法时，依然能返回一个整数（比方说0），而且能和正常返回该整数的状况区别开来。因此还要设置一个全局标志位（atoi就是这样做的）。</li><li>字符串表示的数字超出int型的表示范围时，同样属于非法输入，程序能够检测到并做恰当的处理。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Status &#123;kValid = <span class="number">0</span>, kInvalid&#125;;</span><br><span class="line"><span class="comment">// 全局标志，输入无效字符串时函数返回0，该标志用于和输入字符串'0'作区分</span></span><br><span class="line"><span class="keyword">int</span> g_nStatus = kValid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_nStatus = kInvalid;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>; <span class="comment">// 使用long long来获取转换的数，然后再判断是否超出int型（发生溢出）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(str != <span class="literal">NULL</span> &amp;&amp; *str != <span class="string">'\0'</span>) <span class="comment">// 避免空指针和空字符串的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取出正负号，并移动到数字部分的第一位</span></span><br><span class="line">        <span class="comment">// 如果只有正负号没有数字则会移动到结束符'\0'，不会继续转换</span></span><br><span class="line">        <span class="keyword">bool</span> minus = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">'+'</span>)</span><br><span class="line">            str ++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*str == <span class="string">'-'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            str ++;</span><br><span class="line">            minus = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(*str != <span class="string">'\0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num = StrToIntCore(str, minus);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)num; <span class="comment">//记得最后要转换为int型返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">StrToIntCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* digit, <span class="keyword">bool</span> minus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*digit != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*digit &gt;= <span class="string">'0'</span> &amp;&amp; *digit &lt;= <span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> flag = minus ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">            num = num * <span class="number">10</span> + flag * (*digit - <span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否超出了int型的表示范围，也即发生溢出</span></span><br><span class="line">            <span class="keyword">if</span>((!minus &amp;&amp; num &gt; <span class="number">0x7FFFFFFF</span>)</span><br><span class="line">                || (minus &amp;&amp; num &lt; (<span class="keyword">signed</span> <span class="keyword">int</span>)<span class="number">0x80000000</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            digit++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 一旦遇到非数字字符，就退出并返回0</span></span><br><span class="line">        &#123;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功转换完成，把全局标志置为有效</span></span><br><span class="line">    <span class="keyword">if</span>(*digit == <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        g_nStatus = kValid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题50树中两个结点的最低公共祖先">面试题50：树中两个结点的最低公共祖先</h2><h3 id="题目">题目</h3><blockquote><p>输入两个树结点，求它们的最低公共祖先。</p></blockquote><h3 id="解析">解析</h3><p>这一题的题目其实故意没有说清楚，给定两个树节点，那么这是一棵怎样的树呢？数据结构的定义是怎样的呢？面试官希望我们能想到这些未曾提到的点，并做出反应。</p><p>如果这是一棵二叉搜索树，那找到两个结点的最低公共祖先很简单。我们从根结点开始遍历这棵树，如果当前结点比两个输入结点都大，那么两个输入结点必然都在当前结点的左子树上；如果当前结点比两个输入结点都小，那么两个输入结点必然都在当前结点的右子树上。当我们遍历到一个结点比其中一个输入结点大，比另外一个输入结点小，就找到两个输入结点的最低公共祖先了。因为从这个结点再往下，两个输入结点不会再出现在同一棵子树上了。</p><p>如果是一棵普通的树，但是每个结点有指向父结点的指针，我们把这棵树换个方向来看，其实这道题就变成了前面求两个链表的第一个共同结点的题目。</p><p>如果只是一棵普通的树，树结点定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                    m_nValue;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TreeNode*&gt;    m_vChildren;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个结点有个数不等的多个子结点，且只有指向子结点的指针。这时又应该怎样求解呢？</p><p>最笨的方法是从根结点开始遍历，逐个结点判断两个输入结点是否都在它的同一棵子树中，当到达一个结点，两个输入结点被分散在该结点的不同子树中时，该结点就是最低公共祖先。</p><p>这个方法效率不高，因为从上往下扫的过程中产生了相当多重复的查找。这里介绍一种借助辅助空间来减少时间复杂度的方法。</p><p>我们可以使用两个双向链表（list容器）来分别记录下到达两个结点的完整路径（基于前序遍历来获取），然后就可以把问题转化为求两个链表的第一个共同结点（把list最后一个元素作为链表第一个元素）了。这里因为我们可以直接得到链表头，所以这个问题又可以写作求两个链表的最后一个共同结点（从list.begin()开始）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历根结点为pRoot的树，找到pNode所在的路径，记录在path里面</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetNodePath</span><span class="params">(TreeNode* pRoot, TreeNode* pNode, <span class="built_in">list</span>&lt;TreeNode*&gt;&amp; path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == pNode)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    path.push_back(pRoot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历当前结点的所有子结点，直到找到pNode</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt;::iterator i = pRoot-&gt;m_vChildren.begin();</span><br><span class="line">    <span class="keyword">while</span>(!found &amp;&amp; i &lt; pRoot-&gt;m_vChildren.end())</span><br><span class="line">    &#123;</span><br><span class="line">        found = GetNodePath(*i, pNode, path);</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前路径无法到达pNode，从路径中移除当前结点，返回上一层</span></span><br><span class="line">    <span class="keyword">if</span>(!found)</span><br><span class="line">        path.pop_back();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取path1和path2两条路径的最后一个共同结点</span></span><br><span class="line">TreeNode* GetLastCommonNode</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">list</span>&lt;TreeNode*&gt;&amp; path1,</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">list</span>&lt;TreeNode*&gt;&amp; path2</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// const_iterator指向的对象是常量，即iterator指向常对象，</span></span><br><span class="line">    <span class="comment">// 迭代器本身指向可变，但它指向的对象的内容是const的。</span></span><br><span class="line">    <span class="built_in">list</span>&lt;TreeNode*&gt;::const_iterator iterator1 = path1.begin();</span><br><span class="line">    <span class="built_in">list</span>&lt;TreeNode*&gt;::const_iterator iterator2 = path2.begin();</span><br><span class="line"></span><br><span class="line">    TreeNode* pLast = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(iterator1 != path1.end() &amp;&amp; iterator2 != path2.end())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*iterator1 == *iterator2) <span class="comment">// 每次找到共同结点都会更新</span></span><br><span class="line">            pLast = *iterator1;</span><br><span class="line"></span><br><span class="line">        iterator1++;</span><br><span class="line">        iterator2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pLast;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">GetLastCommonParent</span><span class="params">(TreeNode* pRoot, TreeNode* pNode1, TreeNode* pNode2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span> || pNode1 == <span class="literal">NULL</span> || pNode2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先分别拿到路径</span></span><br><span class="line">    <span class="built_in">list</span>&lt;TreeNode*&gt; path1;</span><br><span class="line">    GetNodePath(pRoot, pNode1, path1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;TreeNode*&gt; path2;</span><br><span class="line">    GetNodePath(pRoot, pNode2, path2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再找路径的最后共同结点</span></span><br><span class="line">    <span class="keyword">return</span> GetLastCommonNode(path1, path2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer</title>
      <link href="/2020/07/06/%E5%89%91%E6%8C%87offer/3_%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
      <url>/2020/07/06/%E5%89%91%E6%8C%87offer/3_%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="高质量的代码">高质量的代码</h1><h2 id="面试题11数值的整数次方">面试题11：数值的整数次方</h2><h3 id="题目">题目</h3><blockquote><p>实现函数 <code>double Power(double base, int exponent)</code>，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p></blockquote><h3 id="解析">解析</h3><p>乍看之下，这道题其实挺简单的，似乎写个循环就好了，但其实包含了很多小的细节。</p><p>比方说从减少时间复杂度的角度考虑，直接用循环求一个数的n次方，复杂度是O(n)；而如果采用<strong>快速求幂</strong>：</p><ol><li>a^n = a^(n/2) · a^(n/2),    n为偶数</li><li>a^n = a^(n/2) · a^(n/2) · a, n为奇数</li></ol><p>复杂度就变为了O(log n)</p><p>更深入地，如何判断一个数是奇数还是偶数呢？直接<strong>用求余运算符（%）的效率不如使用位运算</strong>。我们可以通过判断一个数与1相与的结果来判断，因为奇数的二进制表示最右边一位必然是1。</p><p>有了上面这些分析，基本的框架就搭起来了。但是！还有很多细节没注意到！</p><p>如果指数为0，应该怎么处理呢？指数是负数的话前面的计算方法还成立吗？如果底数为0，又应该怎么处理呢？</p><p>首先，指数为0的求幂应该返回结果1，特别地，0的0次方在数学上是没有意义的，返回0或者1都可以，具体可以跟面试官沟通一下。</p><p>然后，对于指数为负的状况，我们可以先把指数变为绝对值，然后求幂，最后取倒数即可。特别地，取倒数时<strong>不应该用1作为被除数</strong>，而应用1.0。因为题目中给出的底数是double类型，返回值也是double类型。如果我们用1作为被除数，那么当底数是1是，求倒数得到的就会变成了int类型。</p><p>最后，针对底数为0的问题，我们要注意到<strong>对0求负数幂是不可能的</strong>，因为0无法作为分母。这时候应该返回什么呢？可以选择返回0，但是怎样<strong>和正常返回0的情况作区分</strong>呢？我们可以再设置一个全局标志。虽然直接返回数值允许我们在调用这个函数时可以直接赋值，但如果<strong>忘记检查全局标志</strong>依然会出错。</p><p>最后的最后，还有一个小细节，在检查底数是否为0时，不能直接使用 <code>base == 0</code> 来判定。因为<strong>计算机中表示小数（double类型和float类型）是有误差的</strong>，所以如果要判断两个小数是否相等，我们应该看它们的<strong>差的绝对值是否足够小</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> g_InvalidInput = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_InvalidInput = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(equal(base, <span class="number">0.0</span>) &amp;&amp; exponent &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        g_InvalidInput = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> absExponent = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(exponent);</span><br><span class="line">    <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)</span><br><span class="line">        absExponent = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(-exponent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> result = PowerWithUnsignedExponent(base, absExponent);</span><br><span class="line">    <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)</span><br><span class="line">        result = <span class="number">1.0</span> / result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">PowerWithUnsignedExponent</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">unsigned</span> <span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> result = PowerWithUnsignedExponent(base, exponent &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    result *= result;</span><br><span class="line">    <span class="keyword">if</span>((exponent &amp; <span class="number">0x1</span>) == <span class="number">1</span>)</span><br><span class="line">        result *= base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((num1 - num2 &gt; <span class="number">-0.0000001</span>)</span><br><span class="line">        &amp;&amp; (num1 - num2 &lt; <span class="number">0.0000001</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题12打印1到最大的n位数">面试题12：打印1到最大的n位数</h2><h3 id="题目">题目</h3><blockquote><p>输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。</p></blockquote><h3 id="解析">解析</h3><p>初看这条题，容易产生好简单的错觉。如果我们不需要考虑<strong>大数问题</strong>，那这条题将没有任何难度。而事实上，题目所说的n位数很可能是超出int甚至long long所能表示的，因此我们只能用字符串或者数组来进行表示了。</p><p>考虑字符串表示的方法，最直观的做法是<strong>模拟加法</strong>来实现，代码中的解法一就是这样做的。但是这样写的代码不太简洁，有没有更好的思路呢？</p><p>其实，题目要求按顺序打印出从1最大的n位十进制数，这个数的每一位无非就只有10种可能，也即我们可以把它想像成一个<strong>排列组合问题</strong>。只要我们按顺序罗列出所有排列组合就可以了。</p><p>可以使用<strong>递归</strong>的方式来实现，递归结束的条件就是设置完最后一位的数值。</p><p>最后要注意，使用字符串来表示数字，从索引0到n-1分别对应着数字的最高位到最低位。但不是所有数都是n位数，有可能是两位数、三位数等等，因此输出时要把高位的0过滤掉。特别注意，按照前面的思路，我们有可能得到n位全是0这种排列，按题目要求是从1开始输出，所以我们也要注意避免输出数字0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigits_2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="comment">// 避免不合法的输入</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* number = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line">    number[n] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次尝试最高位数字的10种可能</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        number[<span class="number">0</span>] = i + <span class="string">'0'</span>; <span class="comment">//int转为对应char</span></span><br><span class="line">        Print1ToMaxOfNDigitsRecursively(number, n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用递归来完成数字各个位置的设置，并尝试所有的可能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigitsRecursively</span><span class="params">(<span class="keyword">char</span>* number, <span class="keyword">int</span> length, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 索引为length-1时，数字设置完成，打印当前数字</span></span><br><span class="line">    <span class="keyword">if</span>(index == length - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PrintNumber(number);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未设置完成则依次尝试右边一位的10种可能</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        number[index + <span class="number">1</span>] = i + <span class="string">'0'</span>;</span><br><span class="line">        Print1ToMaxOfNDigitsRecursively(number, length, index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串number表示一个数字，数字有若干个0开头</span></span><br><span class="line"><span class="comment">// 打印出这个数字，并忽略开头的0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintNumber</span><span class="params">(<span class="keyword">char</span>* number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isBeginning0 = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> nLength = <span class="built_in">strlen</span>(number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isBeginning0 &amp;&amp; number[i] != <span class="string">'0'</span>)</span><br><span class="line">            isBeginning0 = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!isBeginning0)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, number[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!isBeginning0)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\t"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题13在o1时间删除链表结点">面试题13：在O(1)时间删除链表结点</h2><h3 id="题目">题目</h3><blockquote><p>给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。链表结点与函数的定义如下：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>       m_nValue;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void DeleteNode(ListNode** pListHead, ListNode* pToBeDeleted);</span><br></pre></td></tr></table></figure><h3 id="解析">解析</h3><p>最常规的一种思路是遍历链表找到这个结点，删除它并把它前一结点的指针指向下一结点。但这样做复杂度是O(n)，而题目要求的是O(1)的时间复杂度，怎么做到呢？</p><p>其实不难，所谓O(1)意思是<strong>处理的时间与输入规模无关</strong>。我们可以直接从要删除的结点下手，把下一结点的内容复制到要删除的结点中，然后把要删除的结点的指针指向下下个结点，并把下一结点删除掉。这样做和前面的效果是一样的。</p><p>但是！注意了，如果<strong>要删除的结点是尾</strong>结点就无法这样做了，因为没有下一结点，这时只能顺序遍历来删除。还有一个细节，如果<strong>链表只有一个结点</strong>，那么除了删除，还要把头结点设置为NULL。</p><p>此外，以上分析都是基于链表中存在待删除结点来讨论的，如果要删除的结点不在链表中就会出错，这就需要调用函数的人自己注意了。要确定一个结点是否在链表中还是需要O(n)的时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(ListNode** pListHead, ListNode* pToBeDeleted)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pListHead || !pToBeDeleted)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要删除的结点不是尾结点</span></span><br><span class="line">    <span class="keyword">if</span>(pToBeDeleted-&gt;m_pNext != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pNext = pToBeDeleted-&gt;m_pNext;</span><br><span class="line">        pToBeDeleted-&gt;m_nValue = pNext-&gt;m_nValue;</span><br><span class="line">        pToBeDeleted-&gt;m_pNext = pNext-&gt;m_pNext;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> pNext;</span><br><span class="line">        pNext = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表只有一个结点，删除头结点（也是尾结点）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(*pListHead == pToBeDeleted)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pToBeDeleted;</span><br><span class="line">        pToBeDeleted = <span class="literal">NULL</span>;</span><br><span class="line">        *pListHead = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表中有多个结点，删除尾结点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pNode = *pListHead;</span><br><span class="line">        <span class="keyword">while</span>(pNode-&gt;m_pNext != pToBeDeleted)</span><br><span class="line">        &#123;</span><br><span class="line">            pNode = pNode-&gt;m_pNext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pNode-&gt;m_pNext = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">delete</span> pToBeDeleted;</span><br><span class="line">        pToBeDeleted = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题14调整数组顺序使奇数位于偶数前面">面试题14：调整数组顺序使奇数位于偶数前面</h2><h3 id="题目">题目</h3><blockquote><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p></blockquote><h3 id="解析">解析</h3><p>这条题的思路其实不难，我们<strong>维护两个指针</strong>即可。指针1初始化指向数组的第一个元素，并向后移动；指针2初始化指向数组的最后一个元素，并向前移动。</p><p>首先往后移动指针1，当指针1指向偶数时，开始往前移动指针2，直至指针2指向奇数。注意，在这两个过程中，有可能指针1和指针2会相遇，这表示数组已经调整完毕。如果没有相遇，就证明还需继续调整，将此时指针1和指针2所指的数字交换位置，再继续下一轮的查找，直至两指针相遇时结束。</p><p>这道题其实可以做很多扩展，可能不是针对奇偶数重排，而是素数非素数，正数负数等等。<strong>考虑扩展性</strong>的话，我们不妨把判断部分分离出来写成一个函数，在重排时<strong>把判断函数作为一个参数传入</strong>即可。</p><p>具体来说，这里依然使用位运算来实现判断奇偶，把这个操作封装为一个函数，传入参数为int型变量，返回值为bool型变量。</p><p>在声明重排函数的参数时，格式就是 <code>返回值类型 (*函数别名)(函数的参数类型)</code>。其中函数别名根据自己喜欢来取就可以了。</p><p>在调用重排函数时，我们传入函数名就可以了，不需要作其他处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReorderOddEven_2</span><span class="params">(<span class="keyword">int</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Reorder(pData, length, isEven);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reorder</span><span class="params">(<span class="keyword">int</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">int</span> length, <span class="keyword">bool</span> (*func)(<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pData == <span class="literal">NULL</span> || length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *pBegin = pData;</span><br><span class="line">    <span class="keyword">int</span> *pEnd = pData + length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pBegin &lt; pEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 向后移动pBegin</span></span><br><span class="line">        <span class="keyword">while</span>(pBegin &lt; pEnd &amp;&amp; !func(*pBegin))</span><br><span class="line">            pBegin ++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向前移动pEnd</span></span><br><span class="line">        <span class="keyword">while</span>(pBegin &lt; pEnd &amp;&amp; func(*pEnd))</span><br><span class="line">            pEnd --;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pBegin &lt; pEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = *pBegin;</span><br><span class="line">            *pBegin = *pEnd;</span><br><span class="line">            *pEnd = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题15链表中的倒数第k个结点">面试题15：链表中的倒数第k个结点</h2><h3 id="题目">题目</h3><blockquote><p>输入一个链表，输出该链表中倒数第k个结点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾结点是倒数第1个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个结点是值为4的结点。链表结点定义如下：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>       m_nValue;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析">解析</h3><p>由于这是一个单向链表，所以就不存在先走到链表尾部，再倒退k-1步的可能了。</p><p>最普通的一个思路是，使用一个指针，先遍历一次整个链表，得到链表长度n。倒数第k个结点是链表中的第n-k+1个结点。我们只要然后重新从链表头开始走n-k步就能走到它了。</p><p>但是这样需要遍历两次，有没有<strong>只遍历一次</strong>就能找到它的方法呢？</p><p>有的。类似上一道题，我们维护两个指针就可以了。指针1先走，在指针1走了k-1步之后指针2再走。这样当指针1到底尾结点时，指针2所指的就是倒数第k个结点。</p><p>上面的解法有3个很大的漏洞：</p><ol><li><p><strong>链表头结点是空指针</strong>，遍历这样的链表会造成访问空指针指向的内存，引起程序崩溃，所以要额外处理。</p></li><li><p><strong>链表结点数目少于k</strong>，如果我们直接让指针1在循环中走k-1步而不加判断，同样会访问到空指针指向的内存。</p></li><li><p><strong>k为0</strong>，如果我们定义k是unsigned int型，那么k-1就是unsigned int型能表示的最大整数4294967295（即二进制的0xFFFFFFFF，最高位不需用于标识符号），循环的次数将会非常恐怖… 所以我们必须对k值是否合法也做一个判断。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pListHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 空指针处理和合法k值检查</span></span><br><span class="line">    <span class="keyword">if</span>(pListHead == <span class="literal">NULL</span> || k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ListNode *pAhead = pListHead;</span><br><span class="line">    ListNode *pBehind = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针1走k-1步</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pAhead-&gt;m_pNext != <span class="literal">NULL</span>) <span class="comment">// 对链表长度不足k作出处理</span></span><br><span class="line">            pAhead = pAhead-&gt;m_pNext;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针2开始走，直到指针1走到链表尾时停止</span></span><br><span class="line">    pBehind = pListHead;</span><br><span class="line">    <span class="keyword">while</span>(pAhead-&gt;m_pNext != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pAhead = pAhead-&gt;m_pNext;</span><br><span class="line">        pBehind = pBehind-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pBehind;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题16反转链表">面试题16：反转链表</h2><h3 id="题目">题目</h3><blockquote><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。链表结点定义如下：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>       m_nValue;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析">解析</h3><p>关于链表的题目，其实最好画图来把过程中的各个步骤都理清楚。要实现反转链表，我们需要维护三个指针，一个指向当前结点，一个指向上一结点，还有一个指向下一结点。</p><p>当我们实现反转时，其实是把原链表中上一结点变成当前结点的下一结点，但这样就会使得链表发生断裂，原链表中下一结点就找不到了，所以我们要先记住它。</p><p>在每一个翻转过程中，有以下步骤：</p><ol><li>得到当前结点的下一结点</li><li>判断下一结点是否NULL，也即是否到达原链表的链表尾<ul><li>若下一结点为NULL，说明当前结点就是反转链表的链表头</li></ul></li><li>把当前结点的指针指向上一结点</li><li>更新<ul><li>当前结点变为上一结点</li><li>下一结点变为当前结点</li></ul></li><li>当前结点为NULL时结束，否则继续下一次反转</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* pReversedHead = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* pNode = pHead;</span><br><span class="line">    ListNode* pPrev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pNext = pNode-&gt;m_pNext;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pNext == <span class="literal">NULL</span>)</span><br><span class="line">            pReversedHead = pNode;</span><br><span class="line"></span><br><span class="line">        pNode-&gt;m_pNext = pPrev;</span><br><span class="line"></span><br><span class="line">        pPrev = pNode;</span><br><span class="line">        pNode = pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pReversedHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题17合并两个排序的链表">面试题17：合并两个排序的链表</h2><h3 id="题目">题目</h3><blockquote><p>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。例如下面的链表1和链表2可以合并为链表3。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">链表1： 1 -&gt; 3 -&gt; 5 -&gt; 7</span><br><span class="line">链表2： 2 -&gt; 4 -&gt; 6 -&gt; 8</span><br><span class="line">链表3： 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8</span><br></pre></td></tr></table></figure><blockquote><p>链表结点定义如下：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>       m_nValue;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析">解析</h3><p>这题其实写成代码不算难，但还是要理清思路。合并两个<strong>递增排序链表</strong>，我们可以采取递归的方式。</p><p>令<strong>递归函数返回合并链表的链表头</strong>，在每次递归中，我们先对两个链表的链表头进行判断，取较小的一个作为合并链表的头结点（并在函数结束时返回）。然后，还要重新设置这个结点的next指针，它指向的是两个链表未被并入的结点中最小的那个结点。要实现这一点，我们只需要令这一轮头结点被并入的链表的头结点指针往后移动一个位置，然后继续递归合并两个链表就可以了。<strong>下一轮递归返回的链表头就是当前合并链表的头结点的next指针指向的结点</strong>。</p><p>关键是<strong>递归结束条件的设置</strong>，有以下三种情况：</p><ol><li><p>链表1的头结点为NULL而链表2不是，此时返回链表2的头结点即可，因为链表2本身也是递增排序，所以合并后依然能保持递增排序；</p></li><li><p>链表2的头结点为NULL而链表1不是，此时返回链表1的头结点即可，因为链1本身也是递增排序，所以合并后依然能保持递增排序；</p></li><li><p>链表1和链表2的头结点都是NULL，此时返回NULL即可。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里实际已经包含了三种递归结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(pHead1 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> pHead2;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pHead2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> pHead1;</span><br><span class="line"></span><br><span class="line">    ListNode* pMergedHead = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pHead1-&gt;m_nValue &lt; pHead2-&gt;m_nValue)</span><br><span class="line">    &#123;</span><br><span class="line">        pMergedHead = pHead1;</span><br><span class="line">        pMergedHead-&gt;m_pNext = Merge(pHead1-&gt;m_pNext, pHead2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pMergedHead = pHead2;</span><br><span class="line">        pMergedHead-&gt;m_pNext = Merge(pHead1, pHead2-&gt;m_pNext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pMergedHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题18树的子结构">面试题18：树的子结构</h2><blockquote><p>题目：输入两棵二叉树A和B，判断B是不是A的子结构。二叉树结点的定义如下：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                    m_nValue;</span><br><span class="line">    BinaryTreeNode*        m_pLeft;</span><br><span class="line">    BinaryTreeNode*        m_pRight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析">解析</h3><p>树的结构要比链表更加复杂，但是只要分析得好，这一题不算太难。</p><p>我们将整个判断过程分为两个步骤：</p><ol><li>寻找树A中与树B根结点值相同的结点R；</li><li>分析树A中以结点R为根结点的子树是否和树B的结构一样。</li></ol><p>具体来说可以实现两个递归函数。</p><p>函数1执行步骤1。输入两棵树的根结点，如果树A根结点与B的不同，则把它左右子树的根结点作为树A的根节点传入函数1来递归查找；如果两棵树根结点相同就调用函数2。递归的终止条件有两种情形：</p><ol><li>树A或树B的根节点为NULL，有可能是因为输入了空指针，也可能是递归查找到达了树A的叶结点处仍然没匹配上，这两种情况都是返回false；</li><li>这一轮成功匹配上，匹配上之后就不需要再递归查找了，所以我们在 调用函数2得到结果后，先判断有没匹配成功，没有再看左子树，左子树也没有才看右子树。</li></ol><p>函数2执行步骤2。输入两棵树的当前结点，如果树B当前结点为NULL，说明匹配成功了；否则如果树A当前结点为NULL，说明A已经到叶结点但还没匹配完，也即匹配失败。另外，只要在这一轮中，两棵树的当前结点值不同，也算匹配失败。如果经过以上判断后，仍然没有得到匹配结果，那就说明目前还是能匹配上的，下一步继续递归地检查两棵树当前结点的左子树和右子树是否也能匹配。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果到了叶结点依然没匹配上或者传入的树是空指针就直接返回false</span></span><br><span class="line">    <span class="keyword">if</span>(pRoot1 != <span class="literal">NULL</span> &amp;&amp; pRoot2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1-&gt;m_nValue == pRoot2-&gt;m_nValue)</span><br><span class="line">            result = DoesTree1HaveTree2(pRoot1, pRoot2);</span><br><span class="line">        <span class="comment">// 实际隐藏了一个递归结束的条件</span></span><br><span class="line">        <span class="comment">// 成功匹配时，不会再继续递归搜索左右子树了</span></span><br><span class="line">        <span class="comment">// 因此成功匹配的那一轮就停下了并返回结果</span></span><br><span class="line">        <span class="keyword">if</span>(!result)</span><br><span class="line">            result = HasSubtree(pRoot1-&gt;m_pLeft, pRoot2);</span><br><span class="line">        <span class="keyword">if</span>(!result)</span><br><span class="line">            result = HasSubtree(pRoot1-&gt;m_pRight, pRoot2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DoesTree1HaveTree2</span><span class="params">(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pRoot1 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pRoot1-&gt;m_nValue != pRoot2-&gt;m_nValue)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DoesTree1HaveTree2(pRoot1-&gt;m_pLeft, pRoot2-&gt;m_pLeft) &amp;&amp;</span><br><span class="line">        DoesTree1HaveTree2(pRoot1-&gt;m_pRight, pRoot2-&gt;m_pRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer</title>
      <link href="/2020/07/06/%E5%89%91%E6%8C%87offer/"/>
      <url>/2020/07/06/%E5%89%91%E6%8C%87offer/</url>
      
        <content type="html"><![CDATA[<p>《剑指offer》阅读笔记<br>全书共8章，因此，我的笔记也分为相应的8个章节，可以从以下目录访问</p><h3 id="面试的流程"><a href="/2020/07/06/剑指offer/1_面试的流程/" title="面试的流程">面试的流程</a></h3><p>面试环节以及注意问题</p><h3 id="面试需要的基础知识"><a href="/2020/07/06/剑指offer/2_面试需要的基础知识/" title="面试需要的基础知识">面试需要的基础知识</a></h3><p>从编程语言、数据结构、算法三个方面总结程序员的面试知识点。</p><h3 id="高质量的代码"><a href="/2020/07/06/剑指offer/3_高质量的代码/" title="高质量的代码">高质量的代码</a></h3><p>讨论影响代码质量的3个要素（规范性、完整性、鲁棒性），强调高质量代码除完成基本功能外，还能考虑特殊情况，并对非法输入进行合理处理。</p><h3 id="解决面试题的思路"><a href="/2020/07/06/剑指offer/4_解决面试题的思路/" title="解决面试题的思路">解决面试题的思路</a></h3><p>总结编程面试中解决难题的有效思考模式，如在面试中遇到复杂难题，可以利用画图、举例和分解将其化繁为简，先形成清晰思路再动手编程。</p><h3 id="优化时间和空间效率"><a href="/2020/07/06/剑指offer/5_优化时间和空间效率/" title="优化时间和空间效率">优化时间和空间效率</a></h3><p>介绍优化时间效率和用空间换时间的常用算法。</p><h3 id="面试中的各项能力"><a href="/2020/07/06/剑指offer/6_面试中的各项能力/" title="面试中的各项能力">面试中的各项能力</a></h3><p>总结应聘者如何充分表现学习和沟通能力，并通过具体面试题讨论如何培养知识迁移、抽象建模和发散思维能力。</p><h3 id="两个面试案例"><a href="/2020/07/06/剑指offer/7_两个面试案例/" title="两个面试案例">两个面试案例</a></h3><p>分析总结哪些面试举动是不良行为，而哪些表现又是面试官所期待的行为。</p><h3 id="英文版新增面试题"><a href="/2020/07/06/剑指offer/8_英文版新增面试题/" title="英文版新增面试题">英文版新增面试题</a></h3><p>优选久经欧美知名企业面试考验的经典题目，帮助国内读者开阔视野、增补技能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 书籍阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2020/07/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/07/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS</title>
      <link href="/2020/07/06/OS/"/>
      <url>/2020/07/06/OS/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blog 产生记</title>
      <link href="/2020/07/05/blog/"/>
      <url>/2020/07/05/blog/</url>
      
        <content type="html"><![CDATA[<h3 id="部署">部署</h3><p>hexo<br>next</p><h3 id="plugin">plugin</h3><ul><li>hexo-generator-search</li><li>hexo-renderer-markdown-it</li></ul><h3 id="问题">问题</h3><p><a href="https://convivae.top/posts/hexo-bo-ke-cai-keng/" target="_blank" rel="noopener">hexo toc 锚点失效</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/07/05/Clousim/"/>
      <url>/2020/07/05/Clousim/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.trojx.me/2019/12/30/cloudsim-plus-faq/" target="_blank" rel="noopener">云计算仿真工具CloudSim Plus常见问题总结</a><br><a href="https://veviz.github.io/2016/05/17/CloudSim/" target="_blank" rel="noopener">CloudSim Introduction</a><br><a href="https://blog.csdn.net/wjh1313677/article/details/45625999" target="_blank" rel="noopener">CloudSim源码分析-DatacenterBroker创建</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java 语言学习</title>
      <link href="/2020/06/30/Java/"/>
      <url>/2020/06/30/Java/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程">多线程</h1><h2 id="线程创建方法">线程创建方法</h2><blockquote><p>1.继承Thread类，重写run()线程执行程序，创建线程<br>2.实现Runnable接口，重写run()方法，作为参数构造thread，创建线程<br>3.使用Callable和Future创建线程<br>4.使用线程池例如用Executor框架</p></blockquote><blockquote><p>实现Runnable接口比继承Thread类所具有的优势：<br><a href="https://blog.csdn.net/absolute_chen/article/details/91890221" target="_blank" rel="noopener">https://blog.csdn.net/absolute_chen/article/details/91890221</a><br>1)适合多个相同的程序代码的线程去处理同一个资源;可以资源共享<br>2)可以避免java中的单继承的限制；可以继承多个接口<br>3)增加程序的健壮性，代码可以被多个线程共享，代码和数据独立<br>4)线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类</p></blockquote><h2 id="多线程">多线程</h2><blockquote><p>线程开始<br>线程停止：正常执行完run；interrupt使得线程异常，执行完run<br>其他：</p><blockquote><p>设置线程优先级（特性：继承性（线程A启动线程B，B继承A的优先级）；随机性（线程的调度顺序不一定根据优先级，具有随机性））<br>yield方法，释放CPU资源，通常它会让当前运行线程回到可运行性状态，使得有相同优先级的线程有机会执行。<br>sleep方法，使当前线程睡眠至少时间<br>join()方法：保证当前线程停止执行，直到该线程所加入的线程完成为止。然而，如果它加入的线程没有存活，则当前线程不需要停止（基于wait方法和notify方法）</p></blockquote></blockquote><h1 id="gc">GC</h1><h2 id="背景">背景</h2><blockquote><p>内存空间是有限的，如果高效利用有限的空间，可以通过释放不适用的对象所占用的内存（Java虚拟机所管理的内存区域分为如下部分：方法区、堆内存、虚拟机栈、本地方法栈、程序计数器）</p></blockquote><h2 id="gc对象">GC对象</h2><blockquote><p>程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理；内存垃圾回收主要集中于 java 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的</p></blockquote><h3 id="判定方法">判定方法</h3><blockquote><p>如何判断对象不再存活：引用计数（每个对象有一个引用计数属性，计数为0时可以回收，但无法解决对象相互循环引用的问题）和可达分析（通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连，则证明此对象是不可用的）</p></blockquote><h3 id="触发gc的条件">触发GC的条件</h3><blockquote><p>1.程序主动调用System.gc<br>2.内存不足被动触发</p></blockquote><h2 id="gc-roots">GC ROOTS</h2><blockquote><p>虚拟机栈、方法区和本地方法栈；方法区中类静态属性引用的对象；常量<br>1.系统类加载器锁加载的类<br>2.阻塞线程以及运行线程涉及的对象；本地方法栈涉及的对象<br>3.全局对象，上锁对象<br>4.针对younggc来说，gcroot的对象包括所有年老带对象</p></blockquote><h2 id="gc常用算法">GC常用算法</h2><blockquote><p>1.标记-清除算法：标记对象的存活或者死亡;清除对象会导致大量碎片<br>2.标记-压缩算法：在上种算法的基础上，将存活的对象整理到一起；如果存活对象过多会导致，复制次数过多，效率下降<br>3.复制算法：内存分为两部分，只使用其中一部分，这部分内存用完后，将其中存活的对象移动至另一部分，其他删除；没有碎片，但内存利用率低<br>4.分代收集算法（JVM Hotspot在使用）：根据对象的生存周期，将堆分为新生代(Young)和老年代(Tenure)。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。</p></blockquote><h3 id="cms">CMS</h3><blockquote><p>基于标记-清除算法<br>堆被划分为新生代和老年代，新生代又被进一步划分为Eden和Survivor区，而Survivor由FromSpace和ToSpace组成。<br><br>新生代：新创建的对象都是用新生代分配内存，Eden空间不足时，触发Minor GC，这时会把存活的对象转移进Survivor区。<br><br>老年代：老年代用于存放经过多次Minor GC之后依然存活的对象，老年代内存不足时触发，Major GC</p></blockquote><h3 id="cms-vs-g1"><a href="https://www.cnblogs.com/heyonggang/p/11718170.html" target="_blank" rel="noopener">CMS VS G1</a></h3><blockquote><p>CMS：Concurrent Mark Sweep，基于标记-清楚算法，作用于老年代，以并发获取最短回收停顿时间为目标的</p><blockquote><p>初始标记（标记root直接关联的对象）、并发标记（root  trace）、重新标记（并发标记中涉及的对象）、并发清除（CMS concurrent sweep）<br>优点：并发收集、低停顿<br>缺点：</p><blockquote><p>CMS收集器对CPU资源非常敏感，频繁GC，CPU资源不足。<br>CMS收集器无法处理浮动垃圾（Floating Garbage），并发清除阶段，运行产生的垃圾无法在本次回收。<br>CMS收集器是基于标记-清除算法，导致碎片。<br>安全点：程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停，安全点的初始目的是找到一个稳定的执行状态。在这个执行状态下，Java虚拟机的堆栈不会发生变化；长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等<br></p></blockquote></blockquote></blockquote><blockquote><p>G1：Garbadge First Collector；基于标记-整理算法；G1重新定义了堆空间，将堆划分为一个个区域；来进行垃圾回收，不必在全堆范围内收集，可以预测停顿时间</p><blockquote><p>与CMS的步骤类似，只是第4步时，他根据region排序价值和预测时间去清除，最后然后拷贝存活对象至新的region<br>卡表：？？？与老年代引用年轻代<br>相对于CMS优势：可预测的停顿模型；避免了CMS的垃圾碎片；超大堆的表现更出色</p></blockquote></blockquote><h1 id="设计模式">设计模式</h1><h2 id="单例模式">单例模式</h2><blockquote><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象</p></blockquote><blockquote><blockquote><ol><li>懒汉模式：实例在使用到的时候才创建,当多线程并发调用 getInstance(),如果方法不加synchronize 关键字修饰,会导致线程不安全</li></ol></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class LHan &#123;</span><br><span class="line">    private static LHan instance;</span><br><span class="line">    private LHan()&#123;&#125;</span><br><span class="line">    public static LHan getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            instance = new LHan();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><ol start="2"><li>饿汉模式,实例在最初已经初始化,getInstance()方法线程安全，但浪费内存空间</li></ol></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class EHan &#123;</span><br><span class="line">    private static EHan instance = new EHan();</span><br><span class="line">    private EHan()&#123;&#125;</span><br><span class="line">    public static EHan getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><ol start="3"><li>双检锁,双重校验锁,在synchronize 关键字内外都加上一层if判断,即避免内存浪费,又保证了线程安全,同时 比直接上锁提高了执行效率</li></ol></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class DoubleCheck &#123;</span><br><span class="line">    private static DoubleCheck instance;</span><br><span class="line">    private DoubleCheck()&#123;&#125;</span><br><span class="line">    public static DoubleCheck getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            synchronize(DoubleCheck.class)&#123;</span><br><span class="line">                if(instance == null)&#123;</span><br><span class="line">                    instance = new DoubleCheck();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><ol start="4"><li>静态内部类(内部类是外部类的一个成员,分为静态内部类和非静态内部类：静态内部类可以直接调用外部类的静态成员(静态成员变量和静态方法)，但是不能直接调用外部类的非静态成员；而非静态内部类可以直接调用外部类的其他成员)</li></ol></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class SingleTon &#123;</span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static final SingleTon INSTANCE = new SingleTon();</span><br><span class="line">    &#125;</span><br><span class="line">    private SingleTon()&#123;&#125;</span><br><span class="line">    public static final SingleTon getInstance()&#123;</span><br><span class="line">        return SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><ol start="5"><li>枚举</li></ol></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum SingleTonn &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public void AnyMethod()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据库">数据库</h1><h2 id="reids">Reids</h2><h3 id="基础数据类型">基础数据类型：</h3><blockquote><p>string，hash，list，set及有序集合（每个元素都关联一个分数，通过分数排序）</p></blockquote><h3 id="redis持久化">Redis持久化：</h3><blockquote><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失<br>两种持久化方式:RDB（Redis DataBase；默认；定期备份；把内存中数据写到磁盘以及把文件读到内存；制定的时间间隔生成数据集的快） 和AOF(Append-only file;写入保存两个步骤；WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件 ；SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。持久化记录服务器执行的所有写命令到日志文件，并在服务器重启时，重新执行这些命令来恢复数据)</p><blockquote><p>两种区别就是，一个是持续的用日志记录写操作，crash后利用日志恢复；一个是平时写操作的时候不触发写，只有手动提交save命令，或者是关闭命令时，才触发备份操作。<br>选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。</p></blockquote></blockquote><h3 id="过期策略定期删除惰性删除内存淘汰机制">过期策略：定期删除+惰性删除+内存淘汰机制</h3><blockquote><p>定期删除：redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除</p></blockquote><blockquote><p>惰性删除：当访问key时，检测key是否过期，过期则不返回</p></blockquote><blockquote><p>内存淘汰机制：当内存不足以写入新数据时，什么都不做，写入报错/移除随机key/移除最近最少使用的key/随机（或者选择最先过期 ）移除有过期时间的key/移除有过期的key中最近最少使用的/</p></blockquote><h3 id="redis的架构模式">Redis的架构模式</h3><blockquote><p>单机版（存储，处理有限，无法高可用）</p></blockquote><blockquote><p>主从复制（读写分离；更新同步；但是master写的压力存在，高可用不行）</p></blockquote><blockquote><p>哨兵（监控主从模式，遇到故障自动迁移；解决高可用，但master写仍存在）</p></blockquote><blockquote><p>集群（proxy 型）：利用哈希进行数据分布，分布到多个主从集群+哨兵</p></blockquote><blockquote><p>集群（直连型）：</p><blockquote><p>集群（直连型）:<a href="https://blog.csdn.net/z15732621582/article/details/79121213" target="_blank" rel="noopener">简介</a>  和 <a href="https://www.cnblogs.com/lpfuture/p/5796398.html" target="_blank" rel="noopener">一致性Hash算法</a><br>Redis集群预分好16384个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中<br>节点的fail是通过集群中超过半数的节点检测失效时才生效</p></blockquote></blockquote><h3 id="相关概念">相关概念</h3><h4 id="缓存雪崩">缓存雪崩</h4><blockquote><p>描述：大量相同过期时间的缓存，同时失效，导致大量的并发访问失败并访问磁盘；<br>解决：使用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写</p></blockquote><h4 id="缓存穿透">缓存穿透</h4><blockquote><p>描述：用户在查询一个持久层数据库也没有的数据时，会出现缓存未命中，且访问持久层无果的情况，大量这种类型的访问会给持久层数据库带来很大压力<br>解决：利用布隆过滤器判断对象是否一定不存在；缓存空对象</p></blockquote><h4 id="缓存击穿">缓存击穿</h4><blockquote><p>描述；指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞</p></blockquote><h4 id="缓存预热">缓存预热</h4><blockquote><p>描述：相关的缓存数据直接加载到缓存系</p></blockquote><h4 id="缓存更新">缓存更新</h4><blockquote><p>除了缓存失效策略（定义失效时间）外，还有定时去清理过期的缓存策略（判断是否失效）以及访问时才判断是否失效</p></blockquote><h4 id="缓存降级">缓存降级</h4><blockquote><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级，保证核心服务可用</p></blockquote><h4 id="热点数据和冷数据">热点数据和冷数据：</h4><blockquote><p>频繁访问修改的数据称之为热点数据；冷数据指访问间隔很长的数据（出现只访问一次，就被挤出内存的情况）</p></blockquote><h4 id="单线程的redis为什么这么快">单线程的redis为什么这么快</h4><blockquote><p>(1)纯内存操作<br>(2)单线程操作，避免了频繁的上下文切换<br>(3)采用了非阻塞I/O多路复用机制</p></blockquote><h4 id="memcache-vs-redis">Memcache VS Redis</h4><blockquote><p>(1)存储方式 ：Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，redis可以持久化其数据<br><br>(2)数据支持类型 memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 ，提供list，set，zset，hash等数据结构的存储<br><br>(3)使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。<br><br>(4)value 值大小不同：Redis 最大可以达到 512M；memcache 只有 1mb。<br><br>(5)redis的速度比memcached快很多<br><br>(6)Redis支持数据的备份，即master-slave模式的数据备份。<br><br>Redis key和value的大小限制：512MB</p></blockquote><h4 id="redis数据库的数据一致性">Redis数据库的数据一致性</h4><blockquote><p>主从同步：从服务器启动，会向主服务器发起sync命令；主服务器收到后会在后台保存快照（RDB操作），并缓存保存期间的命令；结束后，会将快照和缓存命令传递给从数据库，从数据库接收到后，会载入快照并执行缓存命令；</p><p>哈希槽算法：与一致性哈希算法相似，一个节点根据其存储量，分为若干个槽</p><p>全量复制，增量复制，异步复制</p></blockquote><h4 id="哨兵模式"><a href="https://blog.csdn.net/sz85850597/article/details/86751215" target="_blank" rel="noopener">哨兵模式</a></h4><blockquote><p>主观下线-&gt;客观下线<br>sential leader 选举：当每一个发现redis master 的sential节点都可以向其他节点发送选举信号，每个接收到该信号的节点如果没有投票，可以投它，当达到最低票数时，正式成为sential leader；否则进行下一轮；<br>redis master 选举：由 sential leader 选择redis集群中的某个节点作为master</p><blockquote><p>a.排除故障节点</p></blockquote><blockquote><p>b.选择节点中slave-priority最大的从节点作为主节点</p></blockquote><blockquote><p>c.选择择复制偏移量（数据写入量的字节，记录写了多少数据。主服务器会把偏移量同步给从服务器，当主从的偏移量一致，则数据是完全同步）最大的从节点作为主节点</p></blockquote><blockquote><p>d.选择runid（redis每次启动的时候生成随机的runid作为redis的标识）最小的从节点作为主节点</p></blockquote></blockquote><h4 id="redis-集群选举">redis <a href="https://www.cnblogs.com/nijunyang/p/12508098.html" target="_blank" rel="noopener">集群选举</a></h4><blockquote><p>背景：利用hash桶算法进行数据的分隔布置到多个主从模式服务器去<br>选举：slave发现master Fail之后，就尝试选举</p><blockquote><p>a.增加currentEpoch加1，并广播FAILOVER_AUTH_REQUEST信息</p></blockquote><blockquote><p>b.收到信息的Master节点会判断请求者的合法性，并发&gt;送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack</p></blockquote><blockquote><p>c.尝试failover的slave收集FAILOVER_AUTH_ACK;超过半数后变成新Master;广播Pong通知其他集群节点</p></blockquote></blockquote><h2 id="mysql">Mysql</h2><h3 id="事务的基本要素">事务的基本要素</h3><blockquote><p>原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。<br><br>一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏。<br><br>隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。<br><br>持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚</p></blockquote><h3 id="事务的并发问题">事务的并发问题</h3><blockquote><p>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据<br><br>不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。<br><br>幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读.<br><br>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表<br></p></blockquote><h3 id="事物隔离级别">事物隔离级别</h3><table><thead><tr><th style="text-align:left">事务隔离级别</th><th style="text-align:right">脏读</th><th style="text-align:right">不可重复</th><th style="text-align:right">幻读</th></tr></thead><tbody><tr><td style="text-align:left">读未提交（read-uncommitted）</td><td style="text-align:right">是</td><td style="text-align:right">是</td><td style="text-align:right">是</td></tr><tr><td style="text-align:left">读未提交（read-uncommitted）</td><td style="text-align:right">否</td><td style="text-align:right">是</td><td style="text-align:right">是</td></tr><tr><td style="text-align:left">可重复读（默认，repeatable-read）</td><td style="text-align:right">否</td><td style="text-align:right">否</td><td style="text-align:right">是</td></tr><tr><td style="text-align:left">串行化（serializable）</td><td style="text-align:right">否</td><td style="text-align:right">否</td><td style="text-align:right">否</td></tr></tbody></table><h3 id="存储引擎">存储引擎</h3><blockquote><p>存储引擎是数据库管理系统用来从数据库创建、读取和更新数据的软件模块<br>mysql5.5之后默认使用事务性存储引擎 InnoDB(这是MySQL 5.5或更高版本的默认存储引擎。它提供了事务安全(ACID兼容)表，支持外键引用完整性约束。它支持提交、回滚和紧急恢复功能来保护数据。它还支持行级锁定。当在多用户环境中使用时，它的“一致非锁定读取”提高了性能。它将数据存储在集群索引中，从而减少了基于主键的查询的I/O)</p></blockquote><h4 id="innodb">InnoDB</h4><blockquote><p>在 InnoDB 存储引擎中，所有的数据都被逻辑地存放在表空间中，表空间（tablespace）是存储引擎中最高的存储逻辑单位，在表空间的下面又包括段（segment）、区（extent）、页（page）<br><br>MySQL 使用 InnoDB 存储表时，会将表的定义和数据索引等信息分开存储，其中前者存储在 .frm文件中，后者存储在 .ibd 文件中<br></p></blockquote><h3 id="索引">索引</h3><blockquote><p>索引优化是对查询性能优化的最有效手段<br>InnoDB 存储引擎在绝大多数情况下使用 B+ 树建立索引，这是关系型数据库中查找最为常用和有效的索引</p></blockquote><blockquote><p>一张表一定包含一个聚集索引构成的 B+ 树以及若干辅助索引的构成的 B+ 树（辅助索引的存在并不会影响聚集索引，因为聚集索引构成的 B+ 树是数据实际存储的形式，而辅助索引只用于加速数据的查找，所以一张表上往往有多个辅助索引以此来提升数据库的性能。）</p></blockquote><h4 id="聚集索引-和-辅助索引">聚集索引  和  辅助索引</h4><blockquote><p>聚合索引可以理解为基于主键的索引，是实际存储的位置；而附注索引是对于其他键的索引，最终叶子节点内容为指向基于主键的索引；<br><br>主键(指定主键或者选择费控的合适键或者隐藏键uuid)</p></blockquote><h3 id="数据库主从同步">数据库主从同步</h3><blockquote><p><a href="https://www.cnblogs.com/syncnavigator/p/10189597.html" target="_blank" rel="noopener">流程参考</a><br>首先必须打开master端的binlog (mysql-bin.xxxxxx)日志功能，否则无法实现mysql的主从复制。因为mysql的整个主从复制过程实际上就是：slave端从 master端获取binlog日志，然后再在自己身上完全顺序的执行该日志中所记录的各种SQL操作</p><blockquote><p>1.master在执行sql之后，记录二进制log文件（bin-log）。<br>2.slave连接master，并从master获取binlog，存于本地relay-log中，然后从上次记住的位置起执行SQL语句，一旦遇到错误则停止同步。</p></blockquote></blockquote><h3 id="mvcc">MVCC</h3><blockquote><p>待完善<br><a href="https://blog.csdn.net/weixin_41835916/article/details/81633072?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3" target="_blank" rel="noopener">参考博客1</a></p></blockquote><h3 id="最左匹配原则">最左匹配原则</h3><blockquote><p>索引的简历是从左开始的</p></blockquote><h3 id="myisam与innodb">MyISAM与InnoDB</h3><blockquote><p>1.对事务的的支持<br>2.对外键的支持<br>3.InnoDB是聚集索引（主索引存储数据文件，辅助索引指向主键），MyISAM 是非聚集索引（主键索引和辅助索引都指向文件指针）<br>4.InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁<br>5.InnoDB表必须有主键（用户没有指定的话会自己找或生产一个主键），而Myisam可以没有</p></blockquote><h3 id="postgresql-vs-mysql">PostgreSQL  VS MySQL</h3><blockquote><p>待完善</p></blockquote><h3 id="主键索引和唯一索引区别">主键索引和唯一索引区别</h3><blockquote><p>待完善</p></blockquote><h1 id="其他常见问题">其他常见问题</h1><h2 id="hashmap-hashtable-concurrenthashmap">HashMap HashTable ConcurrentHashMap</h2><blockquote><p>都是 数组+单链表 实现<br><a href="https://blog.csdn.net/mbshqqb/article/details/79799009" target="_blank" rel="noopener">参考1</a><br>HashMap基于hashing原理，我们通过put()和get()法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用LinkedList来解决碰撞问题，当发生碰撞了，对象将会储存在LinkedList的下一个节点中。 HashMap在每个LinkedList节点中储存键值对对象。<br>　　当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的LinkedList（链表只让挂7个元素，超过七个就会转成一个红黑树进行处理，当红黑树下挂的节点小于等于6的时候，系统会把红黑树转成链表）中。键对象的equals()方法用来找到键值对<br>String, Interger这样的类，作为HashMap的键是再适合不过了，因为String对象是不可变的，计算hashCode()，就要防止键值改变</p></blockquote><blockquote><p>HashTable：无论key还是value都不能为null，线程安全，实现线程安全的方式是在修改数据时锁住整个HashTable；<br>HashMap：无论key还是value都能为null，线程不安全（在多个线程并发扩容时，会在执行transfer()方法转移键值对时，造成链表成环，导致程序在执行get操作时形成死循环 <a href="https://www.cnblogs.com/lonelyJay/p/9726187.html" target="_blank" rel="noopener">参考1</a> <a href="https://www.sohu.com/a/341902281_100123073" target="_blank" rel="noopener">参考2</a> ;单链表复制是是插入排序，因为时刻知道链表头在哪）</p></blockquote><blockquote><p>但是 HashMap线程不安全，而HashTable安全但是效率低，出现了ConcurrentHashMap使用分段锁<br>抛开 HashMap，hash 冲突有那些解决办法？开放定址法、链地址法、再哈希法<br><a href="https://www.cnblogs.com/cosmos-wong/p/11845934.html" target="_blank" rel="noopener">java stack不推荐使用</a>,建议使用dequeue代替</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读</title>
      <link href="/2020/06/14/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
      <url>/2020/06/14/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h4 id="大多是data-center-资源集中">大多是Data Center ,资源集中</h4><h4 id="cooperative-game-based-virtual-machine-resource-allocation-algorithms-in-cloud-data-centershindawi">Cooperative Game-Based Virtual Machine Resource Allocation Algorithms in Cloud Data Centers(hindawi)</h4><ol><li>Cloud Data Center(CDC)资源利用率低</li><li>思路：对不同资源使用不同的基于 value 的博弈论解决方法;<ul><li>CPU: Shaply value(SV), payoff by number contribution</li><li>memory: weighted Shaply value(WSV),payoff by coliation ;and  members’s payoff about positive effort of coliation</li><li>storage: proportional Shaply value(PSV)</li><li>bandwith: weigthed-egalitarian Shaply value(WESV) payoff by member contribution and  heterogeneity between members</li></ul></li><li>不足：<ul><li>task 生成分为四类,每类的资源要求固定(task 不具有 变动性)</li><li>数据未公开</li><li>未解释 四类资源某些不足时的处理???</li></ul></li></ol><h4 id="game-theoretic-resource-allocation-in-cloud-computing">Game theoretic resource allocation in cloud computing</h4><ol><li>介绍：同名书中的相干章节，基于Min-Max Game<ul><li>输入：request的信息，resource的信息</li><li>输出：分配矩阵</li></ul></li><li>思路：实现最大化资源的 utility(效用) 的目标；</li><li>utility 的公式构成(又分为单类资源utility和全局资源utility) ?? 不同资源,CPU<ul><li>budget</li><li>cost per sencod</li><li>request 量</li><li>request time 消耗时间</li><li>budget和time的factor因子</li></ul></li><li>算法：<ul><li>挑选出可以进行博弈的request</li><li>依次对每一种资源选择全局最大化utility时的分配，iteration</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> cloud-computing resource allocation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设实验</title>
      <link href="/2020/06/11/%E6%AF%95%E8%AE%BE/"/>
      <url>/2020/06/11/%E6%AF%95%E8%AE%BE/</url>
      
        <content type="html"><![CDATA[<p>##实验分类：</p><ol><li>小规模 系统搭建(请求链条不需要长)</li><li>大规模仿真模拟(可以模拟长请求链和大规模，大流量)</li></ol><p>###小规模系统构成：</p><ol><li>请求发送者(微服务的benchmark 附带流量)</li><li>微服务benchmark/请求处理<ul><li>服务链确定</li><li>流量监控(istio)</li></ul></li><li>决策中心(初次放置,调整): 博弈论均衡<ul><li>思路：<ul><li>分类</li><li>加权 集中</li></ul></li><li>放置：资源充足时, 参数 服务链(整体时延) &gt; 资源使用集中程度(避免资源过度集中于某些machine,也避免过度分散)</li><li>缩容：谨慎，按照kubeneats自带策略/长期监控流量,然后决策调整</li><li>扩容：存在多服务链扩容,博弈论<ul><li>资源不冲突，分配</li><li>资源冲突，考虑优先级, 其他参数 资源利用率,资源集中程度<br>###大规模仿真模拟</li></ul></li></ul></li><li>工具：CloudSim(docker)</li><li>微服务的指标细化(QOS,基本资源需求,基本处理能力)</li><li>流量构造(常规多样流量；突发大规模流量)</li></ol><p>###目标：</p><ol><li>满足已存在的QOS 要求(根据流量调整实例的部署，扩缩容)</li><li>资源利用率</li><li>性能表现(latency,稳定性)</li></ol><p>###问题：</p><ol><li>利用博弈论简化问题，<ul><li>只考虑了部署实例的问题，没有考虑具体资源的供给(如何量化的问题),</li><li>暂时没有考虑后续的伸缩</li><li>未考虑 资源不集中</li></ul></li><li>平衡不是目标，平衡是为了降低干扰，我的目标是提高QOS，稳定性，提高资源利用率，降低资源占有率</li><li>长请求链的实际存在依据(实际运行中的每个环节都是请求链的一环)：更多例子</li><li>微服务benchmark的自带流量测试比较简单/不够复杂和波动，需要重新构造设计</li></ol><p>已完成：</p><ol><li>benchmark:<br>1.1 已部署 <a href="https://github.com/microservices-demo/microservices-demo" target="_blank" rel="noopener">Sock-Shop</a> <a href="https://github.com/GoogleCloudPlatform/microservices-demo" target="_blank" rel="noopener">Hipster</a> <a href="https://github.com/FudanSELab/train-ticket/wiki" target="_blank" rel="noopener">Train-Ticket</a> <a href="https://github.com/delimitrou/DeathStarBench" target="_blank" rel="noopener">DeahStarBench</a></li></ol><p>1.2 待部署 <a href="https://github.com/dream-lab/riot-bench" target="_blank" rel="noopener">Riot</a></p><ol start="2"><li>决策中心<br>2.1 熟悉了解 <a href="https://www.coursera.org/learn/game-theory-1/" target="_blank" rel="noopener">博弈论理论</a><br>2.2 算法实现，需要想清楚问题</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Kuberneats </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码阅读</title>
      <link href="/2020/04/14/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2020/04/14/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>docker</p><ul><li><a href="https://mp.weixin.qq.com/s/zyDGaT6SGFUVU60r9L7S3Q?" target="_blank" rel="noopener">参考博客1</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>云计算模拟</title>
      <link href="/2020/03/31/%E4%BA%91%E8%AE%A1%E7%AE%97%E6%A8%A1%E6%8B%9F/"/>
      <url>/2020/03/31/%E4%BA%91%E8%AE%A1%E7%AE%97%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<p>毕业设计需要对于大型云计算环境进行模拟，经过调研，决定使用<a href="http://www.cloudbus.org/cloudsim/" target="_blank" rel="noopener">CloudSim</a> <a href="https://github.com/Cloudslab/cloudsim" target="_blank" rel="noopener">Github</a></p><p>CloudSim是在离散事件模拟包SimJava上开发的函数库,可以直接当做Java工程使用，即导入IDEA<br><a href="https://www.cnblogs.com/sddai/p/6036893.html" target="_blank" rel="noopener">国内比较全的关于CloudSim的介绍</a><br><a href="https://www.cnblogs.com/xxfna/articles/9563068.html" target="_blank" rel="noopener">如何将CloudSim导入IDEA</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CloudSim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux</title>
      <link href="/2020/01/13/linux/"/>
      <url>/2020/01/13/linux/</url>
      
        <content type="html"><![CDATA[<p>本问用于记录linux常用的命令</p><p>ssh</p><p>scp</p><blockquote><p>在两个服务器之间传输文件<br>rz<br>传输本地文件到服务器<br>sz [filename]<br>传输服务器文件到本地</p></blockquote><p>find [PATH] [option]</p><blockquote><p>在指定目录下查找相关文件<br>example : find . -name “name”</p></blockquote><p>tail [file] [option]</p><blockquote><p>从后开始查询文件，默认查询最后十行<br>tail -n 100 nohup.log</p></blockquote><p>cat/touch<br>netstat<br>telnet<br>chown/chmod/chgrp<br>useradd</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux command </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell</title>
      <link href="/2020/01/12/shell/"/>
      <url>/2020/01/12/shell/</url>
      
        <content type="html"><![CDATA[<p>shell 是UNIX系统的用户与操作系统之间的一种接口;</p><p><a href="https://blog.csdn.net/Jiaach/article/details/83788984" target="_blank" rel="noopener">注意事项</a><br>在 单引号 以及 反单引号 里使用 ${AVAILABLE}引用变量</p><p>PATH 变量 谨慎使用</p>]]></content>
      
      
      
        <tags>
            
            <tag> shell script </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>frp</title>
      <link href="/2020/01/12/frp/"/>
      <url>/2020/01/12/frp/</url>
      
        <content type="html"><![CDATA[<p>云服务器　<a href="https://promotion.aliyun.com/ntms/act/campus2018.html" target="_blank" rel="noopener">阿里云ECS</a><br>关于端口限制(connect timeout) <a href="https://blog.csdn.net/cao0507/article/details/82758288" target="_blank" rel="noopener">https://blog.csdn.net/cao0507/article/details/82758288</a></p><p>crontab</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">PROCESS_NUM=`ps -ef | grep &quot;frpc -c &quot; | grep -v &quot;grep&quot; | wc -l`</span><br><span class="line">FRP_PATH=&apos;/home/sun/fpr/frp_0.31.1_linux_amd64&apos;</span><br><span class="line">if [ $PROCESS_NUM -lt 1 ];</span><br><span class="line">then</span><br><span class="line">    `nohup $&#123;FRP_PATH&#125;/frpc -c $&#123;FRP_PATH&#125;/frpc.ini &gt; $&#123;FRP_PATH&#125;/nohup.out 2&gt;&amp;1 &amp;`</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/womenrendeme/article/details/89053746" target="_blank" rel="noopener">多客户端</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> frp shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2020/01/09/docker/"/>
      <url>/2020/01/09/docker/</url>
      
        <content type="html"><![CDATA[<p>##Install<br><a href="https://docs.docker.com/install/linux/linux-postinstall/" target="_blank" rel="noopener">官方教程</a></p><p>##Usage<br>docker</p><blockquote><p>docker ps -a<br>docker images<br>dokcer stop/restart/rm CONTAINER_ID<br>docker rmi IAMGE_ID<br>docker logs CONTAINER_ID --tail NUMBER<br>docker inspect</p></blockquote><p>dokcer java 应用启动慢　尝试解决</p><blockquote><p>1.非阻塞熵池策略 优化　<a href="http://hongjiang.info/tomcat-startup-slowly-in-docker/" target="_blank" rel="noopener">Docker中apache-tomcat启动慢的问题</a>　<a href="https://www.cnblogs.com/a1304908180/p/10745284.html" target="_blank" rel="noopener">为什么阿里云服务器的docker启动tomcat这么慢？</a> -Djava.security.egd=file:/dev/urandom　－＞　-Djava.security.egd=file:/dev/./urandom<br>2.JVM 容量优化，即增加参数值 -Xms256m -Xmx512m -XX:PermSize=64m -XX:MaxPermSize=128m</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> docker install use </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernets</title>
      <link href="/2020/01/09/kubernets/"/>
      <url>/2020/01/09/kubernets/</url>
      
        <content type="html"><![CDATA[<h2 id="install">Install</h2><p>我安装的是 minikube <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl-on-linux" target="_blank" rel="noopener">K8S官方教程</a><br>注意点:</p><ul><li><p>网络问题：</p><ul><li><a href="https://coding.imooc.com/learn/questiondetail/81560.html" target="_blank" rel="noopener">更改镜像源</a></li><li>更改 k8s image 源<blockquote><p>kubeadm init --image-repository <a href="http://registry.aliyuncs.com/google_containers" target="_blank" rel="noopener">registry.aliyuncs.com/google_containers</a><br>kubeadm init --image-repository <a href="http://index.docker.io/mirrorgooglecontainers" target="_blank" rel="noopener">index.docker.io/mirrorgooglecontainers</a></p></blockquote></li></ul></li><li><p>启动选项:</p><ul><li>选择 vm drive(in local linux environment use local docker)</li></ul><blockquote><p>minikube start --vm-driver=none</p></blockquote><ul><li>更改 kubeadm 配置</li></ul><blockquote><p>导出　kubeadm 原本配置　old.yaml，然后更改为 new.yaml<br>kubeadm config migrate --old-config old.yaml --new-config new.yaml</p></blockquote></li><li><p>最终:</p></li></ul><blockquote><p>minikube start --vm-driver=none --image-repository=<a href="http://registry.aliyuncs.com/google_containers" target="_blank" rel="noopener">registry.aliyuncs.com/google_containers</a></p></blockquote><h2 id="kubernetsminikube-相关操作">Kubernets/minikube 相关操作</h2><p><a href="http://docs.kubernetes.org.cn/664.html" target="_blank" rel="noopener">k8s中文文档</a><br>minikube</p><blockquote><p>minikube stop/delete</p></blockquote><p>port</p><blockquote><p>containerPort,targetPort,nodePort,port 之间的区别<br>在deployment 文件中　containerPort相当于映射到容器外的端口 == docker run IMAGE_ID -P OUTSIDE_PORT:INSIDE_PORT<br>docker exec -it  --privileged   ab56f4a5d15c  /bin/sh  携带权限进入 docker，避免进入docker内需要某些权限的操作</p></blockquote><p>kubectl</p><blockquote><p>kubectl describe pod/orders-5dbffdd8ff-zqp2c --namespace=‘sock-shop’<br>kubectl get pods --namespace=‘sock-shop’<br>kubectl edit deploy/shipping  --namespace=‘sock-shop’</p></blockquote><h2 id="相关概念">相关概念</h2><ol><li>pod vs container</li><li>containerPort vs targetPort vs nodePort vs port</li><li>service</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> k8s install </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>microservice 部署</title>
      <link href="/2020/01/08/microservice/"/>
      <url>/2020/01/08/microservice/</url>
      
        <content type="html"><![CDATA[<h2 id="部署-microservice-benchmark">部署　microservice benchmark</h2><p><a href="https://github.com/microservices-demo/microservices-demo" target="_blank" rel="noopener">官方教程</a></p><h2 id="问题">问题</h2><ol><li><p>yml部署文件　unable to recognize</p><ul><li>错误：</li></ul><blockquote><p>unable to recognize “deploy/kubernetes/manifests-logging/elasticsearch.yml”: no matches for kind “Deployment” in version “extensions/v1beta1”, unable to recognize “deploy/kubernetes/manifests-logging/fluentd-daemon.yml”: no matches for kind “DaemonSet” in version “extensions/v1beta1”, unable to recognize “deploy/kubernetes/manifests-logging/kibana.yml”: no matches for kind “Deployment” in version “extensions/v1beta1”</p></blockquote><ul><li>解决　<a href="https://github.com/microservices-demo/microservices-demo/issues/802" target="_blank" rel="noopener">benchmark github issue</a></li></ul></li><li><p>部署pod无法正常运行</p><ul><li>部署错误，原本服务应当暴漏出的接口无法访问</li></ul><blockquote><p>发现是因为 一些pod在部署之后，发现频繁重启,就是因为这些暴露出的接口无法访问，它们是作为监测是否健康的接口存在，认为容器启动错误，因而POD重启container<br>NAME                            READY   STATUS        RESTARTS   AGE<br>carts-fc985d95-h78dn            0/1     Running       22         12h<br>经过各种排查，无法发现原因，最终一次偶然发现行得通了，尝试通过更改配置重现这次情况，最后发现，是因为容器启动太慢，导致监测的delay相对太小，因而监测失败<br>而重复监测失败，重复重启，又有多个pod(contianer)重启，导致CPU占有率高，从而启动速度可能更受影响</p></blockquote><ul><li>尝试排查错误<br>　       1. 观察日志无法发现错误<br>　       2. 经过观察，基本都是80端口的问题</li><li>尝试<br>　       1. 是否因为port范围限制?尝试在/etc/kubernets/manifests/api-servers.yaml中更改，无效<br>　       2. 尝试更改　pod 的yaml 中的port ，并重新apply,确定是否是端口限制的原因</li><li>解决方法：</li></ul><blockquote><p>本质是因为docker启动慢，而此时　pod 的检测已经开始了，从而判断docker未正常启动，从而重启docker,从而陷入循环，所以有两种方法<br>1.加快docker的启动速度，详见<a href="https://walkdeadtobe.github.io/2020/01/09/docker/" target="_blank" rel="noopener">dokcer java 应用启动慢</a><br>2.延后pod的检测，等docker正常启动，可以增加 initialDelaySeconds,failureThreshold,periodSeconds,successThreshold等参数的值</p></blockquote></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> microservice deployment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coding</title>
      <link href="/2019/12/30/%E9%87%8D%E6%9E%84/"/>
      <url>/2019/12/30/%E9%87%8D%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>最近在重构之前用java写的SSO的代码，有点感触<br>1.对自己写的屎一样的代码，尽量重构，起码让自己以后重新看时，还敢承认这是自己的代码<br>2.写代码时，要注意自己的最初目的，不要让函数超出了它本身应该做的事情<br>3.尽量不要涉及硬编码的部分，如果大量重复的硬编码，那么该思考是不是必要的，也许它应该是数据库的信息？</p>]]></content>
      
      
      
        <tags>
            
            <tag> reconstruct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deployment</title>
      <link href="/2019/12/22/%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/12/22/%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="1-nginx">1 nginx</h1></blockquote><blockquote><blockquote><h2 id="11-dockerfile">1.1 dockerfile</h2></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#Dockerfile</span><br><span class="line">FROM nginx:latest</span><br><span class="line">MAINTAINER chengr chengr@buaa.edu.cn</span><br><span class="line">#mkdir</span><br><span class="line">RUN mkdir -p /home/cast/web/kexie_BigScreen_vue/dist \</span><br><span class="line"> &amp;&amp; mkdir -p /home/cast/web/act-kexie-big \</span><br><span class="line"> &amp;&amp; mkdir -p /home/cast/web/vue_front_of_talent/vue-demo \</span><br><span class="line"> &amp;&amp; mkdir -p /home/cast/web/talent_zhejiang/vue-demo \</span><br><span class="line"> &amp;&amp; mkdir -p /home/cast/web/kexie_news/dist \</span><br><span class="line"> &amp;&amp; mkdir -p /home/cast/web/activeDay0904 \</span><br><span class="line"> &amp;&amp; mkdir -p /home/cast/web/kexie_Local_BigScreen_vue/dist \</span><br><span class="line"> &amp;&amp; mkdir -p /home/cast/web/kexie_Local_BigScreen_GuangXi/dist \</span><br><span class="line"> &amp;&amp; mkdir -p /home/cast/web/kexie_BigsScreen_city/dist</span><br><span class="line"></span><br><span class="line">#WORKDIR /home/LAB/bdbc.kg</span><br><span class="line">#copy file</span><br><span class="line">COPY nginx.conf /etc/nginx/</span><br><span class="line">COPY default /etc/nginx/conf.d/default.conf</span><br><span class="line">#COPY Frontend/talent/vue-demo /home/cast/web/vue_front_of_talent/vue-demo</span><br><span class="line">#COPY /home/LAB/bdbc.kg/Frontend/kexie/dist /home/cast/web/kexie_BigScreen_vue/dist</span><br><span class="line"></span><br><span class="line">EXPOSE 80 8003 8010 9010  8888 8889  8890  8891</span><br></pre></td></tr></table></figure><blockquote><blockquote><h2 id="12-build-images">1.2 build images</h2></blockquote></blockquote><p>docker build -t nginx_bh .</p><blockquote><blockquote><h2 id="13-create-container">1.3 create container</h2></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">--name beihang_nginx \</span><br><span class="line">-p 80:80 \</span><br><span class="line">-p 8010:8010 \</span><br><span class="line">-p 9010:9010 \</span><br><span class="line">-p 8888:8888 \</span><br><span class="line">-p 8889:8889 \</span><br><span class="line">-p 8890:8890 \</span><br><span class="line">-p 8891:8891 \</span><br><span class="line">-p 8003:8003 \</span><br><span class="line">-v /home/LAB/bdbc.kg/Frontend/talent/vue-demo:/home/cast/web/vue_front_of_talent/vue-demo \</span><br><span class="line">-v /home/LAB/bdbc.kg/Frontend/kexie_BigScreen_vue/dist:/home/cast/web/kexie_BigScreen_vue/dist \</span><br><span class="line">-v /home/LAB/bdbc.kg/Frontend/talent_zhejiang/vue-demo:/home/cast/web/talent_zhejiang/vue-demo \</span><br><span class="line">-d nginx_bh</span><br></pre></td></tr></table></figure><blockquote><p>其他需要注意或者修改的地方</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python ~/replace.py</span><br></pre></td></tr></table></figure><p>替换前端页面/nginx配置文件(网关地址,单点登录服务地址)</p><blockquote><p>增加新后端时，需要注意的地方</p></blockquote><ul><li>1.后端以及网关处关于验证的部分是否需要更改（待改进）<ul><li>1.1 后端管理授权部分代码</li><li>1.2 网关与SSO 交互部分</li></ul></li><li>2.是否可能因为时延部分，导致网关与后端验证失败</li></ul><blockquote><h1 id="2-kong">2 kong</h1></blockquote><blockquote><blockquote><h2 id="21-dockerfile">2.1 dockerfile</h2></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#Dockerfile</span><br><span class="line">FROM gecwf5gs.mirror.aliyuncs.com/library/kong:1.4</span><br><span class="line">WORKDIR /usr/src/app</span><br><span class="line">ADD my_kong_plugin my_kong_plugin</span><br><span class="line">WORKDIR /usr/src/app/my_kong_plugin</span><br><span class="line">RUN luarocks make &amp;&amp; luarocks pack kong-plugin-myplugin &amp;&amp; luarocks install kong-plugin-myplugin-0.1.0-1.all.rock &amp;&amp; cp ./conf/kong.conf /etc/kong/</span><br><span class="line">ENTRYPOINT [&quot;/docker-entrypoint.sh&quot;]</span><br><span class="line">EXPOSE 8000 8443 8001 8444</span><br><span class="line">STOPSIGNAL SIGQUIT</span><br><span class="line">CMD [&quot;kong&quot;, &quot;docker-start&quot;]</span><br></pre></td></tr></table></figure><blockquote><blockquote><h2 id="22-build-image">2.2 build image</h2></blockquote></blockquote><p>docker build -t  gateway .</p><blockquote><blockquote><h2 id="23-create-container">2.3 create container</h2></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name gateway \</span><br><span class="line">--network=kong-net \</span><br><span class="line">-e &quot;KONG_DATABASE=postgres&quot; \</span><br><span class="line">-e &quot;KONG_PG_</span><br><span class="line">hunHOST=kong-database&quot; \</span><br><span class="line">-e &quot;KONG_CASSANDRA_CONTACT_POINTS=kong-database&quot; \</span><br><span class="line">-e &quot;KONG_PLUGINS= bundled,kong-plugin-myplugin&quot;   \</span><br><span class="line">-e &quot;KONG_ADMIN_LISTEN=0.0.0.0:8001, 0.0.0.0:8444 ssl&quot; \</span><br><span class="line">-p 8000:8000 \</span><br><span class="line">-p 8443:8443 \</span><br><span class="line">-p 8001:8001 \</span><br><span class="line">-p 8444:8444 \</span><br><span class="line">-e &quot;KONG_PROXY_ACCESS_LOG=/dev/stdout&quot; \</span><br><span class="line">-e &quot;KONG_ADMIN_ACCESS_LOG=/dev/stdout&quot; \</span><br><span class="line">-e &quot;KONG_PROXY_ERROR_LOG=/dev/stderr&quot; \</span><br><span class="line">-e &quot;KONG_ADMIN_ERROR_LOG=/dev/stderr&quot; \</span><br><span class="line">gateway</span><br></pre></td></tr></table></figure><blockquote><p>额外需要修改 或者注意的地方</p></blockquote><p>conf/kong.conf 或者 /etc/kong/kong.conf</p><p>1.配置因为API请求中包含很大数据量,不配置会导致数据传输不完全(相应需要配合修改docker nginx 中相关内容)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">nginx_proxy_large_client_header_buffers = 8 64k  </span><br><span class="line">nginx_proxy_proxy_buffer_size = 40m  </span><br><span class="line">nginx_proxy_proxy_buffers = 4 40m  </span><br><span class="line">ngin_proxy_proxy_read_timeout = 600  </span><br><span class="line">nginx_proxy_proxy_send_timeout = 600</span><br></pre></td></tr></table></figure><p>2.定义log格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx_http_log_format=notice escape=json &apos;&#123; &quot;@timestamp&quot;: &quot;$time_iso8601&quot;, &apos; &apos;&quot;remote_addr&quot;: &quot;$remote_addr&quot;, &apos; &apos;&quot;referer&quot;: &quot;$http_referer&quot;, &apos; &apos;&quot;request&quot;: &quot;$request&quot;, &apos; &apos;&quot;status&quot;: $status, &apos; &apos;&quot;bytes&quot;:$body_bytes_sent, &apos; &apos;&quot;agent&quot;: &quot;$http_user_agent&quot;, &apos; &apos;&quot;user&quot;: &quot;$http_username&quot;, &apos; &apos;&quot;x_forwarded&quot;: &quot;$http_x_forwarded_for&quot;, &apos; &apos;&quot;upstr_addr&quot;: &quot;$upstream_addr&quot;,&apos; &apos;&quot;upstr_host&quot;: &quot;$upstream_http_host&quot;,&apos; &apos;&quot;ups_resp_time&quot;: &quot;$upstream_response_time&quot; &#125;&apos;</span><br></pre></td></tr></table></figure><p>3.更改access/error日志格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_access_log =  /dev/stdout  notice  </span><br><span class="line">admin_access_log =  /dev/stdout  notice  </span><br><span class="line">proxy_error_log  =  /dev/stderr  </span><br><span class="line">admin_error_log =  /dev/stderr</span><br></pre></td></tr></table></figure><p>4.修改kong插件代码 myplugin/access.lua</p><blockquote><p>210.14.118.96/210.14.118.95/smart.cast.org.cn-&gt;10.1.1.1<br>111.203.146.69/sso-smart.cast.org.cn:8080 -&gt;10.1.1.2:8080</p></blockquote><p>5.代码中使用时间作为加密因素之一，注意与后端服务时区保持一致，否则可能导致后端验证失败,401</p><blockquote><p>初步解决方案为　多个服务器　都　使用时间戳都转化为北京时间</p></blockquote><p>6.开启 myplugin key-auth<br>7.psql -U kong  -W</p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bug记录和解决</title>
      <link href="/2019/12/20/bug%E8%AE%B0%E5%BD%95%E5%92%8C%E8%A7%A3%E5%86%B3/"/>
      <url>/2019/12/20/bug%E8%AE%B0%E5%BD%95%E5%92%8C%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<ol><li></li></ol><blockquote><p>问题描述：人才库后端检测token失效后,返回要求跳转<br>bug描述：由于返回跳转地址与Host不同,涉及跨域问题<br>尝试1：解决问题位置,排除了问题出在授权服务器所在,确定由于浏览器拦截跨域请求<br>尝试2：尝试将跨域请求伪装成同域的请求,在经同域的nginx拦截,使用rewrite规则或者return 301 重定向；错误,由于ajax请求,是局部数据请求,本身就是为了避免全局刷新的问题,所以ajax请求会自动紧接着执行重定向请求,最终仍然跨域<br>尝试3：尝试获取后端返回的重定向请求中的Location header,然后可以在ajax的complete函数中实现判断301/302状态,跳转到Location所在地址,错误：同尝试2的错误,ajax请求会紧接着执行重定向请求,因而会导致最终执行到complete函数时,已经没有 Location 头,（此外也可能是因为跨域请求只允许暴露部分header,你也可以选择在Access-Control-Expose-Headers 中添加 你所需要暴露进而获取的header）<br>尝试4：从后端入手,当token过期或者无token时,构造状态码为401（Unauthorized）的请求,并添加Header Location的值为所要跳转的地址,同时将Location 添加到 Access-Control-Expose-Headers中,最后在前端的ajax 请求 complete函数中,设置对于 401请求的跳转处理</p></blockquote><ol start="2"><li></li></ol><blockquote><p>问题描述：spring oauth code 模式,以code请求token ,无法获得token,报 500 错误<br>排查:查看当时日志,发现是数据库查询出现问题,但没有指明查询的数据表；因而 开启MySQL数据库的日志功能,记录查询操作,从而定位数据表</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set global general_log=on; #开启日志</span><br><span class="line">show variables like &apos;%general_log%&apos;; #获得日志文件位置,tail命令查询最新日志</span><br></pre></td></tr></table></figure><blockquote><p>前因后果：由于每次服务重启,都要执行数据库脚本(即先drop 然后 create,之后写入)；考虑到许多账户信息无需重复写入,所以更改脚本如果存在就无需drop,否则才create;同时这也引发问题,即对于oauth 模式不仅有账户信息,还有其他认证信息比如说本问题中涉及的 oauth_access_token,重新启动时应当清除其中的一些认证信息,最简单的方式就是清除重建其中的table(除身份信息)<br>解决：短暂解决，直接删除重复的行即可，之后会重新更改数据库脚本</p></blockquote><ol start="3"><li></li></ol><blockquote><p>问题描述：在vue下使用外部图片链接作为 img的src 源,出现403forbidden<br>排查：起初通过chrome-&gt;developer tools-&gt;network  发现在访问原链接之后会发生一次302 重定向,在第二次请求的时候发生403 forbidden,猜测是否是因为重定向的原因导致403发生(认为由于浏览器或者js没有处理重定向)，后来尝试更改改为重定向之后链接发现,仍然有403 错误，最终发现可能是由于外部图片提供对于盗链的处理导致的<br>原因：图片提供的服务器根据 Request Header 的 Referer 来源字段判断图片是否盗链,所以可以通过隐藏这一字段来实现获取图片</p></blockquote><blockquote><p>解决：在html head 标签下添加</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;</span><br></pre></td></tr></table></figure><blockquote><p>此外，由于是在vue项目下进行全局配置，以后是否会引发其他问题，是需要考虑的;后来发现 通过 vue-meta 插件可以<a href="https://blog.csdn.net/zc_ad/article/details/87776163" target="_blank" rel="noopener">配置单个页面的 head</a></p></blockquote><ol start="4"><li></li></ol><blockquote><p>问题描述：在替换SSO服务打包之后的jar包之后，访问人才库，发现每隔一会,SSO分发的token就会失效<br>经过反复排查不是jar包损坏，后来经过开启mysql数据库日志：当建立数据库连接1分钟或者6秒之后，连接就会自动(?)断开,而在spring对于数据库的连接配置 autoConnect=true 以及 初始化脚本有对于数据库中部分表内容的全部删除,所以之后会重新建立连接，同时删除之前存储在数据库里面的token，导致最终每过一分钟就会使得token失效</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">2019-07-31T15:47:07.471818Z   82 Connectroot@localhost on oauth using TCP/IP</span><br><span class="line">2019-07-31T15:47:07.472235Z   82 Query/* mysql-connector-java-5.1.46 ( Revision: 9cc87a48e75c2d2e87c1a293b2862ce651cb256e ) */SELECT  @@session.auto_increment_increment AS auto_increment_increment, @@character_set_client AS character_set_client, @@character_set_connection AS character_set_connection, @@character_set_results AS character_set_results, @@character_set_server AS character_set_server, @@collation_server AS collation_server, @@init_connect AS init_connect, @@interactive_timeout AS interactive_timeout, @@license AS license, @@lower_case_table_names AS lower_case_table_names, @@max_allowed_packet AS max_allowed_packet, @@net_buffer_length AS net_buffer_length, @@net_write_timeout AS net_write_timeout, @@query_cache_size AS query_cache_size, @@query_cache_type AS query_cache_type, @@sql_mode AS sql_mode, @@system_time_zone AS system_time_zone, @@time_zone AS time_zone, @@transaction_isolation AS transaction_isolation, @@wait_timeout AS wait_timeout</span><br><span class="line">2019-07-31T15:47:07.472785Z   82 QuerySET character_set_results = NULL</span><br><span class="line">2019-07-31T15:47:07.473024Z   82 QuerySET autocommit=1</span><br><span class="line">2019-07-31T15:47:07.473220Z   82 Queryselect @@session.transaction_read_only</span><br><span class="line">2019-07-31T15:47:13.644983Z   73 Quit</span><br><span class="line">2019-07-31T15:47:13.648349Z   74 Quit</span><br><span class="line">2019-07-31T15:47:13.648871Z   75 Quit</span><br><span class="line">2019-07-31T15:47:13.649378Z   76 Quit</span><br><span class="line">2019-07-31T15:47:13.650263Z   77 Quit</span><br><span class="line">2019-07-31T15:47:13.650841Z   78 Quit</span><br><span class="line">2019-07-31T15:47:13.651369Z   79 Quit</span><br><span class="line">2019-07-31T15:47:13.651845Z   80 Quit</span><br><span class="line">2019-07-31T15:47:13.652346Z   81 Quit</span><br><span class="line">2019-07-31T15:47:13.652853Z   82 Quit</span><br></pre></td></tr></table></figure><blockquote><p>解决尝试：a) 可能是代码的原因，在对代码进行检查以及和git版本进行核对之后发现，代码并没有更改，排除之  b) maven 依赖的问题，猜测可能是由于maven依赖更新的原因，导致的不兼容，首先怀疑的是对于mysql的java 驱动 java-mysql-connector ,尝试过旧版本后发现版本不兼容，编译报错 ，最终把以前的jar解压后一一比对其中的依赖包文件版本是否相同，但是发现所有的依赖文件版本相同，当然也可能是由于maven其他我不知道的原因导致的，但是暂时排除之  c) 可能是由于mysql数据库本身配置的原因，比如说mysql配置中的 connect_timeout，net_read_timeout,net_write_timeout等参数，但是更改这些参数之后并没有起作用  d) 最终一次意外的尝试发现，当数据库停止运行一段时间后，再次运行之前有问题的jar包，发现不会出现重新连接的情况，猜测可能是数据库连接池没有释放或者类似的原因，导致再连数据库会出现问题 e)回来经过仔细审查发现，是由于crontab脚本出现的错误，导致最终每分钟会尝试执行数据库连接(脚本本身有错误以及脚本监控时候的设计有问题)，着可能导致SSO服务出现数据库连接闪断;<br>解决：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line">service mysqld stop    #关闭mysql数据库</span><br><span class="line">service crond stop     #关闭crontab服务</span><br><span class="line">杀死SSO的进程</span><br><span class="line">echo 3 &gt; /proc/sys/vm/drop_caches  #释放相关缓存</span><br><span class="line">2.等待5分钟左右</span><br><span class="line">3.</span><br><span class="line">service crond start    #重启 crontab 服务,执行相关定时任务</span><br><span class="line">service mysqld stop    #重启 mysql  服务</span><br></pre></td></tr></table></figure><ol start="5"><li></li></ol><blockquote><p>问题描述：在使用git pull  origin master 报错</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">remote: Repository not found. </span><br><span class="line">fatal: repository &apos;https://github.com/*/*.git/&apos; not found</span><br></pre></td></tr></table></figure><blockquote><p>经过查询<a href="https://www.jianshu.com/p/5eb3a91458de" target="_blank" rel="noopener">相关博客</a>,发现是由于之前使用git clone 要求输入用户名与密码，而输入了另一个账户的密码，windows把密码记住了，下次直接使用(这涉及git credential)<br>在当前目录下查看  git config --list 可以看到配置 credential.helper=manager<br>解决方法<br>1: 在windows 用户凭据管理中更改涉及该仓库的用户名和密码(个人使用有效)<br>2: git credential-manager uninstall   git credential-manager install 再输入密码 <a href="https://www.cnblogs.com/zqyw/p/10988018.html" target="_blank" rel="noopener">来源博客</a> (未经测试)</p></blockquote><ol start="6"><li></li></ol><blockquote><p>问题描述：由postman 发出请求,经过 Kong 网关 向 ES 发出请求时,ES报 error “headers name contain non-ascii”<br>进一步排除,一共包含3个部分，postman-&gt;Kong-&gt;ES<br>1.postman发出的请求header有问题<br>2.Kong网关在处理的过程中出现问题<br>3.ES出现问题<br>经过排查日志，发现请求顺畅，到达ES处，但是ES处返回error，因而使中间某个环节出现问题<br>直接向ES发出相关简单请求发现,没有错误，首先暂不考虑3<br>检查了postman的所有header,认为没有错误,那么很可能问题出现在Kong网关部分<br>因此问题很可能出在自定义的网关插件处，经过排查日志,也没有发现那里有错误,为了进一步确定是否是因为这个插件，直接禁止这个插件，发现正常了，起码不报error “headers name contain non-ascii”,那么就确定的确是插件中的某些逻辑出现问题，导致错误，进一步排查插件的问题<br>因为是header相关的问题，因而使用笨方法，尝试挨个注释每个命令，然后刊注释哪个之后正常即该code出问题（或者注释所有相关代码，然后解注释，看哪个有问题？），最终确定产生问题的代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx.set_header(&apos;encrypt2&apos;)=encrypt</span><br></pre></td></tr></table></figure><blockquote><p>由代码可知，header name 应该不会出现非ASCII值，而encrypt变量是加密产生的，其包含非ascii值，所以进一步<br>1.header name 包含非ascii值：在nginx/kong处给header 赋值时，由于非ascii导致溢出（？）或者（该想法未验证）encrypt超过普通header能容纳的长度，溢出<br>2.header name 不包含asciiz值：ES在判断的时候,对header 内容 和 header name中包含非ascii值，都报同一个error</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Learn Markdown</title>
      <link href="/2019/11/15/markdown/"/>
      <url>/2019/11/15/markdown/</url>
      
        <content type="html"><![CDATA[<blockquote><p>代码引用</p></blockquote><p>`print(‘hello world!’)`<br><code>print('hello world!')</code></p><p>&lt;!–￼0–&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&apos;hello world!&apos;)  </span><br><span class="line">printf(&quot;helloworld\n&quot;);  </span><br><span class="line">cout &lt;&lt; &quot;helloworld\n&quot;;  </span><br><span class="line">print(&quot;helloworld&quot;)  </span><br><span class="line">console.log(&quot;helloworld&quot;);  </span><br><span class="line">fmt.Printf(&quot;helloworld\n&quot;);  </span><br><span class="line">echo &quot;helloworld&quot;  </span><br><span class="line">&lt;h1&gt;helloworld&lt;h1&gt;  </span><br><span class="line">print(&quot;hello world&quot;)</span><br></pre></td></tr></table></figure><blockquote><p>大小</p></blockquote><p><code># 一号字</code></p><h1 id="一号字">一号字</h1><p><code>## 二号字</code></p><h2 id="二号字">二号字</h2><p><code>### 三号字</code></p><h3 id="三号字">三号字</h3><p><code>#### 四号字</code></p><h4 id="四号字">四号字</h4><blockquote><p>居中,字体,颜色</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;center&gt;&lt;font color=red size=3 face=&quot;Monospace&quot;&gt;居中&lt;/font&gt;&lt;font color=black size=5&gt;字体&lt;/font&gt;&lt;font color=blue size=6&gt;颜色&lt;/font&gt;&lt;/center&gt;</span><br></pre></td></tr></table></figure><center><font color="red" size="3" face="Monospace">居中</font><font color="black" size="5">字体</font><font color="blue" size="6">颜色</font></center><blockquote><p>空格,列表</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;ensp;</span><br><span class="line">&amp;emsp;</span><br><span class="line">&amp;ensp;&amp;emsp;</span><br></pre></td></tr></table></figure><p> 一个空格<br> 两个空格<br>  三个空格</p><p>无序列表： - + *<br>有序列表：1. 2. 3.<br>可以混合使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 一级标题  </span><br><span class="line">    + 二级标题  </span><br><span class="line">        + 二级标题  </span><br><span class="line">            * 三级标题  </span><br><span class="line">            * 三级标题  </span><br><span class="line">                1. 四级标题</span><br><span class="line">                2. 四级标题</span><br></pre></td></tr></table></figure><ul><li>小标题<ul><li>二级标题</li><li>二级标题<ul><li>三级标题</li><li>三级标题<ol><li>四级标题</li><li>四级标题</li></ol></li></ul></li></ul></li></ul><blockquote><p>链接,图片</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[链接](链接地址)</span><br></pre></td></tr></table></figure><p><a href="https://walkdeadtobe.github.io/" target="_blank" rel="noopener">我的链接</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![用来描述图片的关键词](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;我是可有可无的标题,划过图片可见)</span><br></pre></td></tr></table></figure><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg" alt="用来描述图片的关键词" title="我是可有可无的标题,划过图片可见"></p><blockquote><p>加粗,倾斜,斜体加粗,删除</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗的文字**  </span><br><span class="line">*这是倾斜的文字*  </span><br><span class="line">***这是斜体加粗的文字***  </span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure><p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em><br><em><strong>这是斜体加粗的文字</strong></em><br><s>这是加删除线的文字</s></p><blockquote><p>引用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是引用的内容  </span><br><span class="line">&gt;&gt;这是引用的内容  </span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>这是引用的内容</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><p>分割线</p></blockquote><p>三个或者三个以上的*或者-</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">----</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">***</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*****</span><br></pre></td></tr></table></figure><hr><blockquote><p>表格</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">表头1|表头2|表头3</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br></pre></td></tr></table></figure><table><thead><tr><th>表头1</th><th style="text-align:center">表头2</th><th style="text-align:right">表头3</th></tr></thead><tbody><tr><td>内容</td><td style="text-align:center">内容</td><td style="text-align:right">内容</td></tr><tr><td>内容</td><td style="text-align:center">内容</td><td style="text-align:right">内容</td></tr></tbody></table><p>第二行分割表头和内容。</p><ul><li>有一个就行，为了对齐，多加了几个<br>文字默认居左<br>-两边加：表示文字居中<br>-右边加：表示文字居右<br>注：原生的语法两边都要用 | 包起来.</li></ul><blockquote><p>注释</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--哈哈我是注释，不会在浏览器中显示。--&gt;</span><br><span class="line">[comment]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span><br><span class="line">[comment]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span><br><span class="line">[comment]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span><br><span class="line">[//]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span><br><span class="line">[//]: # (哈哈我是注释，不会在浏览器中显示。)</span><br><span class="line">[^_^]: # (哈哈我是注释，不会在浏览器中显示。)</span><br></pre></td></tr></table></figure><!--哈哈我是注释，不会在浏览器中显示。--><blockquote><p>流程图</p></blockquote><p><a href="https://support.typora.io/Draw-Diagrams-With-Markdown/" target="_blank" rel="noopener">markdown 教程</a></p><p>&lt;!–￼15–&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">​</span><br></pre></td></tr></table></figure><pre><code>&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&gt;在不支持latex的md中插入公式暂时的方法是使用在线latex网站生成公式的图片，然后复制图片链接展示[在线latex编辑网站](http://latex.codecogs.com/eqneditor/samples/example1.php)&gt;页面内跳转[我在这里](#id1)&lt;span id='id1'&gt;我要跳转&lt;a href='#id1'&gt;我要跳转</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统迁移</title>
      <link href="/2019/11/09/%E8%BF%81%E7%A7%BB/"/>
      <url>/2019/11/09/%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<p>这套系统由4部分组成</p><p>Logstash是一个开元数据收集引擎，具备实时管道功能；Logstash可以动态的将俩字不同来源的数据统一起来，并将数据标准化至你所选择的目的地。这里我们选择的Elasricearch</p><p>Elastricearch 是一个分布式可扩展的实时搜索的分析引擎，一个建立在全文搜索引擎Apache Lucene 基础上的搜索引擎，Elastricsearch 不仅包括全文搜索功能，还可以进行</p><ul><li>分布式实时文件存储，将每一个字段都编入索引，使之可以被搜索</li><li>实时分析的分布式搜索引擎</li><li>可以扩展到上百台服务器上，处理PB级别的结果或者非结构化数据</li></ul><p>FIleBeat  是一个日志文件托运工具，在服务器安装客户端后，FIlebeat可以监控日志目录或者指定的日志文件，追踪读取这些文件（追踪文件的变化，不停的读），并且转发这些信息到elasticsearch或者logstarsh中存放。</p><p>Metricbeat可以定期收集操作系统和服务器的运行指标（CPU，内存，硬盘，IO,读写速度，进程等等），Metricbeat可以将收集到的指标和数据发送到你指定的输出，比如：elasticsearch，最终达成监视服务器的目标。</p><p>Kibana是一个开源的分析和可视化平台，设计用于和Elasticsearch一起工作。你用Kibana来搜索，查看，并和存储在Elasticsearch索引中的数据进行交互。你可以轻松地执行高级数据分析，并且以各种图标、表格和地图的形式可视化数据。Kibana使得理解大量数据变得很容易。它简单的、基于浏览器的界面使你能够快速创建和共享动态仪表板，实时显示Elasticsearch查询的变化。</p><p><font size="6">kong</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log_format json_log escape=json &apos;&#123; &quot;@timestamp&quot;: &quot;$time_iso8601&quot;, &apos;  &apos;&quot;remote_addr&quot;: &quot;$remote_addr&quot;, &apos;  &apos;&quot;referer&quot;: &quot;$http_referer&quot;, &apos;  &apos;&quot;request&quot;: &quot;$request&quot;, &apos;  &apos;&quot;status&quot;: $status, &apos;  &apos;&quot;bytes&quot;:$body_bytes_sent, &apos;  &apos;&quot;agent&quot;: &quot;$http_user_agent&quot;, &apos;  &apos;&quot;user&quot;: &quot;$http_username&quot;, &apos; &apos;&quot;x_forwarded&quot;: &quot;$http_x_forwarded_for&quot;, &apos;  &apos;&quot;upstr_addr&quot;: &quot;$upstream_addr&quot;,&apos;  &apos;&quot;upstr_host&quot;: &quot;$upstream_http_host&quot;,&apos;  &apos;&quot;ups_resp_time&quot;: &quot;$upstream_response_time&quot; &#125;&apos;;</span><br><span class="line">access_log logs/access.log json_log;</span><br></pre></td></tr></table></figure><p><font size="6">logstash</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#filebeat_kong.conf</span><br><span class="line">input&#123;</span><br><span class="line">   beats &#123;</span><br><span class="line">        type =&gt; &quot;nginx-log&quot; #&quot;logs&quot;</span><br><span class="line">        port =&gt; 9044</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">filter&#123;</span><br><span class="line">    json&#123; #获取nginx log日志</span><br><span class="line">        source =&gt; &quot;message&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    mutate&#123;# 删去logstash转化后保留的messegae字段</span><br><span class="line">            remove_field =&gt; [&quot;message&quot;]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output&#123;</span><br><span class="line">    stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [&quot;10.1.1.46:9200&quot;]</span><br><span class="line">        index =&gt; &quot;system-syslog-%&#123;+YYYY.MM&#125;&quot;</span><br><span class="line">        document_type =&gt; &quot;logs&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="6">filebeat</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#filebeat.yml</span><br><span class="line">filebeat.prospectors:</span><br><span class="line"></span><br><span class="line">- input_type: log</span><br><span class="line"> # encoding: UTF-8</span><br><span class="line">  paths:</span><br><span class="line">    - /home/LAB/chengr/kong_log/file.log</span><br><span class="line">  json.keys_under_root: true #在一次部署中发现这一行不能识别，最终注释之解决</span><br><span class="line">  #json.add_error_key: true</span><br><span class="line">  #json.message_key: log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output.logstash:</span><br><span class="line">  #The Logstash hosts</span><br><span class="line">  hosts: [&quot;10.1.1.46:9044&quot;]</span><br></pre></td></tr></table></figure><p><font size="6">elastcisearch</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#config/elasticsearch.yml</span><br><span class="line">cluster.name: my-es-cluster</span><br><span class="line">node.name: es-node-1</span><br><span class="line">path.data: /home/LAB/chengr/ELK/data/data-es</span><br><span class="line">path.logs: /home/LAB/chengr/ELK/log/log-es</span><br><span class="line">network.host: 10.1.1.46</span><br><span class="line">http.port: 9200</span><br></pre></td></tr></table></figure><p><font size="6">kibana</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#config/kibana.yml</span><br><span class="line">server.port: 5601</span><br><span class="line">elasticsearch.url: &quot;http://10.1.1.46:9200&quot;</span><br></pre></td></tr></table></figure><p>ps:部署在实际机器上时将配置中ip改为对应的IP</p><p><font size="5">kibana 添加邮件预警 </font><br><a href="http://www.cnblogs.com/small-k/p/8551960.html" target="_blank" rel="noopener">http://www.cnblogs.com/small-k/p/8551960.html</a><br><a href="https://blog.51cto.com/10546390/2051676" target="_blank" rel="noopener">https://blog.51cto.com/10546390/2051676</a></p><p>ps:<a href="https://docs.konghq.com/0.13.x/configuration/?_ga=2.242544130.102618566.1558236281-1173907870.1558236281#proxy_access_log" target="_blank" rel="noopener">kong 相关配置地址</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Aminer</title>
      <link href="/2019/11/03/Aminer/"/>
      <url>/2019/11/03/Aminer/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/t6am3/AMiner_Name_Disambiguation" target="_blank" rel="noopener">Github 项目地址</a><br>这是一场关于论文 同名消歧的比赛,<a href="https://biendata.com/competition/aminer2019/data/" target="_blank" rel="noopener">项目地址</a><br>我们主要借鉴的<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4597035&amp;tag=1" target="_blank" rel="noopener">论文</a><br>论文中发现直接聚类的效果不好，其思路是首先进行居于规则的原子聚类，然后基于原子聚类的结果进一步进行聚类算法，论文中所举的例子是层次聚类(Hierarchical Clustering)以及K-means聚类,论文中发现这种方法可以大幅提升正确率<br>但是我们在实际中发现,论文中所提及的原子聚类效果并不好，也有可能是这场比赛所提供的数据集的问题，最终我们尝试使用自己首先进行规则上的归类，然后再进行基于层次聚类以及K-means聚类</p>]]></content>
      
      
      
        <tags>
            
            <tag> Competition ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>distributed algorithm</title>
      <link href="/2019/10/27/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2019/10/27/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Raft</p></blockquote><p><a href="https://cloud.tencent.com/developer/news/263309" target="_blank" rel="noopener">参考链接</a><br>Raft是一个一致性算法，旨在易于理解。它提供了Paxos的容错和性能。不同之处在于它被分解为相对独立的子问题，它清楚地解决了实际系统所需的所有主要部分。我们希望Raft能够为更广泛的受众提供共识，并且这个更广泛的受众将能够开发出比现在更多的高质量共识系统。</p><p>Raft是一个通过管理一个副本日志的一致性算法。它提供了跟(multi-)Paxos一样有效的功能，但是它的架构和Paxos不一样；它比Paxos更加容易理解，并且能用于生产环境中。为了加强理解，raft把一致性的问题分成了三个子问题，例如leader election, log replication, and safety,</p><p>Role</p><p>Leader，Follower，candidate</p><p>在Raft集群中，有且仅有一个Leader，在Leader运行正常的情况下，一个节点服务器要么就是Leader，要么就是Follower。Follower直到Leader故障了，才有可能变成candidate。</p><p>Leader负责把client的写请求log复制到follower。它会和follower保持心跳。每个follower都有一个timeout时间（一般为150ms~300ms），在接受到心跳的时候，这个timeout时间会被重置。如果follower没有接收到心跳，这些follower会把他们的状态变为candidate，并且开启新的一轮leader election。</p><p>term逻辑时钟</p><p>Term相当于paxos中的proposerID，相当于一个国家的朝代。term是一段任意的时间序号。每一任Leader都有一个与之前不同的term。</p><p>当Leader选举成功之后，一个节点成为了Leader，就会产生一个新的term，并且直到Leader故障，整个集群都会一直在这个term下执行操作。</p><p>如果leader选举失败了，则会再生成出一个term，再开启一轮leader选举。</p><p>Quorums：</p><p>多数派，意思是超过一半的机器存活，则这个机器可用，这个Quorums指的就是集群可用的指标。例如：集群中的节点数为2N，如果有N+1的机器存活，则代表集群可用，可接受请求，写入log，应用到state machine中去，执行操作。如果少于N+1个机器存活，则代表集群可用，可接受请求，可写入log，但不应用到state machine中去，不执行操作。</p><p>Leader Election</p><p>只有在下列两种情况下才会进行leader election：</p><p>在第一次启动raft集群的时候</p><p>在一个已存在的Leader故障的时候</p><p>选举流程：</p><p>如果以上两种任何一种发生了，所有的Follower无法再和Leader保持心跳，则它们都会等待一个（选举）timeout，如果其中一个Follower的timeout最先到时，则这个Follower变成candidate开始选举，</p><p>第一，增加term计数器，</p><p>第二，给自己投票并向所有其他的节点服务器请求投自己一票。</p><p>如果一个Follower在接受到投票请求时，接受到两个term相同的投票请求时（也就是说，产生了两个candidate），则在多个相同term的投票请求中，这个Follower只能给投给其中一个请求，只能投一票，并且按照先来先服务的原则投票。</p><p>如果这个candidate收到另外一个节点服务器的消息，并且这个节点服务器的term序号和当前的term序号一样大，甚至更大的话，则这个candidate选举失败，从而它的状态变成Follower，并且接受新的Leader。</p><p>如果一个candidate获得了Quorums选票N+1(2N为集群中节点的数目)，则它变成新的leader。</p><p>如果多个candidate和多个Follower投完票之后，有多个candidate获得了相同的票数，则会产生split vote，则新的term产生，重新选举。Raft用随机选举timeout迅速地解决split vote问题，这个方法就是对于产生spit vote的candidates各自随机生成一个选举timeout，谁先到时，谁当leader，其他candidate都变为Follower。</p><p>当一个leader被选举出来之后，就在Follower timeout到时变为candidate之前，发心跳信息给所有Followers。</p><p>Log Replication（Raft协议具体过程）</p><p>Leader负责把client的请求日志复制给其他Followers。</p><p>Raft协议具体过程就是通过复制状态机的架构实现的，如下：</p><p>步骤：</p><p>Client发送请求给Leader，其中每个请求都是一条操作指令。</p><p>Leader接受到client请求之后，把操作指令(Entry)追加到Leader的操作日志中。紧接着对Follower发起AppendEntries请求、尝试让操作指令(Entry)追加到Followers的操作日志中，即落地。如果有Follower不可用，则一直尝试。</p><p>一旦Leader接受到多数（Quorums）Follower的回应，Leader就会进行commit操作，每一台节点服务器会把操作指令交给状态机处理。这样就保证了各节点的状态的一致性。</p><p>各服务器状态机处理完成之后，Leader将结果返回给Client。</p><p>Saftety</p><p>Raft的安全性，体现在如下几个方面：</p><p>Election safety:在一个term下，最多只有一个Leader。</p><p>Leader Append-Only:一个Leader只能追加新的entries，不能重写和删除entries</p><p>Log Matching:集群中各个节点的log都是相同一致的</p><p>Leader Completeness:如果一个log entry被committed了，则这个entry一定会出现在Leader的log里。</p><p>State Machine Safety:如果一个节点服务器的state machine执行了一个某个log entry命令，则其他节点服务器，也会执行这个log entry命令，不会再执行其他命令</p><p>之前四条，在前面都有所提及，而State Machine Safety是在Leader election过程中用到过。</p><p>State Machine Safety</p><p>一个candidate在选举的时候，它会向其他节点服务器发送包含他的log的消息，获取票数，如果它的log是最新的，则会获取选票，如果它的log不是最新的，其他节点服务器还有更加新的log，则会拒绝给这个candidate投票。这就保证了State Machine Safety。</p><p>所以State Machine Safety保证的就是一个candidate必须拥有最新的log，才能获取票数，才有机会赢得Leader选举，才有机会成为Leader。</p><p>Follower crashes</p><p>如果一个follower故障了，则不会再接受AppendEntriesandvoterequests，并且Leader会不断尝试与这个节点保持心跳。</p><p>如果这个节点恢复了，则会接受Leader的最新的log，并且将log应用到state machine中去，执行log中的操作</p><p>方格指的是client发出的一条请求。</p><p>方格虚线，说明一条log entry写入了log。</p><p>方格实线，说明一条log entry应用到state machine中</p><p>Leader crashes</p><p>则会进行Leader election。</p><p>如果碰到Leader故障的情况，集群中所有节点的日志可能不一致。</p><p>old leader的一些操作日志没有通过集群完全复制。new leader将通过强制Followers复制自己的log来处理不一致的情况，步骤如下：</p><p>对于每个Follower，new leader将其日志与Followers的日志进行比较，找到他们的达成一致的最后一个log entry。</p><p>然后删除掉Followers中这个关键entry后面的所有entry，并将其替换为自己的log entry。该机制将恢复日志的一致性。</p><p>下面这种情况集群中所有节点的日志可能不一致：</p><p>总结</p><p>Raft要求具备唯一Leader，并把一致性问题具体化为保持日志副本的一致性，以此实现相较Paxos而言更容易理解、更容易实现的目标。Raft是state machine system，Zab是primary-backup system。</p><p>引用</p><ul><li><a href="https://en.wikipedia.org/wiki/Raft_(computer_science)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Raft_(computer_science)</a></li><li><a href="https://raft.github.io/" target="_blank" rel="noopener">https://raft.github.io/</a></li><li><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></li><li><a href="https://raft.github.io/raft.pdf" target="_blank" rel="noopener">https://raft.github.io/raft.pdf</a></li><li><a href="https://www.cnblogs.com/bangerlee/p/5991417.html" target="_blank" rel="noopener">https://www.cnblogs.com/bangerlee/p/5991417.html</a></li><li><a href="https://www.bilibili.com/video/av21667358/" target="_blank" rel="noopener">https://www.bilibili.com/video/av21667358/</a></li><li><a href="https://en.wikipedia.org/wiki/State_machine_replication" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/State_machine_replication</a></li><li><a href="https://github.com/CNiceToUpp/notes/blob/master/paxos%2Craft%2Czab/paper/In%20Search%20of%20an%20Understandable%20Consensus%20Algorithm.pdf" target="_blank" rel="noopener">https://github.com/CNiceToUpp/notes/blob/master/paxos%2Craft%2Czab/paper/In Search of an Understandable Consensus Algorithm.pdf</a></li></ul><blockquote><p>PAXOS</p></blockquote><p>它的假设前提是，在分布式系统中进程之间的通信会出现丢失、延迟、重复等现象，但不会出现传错的现象。Paxos算法就是为了保证在这样的系统中进程间基于消息传递就某个值达成一致。</p><p>在Paxos算法中，有两种角色：</p><p>Proposer<br>Acceptor<br>Paxos算法分为两个阶段。具体如下：</p><p>阶段一：<br>(a) Proposer选择一个提案编号N（全剧唯一version），然后向半数以上的Acceptor发送编号为N的Prepare请求。</p><p>(b) 如果一个Acceptor收到一个编号为N的Prepare请求，且N大于该Acceptor已经响应过的所有Prepare请求的编号，那么它就会将它已经接受过的编号最大的提案（如果有的话）作为响应反馈给Proposer，同时该Acceptor承诺不再接受任何编号小于N的提案。如果已经接受过，比较版本号大小，持久化最新的，并返回信息</p><p>阶段二：<br>(a) 如果Proposer收到半数以上Acceptor对其发出的编号为N的Prepare请求的响应，那么它就会发送一个针对[N,V]提案的Accept请求给半数以上的Acceptor。注意：V就是收到的响应中编号最大的提案的value，如果响应中不包含任何提案，那么V就由Proposer自己决定。</p><p>(b) 如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor没有对编号大于N的Prepare请求做出过响应，它就接受该提案。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/09/19/hello-world/"/>
      <url>/2019/09/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/09/19/centos/"/>
      <url>/2019/09/19/centos/</url>
      
        <content type="html"><![CDATA[<p>centos  安装  psycopg2</p><p>直接 pip install psycopg2报错，根据错误 还需要安装 pip install psycopg2-binary/setuptools,以及  yum install gcc<br>可能还需要安装</p><ul><li>sudo yum install postgresql-libs</li><li>sudo yum install postgresql-devel</li><li>sudo yum install python-devel</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/09/19/README/"/>
      <url>/2019/09/19/README/</url>
      
        <content type="html"><![CDATA[<h1 id="myblog">myblog</h1><p>my_github_blog in markdown</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Raft算法</title>
      <link href="/2019/09/17/Raft/"/>
      <url>/2019/09/17/Raft/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> algorithm 一致性 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bwg</title>
      <link href="/2019/09/04/Windows_terminal/"/>
      <url>/2019/09/04/Windows_terminal/</url>
      
        <content type="html"><![CDATA[<p>开始尝试使用windows terminal ,遇到有些问题记录下来<br>1.在termianl 进入Ubuntu 继续使用 windows安装的程序</p><ul><li>首先在 ~/.bashrc 中添加可执行程序的路径所在</li><li>使用 chmod +x 标识 可执行程序 可执行</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> windows terminal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Paxos</title>
      <link href="/2019/08/12/Paxos/"/>
      <url>/2019/08/12/Paxos/</url>
      
        <content type="html"><![CDATA[<p>博客列表：</p><ul><li><a href="https://www.cnblogs.com/hugb/p/8955505.html" target="_blank" rel="noopener">图解分布式一致性协议Paxos</a></li></ul><p>相关概念</p><ul><li>拜占庭模型:<ul><li><a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">wiki 拜占庭问题</a></li><li>分布式对等网路容错问题：在分布式对等网络中需要按照共同一致策略协作的成员计算机即为问题中的将军，而各成员计算机赖以进行通讯的网络链路即为信使。拜占庭将军问题描述的就是某些成员计算机或网络链路出现错误、甚至被蓄意破坏者控制的情况。</li></ul></li><li>非拜占庭模型：<ul><li>指可能出现故障，但是不会伪造信息的情况(即，要么收不到信息，要么收到真实的信息)</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Distributed System 一致性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 学习</title>
      <link href="/2019/07/22/Git/"/>
      <url>/2019/07/22/Git/</url>
      
        <content type="html"><![CDATA[<h3 id="简介">简介</h3><p>GIT 可以分为本地的内容寻址系统(content-addressable filesystem) 和 远程的分布式的版本控制系统(version control system)</p><blockquote><p>在本地其核心可以看做一个简单的键值对数据存储系统,value 是实际存储的文件(.git/objects 目录下),key是文件的SHA-1值,因而我们用key 找回(retrieve) 历史内容<br>远程内容待补充</p></blockquote><h3 id="目录解析">目录解析</h3><p>.git<br>├── COMMIT_EDITMSG<br>├── FETCH_HEAD<br>├── HEAD<br>├── config<br>├── description<br>├── index<br>├── hooks//以下是文件夹<br>├── info<br>├── logs<br>├── objects<br>└── refs</p><p>1.git/COMMIT_EDITMSG</p><blockquote><p>记录commit附带的说明，经测试只记录最新的commit 说明</p></blockquote><p>2.git/FETCH_HEAD</p><blockquote><p>记录从远程仓库fetch的各分支的Head</p></blockquote><p>3.git/HEAD</p><blockquote><p>表示当前分支的Head</p></blockquote><p>4.git/config</p><blockquote><p>当前 git仓库的配置文件。保存这 git仓库的远程地址,远程仓库分支等</p></blockquote><p>5.git/index</p><blockquote><p>暂存区:存储时间戳,文件名,文件的SHA值等元数据<br>每当我们执行 git add操作的时候， git会给添加的每个文件的内容创建一个对象，然后把这个文件的路径和生成的对象进行映射，存放到 .git/index文件中。等到后期新的命令（比如：git add、 git rm或者 git mv）执行的时候，又会重新更新索引。</p></blockquote><p>6.git/hook</p><blockquote><p>伴随着git的命令所触发的处理脚本,通常在 git init 时拷贝到新目录<br>具体脚本可分为客户端和服务端两种,待补充</p></blockquote><p>7.git/info</p><blockquote><p>关于仓库的的其他信息<br>例如.git/info/exclude 可以排除本地本人不想提交的文件,只与自己相关,该文件也不会上传,可用于排除私人的某些配置等,注意与全局的 .gitignore 文件区别</p></blockquote><p>8.git/logs</p><blockquote><p>记录仓库各分支上提交的commit操作/修改,可以通过 git log 查看</p></blockquote><p>9.git/objects</p><blockquote><p>真正保存代码的地方。其中分成两种类型的文件，一种是 pack，另外的是 blob文件。其中 pack是根据定位内容非常相似的全部文件，然后为他们之一存储整个内容。之后计算相似文件之间的差异并且只存储差异。而 blob文件就是记录差异。blob是“二进制大对象”（ binary largeobject）的简写，是计算机领域常用术语，用来指代某些可以包含任意数据的变量或文件<br>.git/objects:三种类型</p><blockquote><p>blob :实际存储的文件,<a href="https://www.git-scm.com/book/en/v2/Git-Internals-Git-Objects" target="_blank" rel="noopener">具体详情</a><br>tree : 当前project的一个快照,存储多个实体/数据结构(由blob object的git mode,类型,SHA-1值,文件名构成),记录了当前tree下所有文件所指向的blob object<br>commit: 记录所产生的tree object,作者,时间,commit msg,上一个commit object<br>tag: 根据我查看的文件结构与commit相同,但引用博客中说没有记录tree object,而记录创建tag 所在的commit object,是因为更新了？</p></blockquote></blockquote><blockquote><p>.git/objects/info 关于object的其他信息<br>.git/objects/pack 在git gc  或者 git push 时,git 会将松散的object文件打包压缩,降低存储空间 <a href="https://www.git-scm.com/book/en/v2/Git-Internals-Packfiles" target="_blank" rel="noopener">详情</a></p></blockquote><p>10.git/refs</p><blockquote><p>引用文件<br>.git/refs/heads 记录本地各分支最新状态(文件中存储git object 的SHA-1值),即指向最后一次commit提交只有产生的git object<br>.git/refs/tags<br>.git/refs/remotes 记录远程各分支最新状态(文件中存储git object 的SHA-1值),同样指向本地的git object(每次fetch或者pull会拉去远程的更新)</p></blockquote><h3 id="常见命令及其解析">常见命令及其解析：</h3><h4 id="git-addcommitpushfetchconfig">git add/commit/push/fetch/config</h4><blockquote><p>git add <filename></filename></p></blockquote><h4 id="git-checkout">git checkout</h4><blockquote><p><code>git checkout &lt;branch-name&gt;</code> 更改分支</p></blockquote><h4 id="git-reset">git reset</h4><blockquote><p>git reset --hard/mixed/soft</p></blockquote><h4 id="git-log">git log</h4><blockquote></blockquote><h4 id="git-cat-files">git cat-files</h4><blockquote></blockquote><h3 id="常见git场景">常见git场景</h3><h4 id="撤销修改">撤销修改</h4><blockquote><p>已修改,未 <code>git add</code> : <code>git checkout  -- &lt;filepathname&gt;</code> 撤销 某文件未 git add提交的缓存,例如 <code>git checkout --</code> .撤销当前目录所有文件的未add 缓存</p></blockquote><blockquote><p>已 <code>git add</code>,未 <code>git commit</code>: <code>git reset HEAD filepathname</code> 可以撤销 <code>git add</code>命令，回退到 已修改,未 <code>git add</code> 状态</p></blockquote><blockquote><p>已 <code>git commit</code>,未 <code>git push</code>: <code>git reset --hard HEAD^</code> 可回退到上次commit的的状态,也可以使用 <code>git reset --hard  &lt;commitid&gt;</code> 回退到任意版本</p></blockquote><p>跟随态 VS 游离态</p><p>参考：<br>1.<a href="https://www.siteground.com/tutorials/git/directory-structure/" target="_blank" rel="noopener">Git Directory</a><br>2.<a href="https://www.git-scm.com/book/en/v2/Git-Internals-Git-References" target="_blank" rel="noopener">Git Ref</a><br>3.<a href="https://www.git-scm.com/docs/githooks" target="_blank" rel="noopener">Git hooks</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> git  file </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lua</title>
      <link href="/2019/07/10/lua/"/>
      <url>/2019/07/10/lua/</url>
      
        <content type="html"><![CDATA[<p><br>因为决定学习开发网关kong的插件，所以需要学习lua语言，正在从<a href="https://www.runoob.com/lua/" target="_blank" rel="noopener">Lua 菜鸟教程</a>学习<br><br>关于kong插件开发的博客 <a href="https://www.jianshu.com/p/68457b42b84f" target="_blank" rel="noopener">链接1</a><br><br>发现一个很有意思的lua 模块  :openresty 的lua-resty-template 模块，提供模板渲染的功能<br><br>准备在网关处进行对于token的检验工作，由于没有使用已有的oauth server 插件，所以需要自己写个额外插件<br>在这个插件中主要需要完成的工作是从cookie 中 提取出 token ,并以此为凭借到oauth  server 进行相关检验，如果检验成功，应当返回id 以及这个token的ttl ,网关处获得id 应当 将之体现在日志里(插件逻辑处新建header,在nginx日志处自定义日志格式,指明该id或者在网关处建立与oauth server相同的用户体系，起码账户名一致，这样根据id 可以从数据库中提取出相应的consumer credential ,这样的话可以用于后续的基于用户的限流等操作)<br>主要点在于1.Lua中进行http 操作  ,<a href="https://github.com/ledgetech/lua-resty-http#request" target="_blank" rel="noopener">Github 源码文档</a><br>2.考虑对token进行缓存,[‘token’,‘id’,ttl],这样无需多次存取(可能带来的问题有，注销登录后如何通知网关注销token：这又分为两种注销后不再登录和重新登陆，对于后者可以下次请求经过网关时,注销相同id的键值对)<br><a href="https://github.com/openresty/lua-resty-redis/" target="_blank" rel="noopener">Github lua-resty-redis</a><br><a href="https://github.com/Kong/kong/blob/master/kong/plugins/rate-limiting/policies/init.lua" target="_blank" rel="noopener">Kong rate-limiting 插件</a>中涉及对于redis的操作,可以观摩下</p><p><br>目前在网关处验证用户身份成功后，在后端为避免再次检验身份的需要，因此需要网关提供给后端身份凭据，认可这次身份凭据，同时应当提供某种验证手段，让后端验证请求是否身份凭据是否是真的/是否是伪造<br>方案1 ：利用某种对称加密算法,网关对用户身份进行加密,后端以相同的密钥进行解密,得到身份<br>确定使用AES算法<a href="https://github.com/openresty/lua-resty-string/" target="_blank" rel="noopener">Github 示例</a>,在网关处使用CBC加密，相同的偏移向量,结果转化为hex格式，传输到python后端，对结果转发，解密，但是解密始终得不到正确的结果，怀疑是<a href="https://blog.csdn.net/diodosu/article/details/51923670" target="_blank" rel="noopener">博客</a>中提到的问题，但是我在测试中设置的加密字段,加密密钥，偏移向量都是16位的，看起来应该不会有填充的问题才对，但是解密仍然失败<br>方案2 ：采取非对称加密算法，在网关处向后端传递两个header：userid,encrypted 在网关处按照某种方法加密得到 encrypt header,后端使用同样的方法加密，如果结果相同，则认为 userid 经过了网关的认证，同时加密内容应当是网关与后端之间相互约定的动态的内容</p><p><br>2020-1-10 代码更新，把硬编码信息改为插件的配置输入<br>curl -i -X POST <a href="http://localhost:8001/plugins" target="_blank" rel="noopener">http://localhost:8001/plugins</a> <br>–data “name=kong-plugin-myplugin” <br>–data “config.sso_domain=SS0_DOMAIN” <br>–data “config.check_path=CHECK_PATH” <br>–data “config.front_domain=FRONT_DOMAIN” <br>–data “config.client=CLIENT_JSON”</p><p>其中需要注意的是，kong网关对于插件配置的输入中对于字符 ‘&amp;’ 的支持不好，而使用’\&amp;‘的话，网关处接收后会转化为’\\&amp;’,看起来很不舒服，然后我 使用 ‘\a’ 字符代表 ‘&amp;’,在插件处理逻辑处再替换回来(需要注意的是如果单个的’'存在，会影响 string 转化为 json)</p>]]></content>
      
      
      
        <tags>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划学习</title>
      <link href="/2019/07/10/dp/"/>
      <url>/2019/07/10/dp/</url>
      
        <content type="html"><![CDATA[<p>参考资料：</p><ul><li><a href="https://wenku.baidu.com/view/cd5dc88ef80f76c66137ee06eff9aef8951e4854.html" target="_blank" rel="noopener">百度文库资料</a></li><li><a href="https://www.cnblogs.com/Renyi-Fan/p/9285495.html" target="_blank" rel="noopener">博客</a></li></ul><p>动态规划(dynamic programming)<br>条件：</p><ol><li>最优子问题结构</li><li>子问题重叠性质</li><li>无后效性</li></ol><p>动态规划分类</p><ul><li>线性型<ul><li>简介：在线性空间上的递推dp</li><li>思路：</li><li>例子：最长上升子序列(LIS)、最长公共子序列(LCS)、最大子序列和</li></ul></li><li>区间型<ul><li>简介：区间dp就是在区间上进行动态规划，求解一段区间上的最优解。可以是二维的也可以是三维的，一般情况下为二维；</li><li>思路：主要是通过合并小区间的 最优解进而得出整个大区间上最优解的dp算法</li><li>例子：</li></ul></li><li>背包型<ul><li>简介：</li><li>思路：</li><li>例子：0-1背包、完全背包、分组背包、多重背包</li></ul></li><li>树型<ul><li>简介：建立在树这种数据结构上的dp</li><li>思路：一般可以通过dfs维护从根到叶子或从叶子到根的状态转移</li></ul></li><li>其他<ul><li>矩阵型</li><li>序列型</li><li>双序列型</li><li>划分型</li><li>状态压缩型</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> dp  algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>regex</title>
      <link href="/2019/07/09/regex/"/>
      <url>/2019/07/09/regex/</url>
      
        <content type="html"><![CDATA[<p>最近需要从nginx header中提取出变量，需要学习正则表达式相关知识<br><a href="https://www.runoob.com/regexp/regexp-tutorial.html" target="_blank" rel="noopener">菜鸟教程 正则表达式</a></p><blockquote><p>可以使用 $1 $2 $3等来表示匹配的变量<br>例如 对于字符串  A90B3C  ,正则表达式  /A(\d+)B(\d+)C/  匹配的 $1=90 $2=3<br>亦或者 对于正则表达式 /A((\d+)B)(\d+)C/  匹配的 $1=90B  $2=90  $3=3</p></blockquote><br>>对实际应用可以匹配  $http_cookie ~ token=([a-z0-9]*);api_key=([a-z0-9]*)在实际搜素中发现有人使用 {variable}以及<variable> 来匹配变量 variable ，但是在查询文档中没有发现这种用法，也欸有试过是否能用</variable>]]></content>
      
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="/2019/06/29/nginx/"/>
      <url>/2019/06/29/nginx/</url>
      
        <content type="html"><![CDATA[<blockquote><p>rewrite规则必须匹配对应的域名才能生效，比如是server_name <a href="http://xn--aa-tz2c.com" target="_blank" rel="noopener">为aa.com</a> 下的rewrite 规则，则必须访问时前缀是 <a href="http://aa.com" target="_blank" rel="noopener">aa.com</a> ，rewrite规则才能生效</p></blockquote><p>在 nginx 反向代理处直接拒绝不携带token的请求</p><blockquote><p>在 server 内 ，loaction 前对于所有请求 判断cookie内是否携带token(先不管token是否有效)，其中排除对包含code/oauth/static的请求，如果不携带，则使之跳转到授权服务器，登录后自动跳转到首页</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// if ( $request_uri ~* (.*)210.14.118.96(.*))</span><br><span class="line"> // &#123;  rewrite ^/(.*)$  http://localhost:80/$1 break; &#125;</span><br><span class="line">  set $flag 1;</span><br><span class="line"></span><br><span class="line">  if ( $http_cookie ~* (.*)token=(.*) )</span><br><span class="line">  &#123; set $flag 0; &#125;</span><br><span class="line"></span><br><span class="line">  if ( $request_uri ~* (.*)code=(.*))</span><br><span class="line">  &#123; set $flag 0; &#125;</span><br><span class="line"></span><br><span class="line">  if ( $request_uri ~* (.*)oauth(.*))</span><br><span class="line">  &#123; set $flag 0; &#125;</span><br><span class="line"></span><br><span class="line">  if ( $request_uri ~* (.*)static(.*))</span><br><span class="line">  &#123; set $flag 0; &#125;</span><br><span class="line"></span><br><span class="line">  if ( $request_uri ~* (.*)/js/(.*))</span><br><span class="line">  &#123; set $flag 0; &#125;</span><br><span class="line"></span><br><span class="line">  if ( $request_uri ~* (.*)/css/(.*))</span><br><span class="line">  &#123; set $flag 0; &#125;</span><br><span class="line"></span><br><span class="line">  if ( $http_referer = &quot;http://210.14.118.96/&quot; )</span><br><span class="line">  &#123; set $flag 0; &#125;</span><br><span class="line"></span><br><span class="line">  if ( $http_referer = &quot;&quot; )</span><br><span class="line">  &#123; set $flag 0; &#125;</span><br><span class="line"></span><br><span class="line">  if ( $flag = 1)&#123;</span><br><span class="line">  //rewrite ^(.*)$ http://111.203.146.69/oauth/authorize?client_id=kexie&amp;redirect_uri=http://210.14.118.96/ep/cookie.html&amp;response_type=code&amp;scope=read permanent;# redirect;</span><br><span class="line">  return 301  http://111.203.146.69/oauth/authorize?client_id=kexie&amp;redirect_uri=http://210.14.118.96/ep/cookie.html&amp;response_type=code&amp;scope=read;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是 从网上博客看，/etc/nginx/nginx.conf 的优先级比 /etc/nginx/conf.d/* 以及/etc/nginx/sites-enables/*优先级高，  但是如果后面的配置中标明了default_server，那么优先级应该是更高的(实际效果，没有去网上查找核实);导致后者的server_name:_  覆盖了前者的server_name:210.14.118.96</p></blockquote><p>在vue项目中 ，全局配置使得请求携带cookie<br>修改 ./src/main.js 添加 <a href="https://github.com/pagekit/vue-resource/issues/191" target="_blank" rel="noopener">相关问题连接</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &quot;vue&quot;;</span><br><span class="line">import VueAwesomeSwiper from &apos;vue-awesome-swiper&apos;</span><br><span class="line">import &apos;swiper/dist/css/swiper.css&apos;</span><br><span class="line">import App from &quot;./App.vue&quot;;</span><br><span class="line">import router from &quot;@/router/index&quot;;</span><br><span class="line">import store from &quot;@/store/index&quot;;</span><br><span class="line">import ElementUI from &quot;element-ui&quot;</span><br><span class="line">import &apos;element-ui/lib/theme-chalk/index.css&apos;</span><br><span class="line">import echarts from &quot;echarts&quot;;</span><br><span class="line">import &#123; debounce &#125; from &quot;@/assets/scripts/util&quot;;</span><br><span class="line">import starSky from &quot;@/assets/scripts/common/canvas.js&quot;;</span><br><span class="line">import echartTheme from &quot;@/constant/chalk.project.json&quot;</span><br><span class="line">//添加内容-开始</span><br><span class="line">import VueResource from &apos;vue-resource&apos;</span><br><span class="line">Vue.use(VueResource)</span><br><span class="line">Vue.http.options.xhr = &#123; withCredentials: true &#125;;</span><br><span class="line">//添加内容-结束</span><br><span class="line">echarts.registerTheme(&quot;chalk&quot;, echartTheme);</span><br><span class="line">Vue.config.productionTip = false;</span><br><span class="line">Vue.use(VueAwesomeSwiper)</span><br><span class="line">Vue.use(ElementUI)</span><br><span class="line">Vue.prototype.$charts = echarts;</span><br><span class="line">Vue.prototype.$debounce = debounce;</span><br><span class="line">Vue.prototype.$starSky = starSky;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;).$mount(&quot;#app&quot;);</span><br></pre></td></tr></table></figure><p>此外报错，需要安装插件</p><blockquote><p>npm install --save vue-resource</p></blockquote><blockquote><p>清除cookie 使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = &quot;token=;expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/&quot;; </span><br><span class="line">document.cookie = &quot;token=;expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/ep&quot;;</span><br></pre></td></tr></table></figure><p>而 setCookie()不能删除不同域下cookie</p><blockquote><p>当使用 upstream 代指 上游 多个可用服务器，nginx会根据 error  timeout 来自动替换选择 可用服务器，但是不支持对于有状态码的返回，此外我们可以配置自动检查后端情况以及相应处理 ,<a href="https://www.nginx.com/resources/wiki/modules/healthcheck/" target="_blank" rel="noopener">Nginx ngx_http_healthcheck_module</a>  <a href="https://github.com/cep21/healthcheck_nginx_upstreams/blob/master/README" target="_blank" rel="noopener">Github healthcheck_nginx_upstreams</a><br>而在目前项目中，由于前端nginx调用后面网关 ，所以需要已具有某些状态码来决定是否轮替， 例如</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">upstream backends &#123;</span><br><span class="line">server 192.2.0.1;</span><br><span class="line">server 192.2.0.2;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">  location / &#123;</span><br><span class="line">  proxy_pass http://backends;</span><br><span class="line">  proxy_next_upstream error timeout http_404 http_502 http_500;#依据状态码确定轮替，此外在 多个nginx转发情况下使用 timeout，会导致其它一些问题，简单的方式是除去timeout </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出于实际需要，需要在kong网关处进行添加自定义插件，其中逻辑需要添加自定义header，使用 ngx.request.set_header(name,value)<br>但是发现自己在网关处添加的header无法传递到(Django)后端,遍历httprequest.MEAT也没有发现，最终经过查询发现 nginx 默认(可以通过配置 underscores_in_headers  on)不允许 header name 中携带 下划线,可以除去下划线或者用’-‘代替’<em>’,但是好奇的是在网关处 带下划线的header 仍然可以使用<br>可以使用 ngx.req.get_header(name) 查询，以及在日志中也可以配置 http_name得到值，或许只是不能够传出去??</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>postgresql</title>
      <link href="/2019/06/22/psql/"/>
      <url>/2019/06/22/psql/</url>
      
        <content type="html"><![CDATA[<p>按照官网教程安装postgresql数据库<br><a href="https://www.postgresql.org/download/linux/redhat/" target="_blank" rel="noopener">https://www.postgresql.org/download/linux/redhat/</a><br>输入</p><blockquote><p>su - postgres<br>进入 postgresql 用户<br>输入<br>psql<br>进入数据库<br>输入<br>\c kong<br>切换数据库<br>输入<br>select * from pg_tables where schemaname = ‘public’;<br>查询该数据库的所有表</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go</title>
      <link href="/2019/06/22/go/"/>
      <url>/2019/06/22/go/</url>
      
        <content type="html"><![CDATA[<h2 id="go语言学习">Go语言学习</h2><h3 id="注意点">注意点</h3><h4 id="变量类型">变量类型</h4><ol><li>切片和指针都是引用类型</li><li>实际存储的字符的ascii值，没有char,取而代之的是byte(uint8),rune(int32)</li><li>raw string？？</li><li>fmt.Println 与 println的区别</li><li>list.List 与 list.New() 的[区别]](<a href="https://golang.org/pkg/container/list/" target="_blank" rel="noopener">https://golang.org/pkg/container/list/</a>)<a href="https://blog.csdn.net/xxx9001/article/details/52574501" target="_blank" rel="noopener">CSDN</a><br>list.List 返回的是一个结构体值类型,list.New()返回的是一个初始化的结构体的指针类型，区别在于1.作为函数参数传入时,list.List不可更改，而指针类型可更改2.传入参数需要与函数定义相同,即函数定义的是值类型，那么只能传入值类型</li></ol><h2 id="分布式系统学习第一弹">分布式系统学习第一弹</h2><p><a href="https://pdos.csail.mit.edu/6.824/labs/lab-1.html" target="_blank" rel="noopener">MIT 6.824</a><br>按照课程要求，下载源码<br>修改一：添加日志，在 go  init 函数更改日志格式,使得输出时带位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//init log format</span><br><span class="line">func init()&#123;</span><br><span class="line">    log.SetFlags(log.Ldate| log.Lshortfile |log.Ltime |log.LUTC)</span><br><span class="line">&#125;</span><br><span class="line">//样例输出</span><br><span class="line">2019/07/22 07:34:41 master_splitmerge.go:23: Merge: open mrtmp.test-res-0: no such file or directory</span><br></pre></td></tr></table></figure><h2 id="cache2go-学习">cache2go 学习</h2><p><a href="https://blog.csdn.net/notbaron/article/details/52008155" target="_blank" rel="noopener">项目结构 简介</a><br><a href="https://blog.csdn.net/zhizhengguan/article/details/84257338" target="_blank" rel="noopener">Go缓存库cache2go介绍</a></p><h2 id="go-语言">go 语言</h2><p>实现长度为变量的二维数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var status [][]int</span><br><span class="line">for i := 0; i &lt; len(variable1); i++ &#123;</span><br><span class="line">var statu = make([]int, len(variable2))</span><br><span class="line">status = append(status, statu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>range</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for _, num := range nums &#123;</span><br><span class="line">    sum += num</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;sum:&quot;, sum)</span><br><span class="line">//在数组上使用range将传入index和值两个变量。上面那个例子我们不需要使用该元素的序号，所以我们使用空白符&quot;_&quot;省略了。有时侯我们确实需要知道它的索引。</span><br><span class="line">for i, num := range nums &#123;</span><br><span class="line">    if num == 3 &#123;</span><br><span class="line">        fmt.Println(&quot;index:&quot;, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>make vs new</p>]]></content>
      
      
      
        <tags>
            
            <tag> MIT6.824 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统配置</title>
      <link href="/2019/06/19/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/06/19/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>安装mysql，按照官网教程来即可 <a href="https://dev.mysql.com/doc/refman/8.0/en/linux-installation-yum-repo.html" target="_blank" rel="noopener">官网连接</a><br>在 windows 下安装MySQL时会出现错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\Software\Mysql-8.0.17-winx64\bin&gt;net start MySQL</span><br><span class="line">服务没有响应控制功能。</span><br><span class="line">请键入 NET HELPMSG 2186 以获得更多的帮助。</span><br></pre></td></tr></table></figure><p>解决方法：在windows 服务控制中，设置MySQL服务的属性-&gt;登陆-&gt;登陆身份  中设置身份为此身份，身份应当有Administration权限<br>安装java</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bwg</title>
      <link href="/2019/06/17/bwg/"/>
      <url>/2019/06/17/bwg/</url>
      
        <content type="html"><![CDATA[<p>今天尝试给bwg上的vpn安装上支持 IPV4,IPV6和多端口（即监听来自IPV4,ipv6的多个端口的访问）<br>弄了半天，把多端口访问的问题，弄好了，但是同时允许IPV4，IPv6的不行，被恶心了（有空再折腾这个）<br>暂且记录下流程</p><ul><li>寻找多端口的方法；由于我的配置是基于openvpn，只能设置一个端口；多端口的话，可以安装基于python实现的shadowsocks</li><li>进行最后一步发现，都是对ssserver的配置</li><li>尝试配置监听IPV4,IPV6访问，尝试过各种配置发现，最后找到以为博主的方法，从方法逻辑上看，是可以的，但是实际中不行，可能是我的其他配置问题（例如防火墙？），但下次再折腾这个，再次列出 <a href="http://jinke.me/2015-12-20-shadowsocks/" target="_blank" rel="noopener">链接</a>,因为比较敏感，以防丢失，暂且记录下思路；大概是分别存在IPv4与ipv6的配置文件，并启动shadowsocks 分配给不同的进程</li><li>由于基于python的shadowsocks很久都没有更新了，看github上的讨论，基于c语言的shadowsocks可以实现ipv4v6共存，因而尝试安装基于c语言的shadowsocks；</li><li>发现安装shadowsocks-libev 需要很多依赖，而且依赖循环依赖，很恶心，尝试了一阵后，因为马上有事，就暂且放弃</li><li>步骤1:在https://pkgs.org/上寻找需要的centosrpm包，下载，安装 ；步骤2：重复步骤1</li><li>注意点：下载rpm包时，注意与自己服务器的系统对应（比如 我的系统是centos6，下载的7，/(ㄒoㄒ)/~~）； 留心该命令  yum install --downloadonly --downloaddir=/root/rpm <package-name> 以及<a href="https://blog.csdn.net/xuxile/article/details/88699910" target="_blank" rel="noopener">链接</a>，似乎可以避免循环依赖的问题,但是尝试失败；在使用yum repolist all 查看时发现很多源都被禁止，不知道为什么？下次有空探究下；</package-name></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> vpn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域问题小结</title>
      <link href="/2019/05/27/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/05/27/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>最近在做项目时经常遇到跨域问题，经历过这种折腾，最终有两种比较可行的方法，但总体而言都是代理转发</p><ul><li>在nginx上部署相关请求的代理转发，在将请求指向同域名的nginx服务器</li><li>将请求转发给网关，由网关做代理</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> cross_domain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务授权</title>
      <link href="/2019/05/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8E%88%E6%9D%83/"/>
      <url>/2019/05/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8E%88%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>目前准备使用外部授权认证服务与kong结合，kong可能制作简单的限流任务；<br>经过查询，发现kong在这里提供两个插件<br><a href="https://docs.konghq.com/hub/kong-inc/oauth2/" target="_blank" rel="noopener">OAuth 2.0 Authentication</a><br>和 <a href="https://docs.konghq.com/hub/kong-inc/oauth2-introspection/" target="_blank" rel="noopener">OAuth 2.0 Introspection</a><br>前者主要可以提供Oauth 认证服务，而后者支持第三方的授权认证服务器，不过仅支持企业版<br>最后找到一个github同仁自己基于 lua开发的相关插件，<a href="https://github.com/mogui/kong-external-oauth" target="_blank" rel="noopener">链接</a></p><p>安装 这个额外插件，重新启动kong 时，luarock 需要luacrypto 去完成加密相关操作，故直接即可  sudo luarocks install luacrypto（从源码配置有点麻烦）</p><p>Spring Security 源码分析系列博客<br><a href="https://niocoder.com/categories/#Security" target="_blank" rel="noopener">链接1</a><br><a href="http://www.liuhaihua.cn/%E5%8F%B2%E4%B8%8A%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84-springcloud-%E6%95%99%E7%A8%8B" target="_blank" rel="noopener">链接2</a></p><p>spring 讲解<br><a href="https://www.cnblogs.com/RunForLove/p/4641672.html" target="_blank" rel="noopener">链接1</a></p><p>spring 默认配置<br><a href="https://www.jianshu.com/p/b02691ff4093" target="_blank" rel="noopener">链接1</a></p><p>springboot+springsecurity+oauth2整合(并用mysql数据库实现持久化客户端数据 <a href="https://blog.csdn.net/Victor_An/article/details/81510874" target="_blank" rel="noopener">链接1</a></p><p>spring登录认证 与 token<br><a href="https://www.huangyunkun.com/2016/03/02/spring-security-form-to-token/" target="_blank" rel="noopener">链接1</a><br><a href="https://www.jianshu.com/p/19059060036b" target="_blank" rel="noopener">链接2</a><br><a href="https://www.jianshu.com/p/68779236aa23" target="_blank" rel="noopener">链接3</a><br><a href="https://www.cnblogs.com/xifengxiaoma/p/10043173.html" target="_blank" rel="noopener">链接4 个人觉得最详细</a><br>access_token 获取过程 <a href="https://www.cnblogs.com/lexiaofei/p/7152326.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">链接1</a></p><p>access_token 更改返回 <a href="https://www.jianshu.com/p/d9a35facff6f" target="_blank" rel="noopener">链接1</a></p><p>oauth2数据库 表的说明 <a href="https://www.cnblogs.com/donglu/articles/10218348.html" target="_blank" rel="noopener">链接1</a><br><a href="https://www.bbsmax.com/A/qVdeeNmndP/" target="_blank" rel="noopener">链接2</a><br><a href="http://www.andaily.com/spring-oauth-server/db_table_description.html" target="_blank" rel="noopener">链接3</a></p><p>oauth2 授权过程说明 来自知乎<a href="https://www.zhihu.com/question/19781476" target="_blank" rel="noopener">链接1</a><br><a href="http://andaily.com/spring-oauth-server/db_table_description.html" target="_blank" rel="noopener">链接2</a></p><p>接口测试链接(备用)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST http://localhost:8082/oauth/token?grant_type=client_credentials&amp;client_id=curl_client&amp;client_secret=user</span><br><span class="line"></span><br><span class="line">GET http://localhost:8082/oauth/check_token?grant_type=client_credentials&amp;token=445d302d-4fa1-49c4-8800-617bd72dd1e9</span><br></pre></td></tr></table></figure><p>在直接使用JdbcClientDetailsService 直接查询数据时，出现变量为null<br>即在非controller 层使用 @AUtowired时，无法取得变量<br>使用 如下方法 解决  <a href="https://blog.csdn.net/u013294097/article/details/84192367" target="_blank" rel="noopener">链接</a></p><p>error</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data too long for oauth_code column &apos;authentication&apos;</span><br><span class="line">这是在oauth服务器中获取oauth_code时往数据库插入值时，发生的意外，在网上找到许多奇奇怪怪的方法，行不通，最后发现自己在数据库oauth建表是oauth_code 表 authentication 表项为 VARBINARY 而实际应该是 LONG VARBINARY</span><br></pre></td></tr></table></figure><p>2019-5-21</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目前，打算借助oauth2 实现SSO ,利用client_credential 来识别不同系统或者应用，只不过比较困惑的是如何定义用户的权限(目前做demou先不考虑)</span><br></pre></td></tr></table></figure><p>2019-5-23<br>认证流程<br>1.系统A检测是否有token，没有跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8082/oauth/authorize?client_id=test&amp;redirect_uri=http://127.0.0.1&amp;response_type=code&amp;scope=read</span><br></pre></td></tr></table></figure><p>2.填写用户名与密码（图片不对，待更换）<br><img src="https://github.com/walkdeadtobe/picture/raw/master/code_check_token.png" alt="登录_png"><br>3.返回相应code 到系统A，系统A根据code到授权服务器申请token（部分图片错误，待更改）</p><blockquote><p>获取code<br><img src="https://github.com/walkdeadtobe/picture/raw/master/code_check_token.png" alt="获取code_png"></p></blockquote><blockquote><p>根据code获取token<br><img src="https://github.com/walkdeadtobe/picture/raw/master/code_token.png" alt="获取token_png"></p></blockquote><p>4.系统检测到token后，需要到授权系统检测该token对应的用户权限</p><blockquote><p>获取token所对应用户权限<br><img src="https://github.com/walkdeadtobe/picture/raw/master/code_check_token.png" alt="检测token_png"></p></blockquote><p>2019-7-24<br>最近涉及到单点登陆系统记住用户所登陆的系统，下次访问默认登陆,经过思考可以在cookie里面添加tag字段,在接受登陆请求之后标志所登陆的系统,下次登陆时可以以此作为标志,此外应当保证登陆另外一个系统时，字段值更改(js),这就需要后端向前端传值,由于sprig boot里传递的是modelandview 所以不采用在url链接链接里附上参数的方法，转而 controller层通过Model对象传值到对应的返回页面，返回页面获得相应的参数来做处理;<br>前端页面我 使用 thymeleaf模板引擎 渲染,其也有相应的方法取值<br>后端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/login&quot;)</span><br><span class="line">    public ModelAndView loginPage(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        RequestCache requestCache= new HttpSessionRequestCache();</span><br><span class="line">        SavedRequest savedrequest = requestCache.getRequest(request,response);</span><br><span class="line">        ModelAndView model = new ModelAndView(&quot;login&quot;);</span><br><span class="line">        model.addObject(&quot;from&quot;, &quot;all&quot;);</span><br><span class="line">       return model;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>前端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">var s_from = [[$&#123;from&#125;]];</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;p  th:text=&quot;#&#123;from&#125;&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>此外，由于需要获得服务启动时服务本身的端口号，需要配置读取 Application.yml 的配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># @ConfigurationProperties 注解依赖</span><br><span class="line">&lt;dependency&gt;  </span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  </span><br><span class="line">    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;  </span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;  </span><br><span class="line">&lt;/dependency&gt;  </span><br><span class="line"></span><br><span class="line">#Application.yml 部分内容</span><br><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line">  address: 0.0.0.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 配置类</span><br><span class="line">package com.aak.configuration;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix=&quot;server&quot;) //接收application.yml中的server下面的属性</span><br><span class="line">public class MyApplication &#123;</span><br><span class="line">    public String address;</span><br><span class="line">    public String port;</span><br><span class="line">    public String getUrl() &#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setUrl(String Url) &#123;</span><br><span class="line">        this.address = Url;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getPort() &#123;</span><br><span class="line">        return port;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setPort(String port) &#123;</span><br><span class="line">        this.port = port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#使用</span><br><span class="line">@Autowired</span><br><span class="line">private MyApplication myApplication ;</span><br><span class="line">String port=myApplication.getPort();</span><br><span class="line">log.info(&quot;port:&quot;+port);</span><br></pre></td></tr></table></figure><p>2019-8-5<br>spring security oauth2 authorization code模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[Spring Security Oauth 相关配置默认实现](https://docs.spring.io/spring-security/oauth/apidocs/org/springframework/security/oauth2/provider/endpoint/package-summary.html),其中包含(后期重新排版)</span><br><span class="line">AuthorizationEndpoint:Implementation of the Authorization Endpoint from the OAuth2 specification.</span><br><span class="line">CheckTokenEndpoint:Controller which decodes access tokens for clients who are not able to do so (or where opaque token values are used).</span><br><span class="line">DefaultRedirectResolver:Default implementation for a redirect resolver.</span><br><span class="line">ExactMatchRedirectResolver:Strict implementation for a redirect resolver which requires an exact match between the registered and requested redirect_uri.</span><br><span class="line">FrameworkEndpointHandlerMapping:A handler mapping for framework endpoints (those annotated with @FrameworkEndpoint).</span><br><span class="line">TokenEndpoint:Endpoint for token requests as described in the OAuth2 spec.</span><br><span class="line">TokenEndpointAuthenticationFilter:An optional authentication filter for the TokenEndpoint.</span><br><span class="line">TokenKeyEndpoint:OAuth2 token services that produces JWT encoded token values.</span><br><span class="line">WhitelabelApprovalEndpoint:Controller for displaying the approval page for the authorization server.</span><br><span class="line">WhitelabelErrorEndpoint:Controller for displaying the error page for the authorization server.</span><br><span class="line"></span><br><span class="line">最近需要在单点登录系统中实现在登录完成之后.跳转回系统跳转登录的页面</span><br><span class="line">code 模式下, </span><br><span class="line">1.跳转 http://localhost:8080/oauth/authorize?client_id=test2&amp;redirect_uri=http://127.0.0.1/oauth/code&amp;response_type=code&amp;scope=read</span><br><span class="line">2.登录成功之后返回code即重定向至http://127.0.0.1/oauth/code?code=CODE</span><br><span class="line">3.http://127.0.0.1/oauth/code?code=CODE获取code,传至后端,后端由此可以根据code获取token以Set-Cookie的方式返回response到页面</span><br><span class="line"></span><br><span class="line">AuthorizationEndpoint 实现 /oauth/authorize 接口,[实现流程](https://www.cnblogs.com/xifengxiaoma/p/10043173.html)中首先检验相关信息正确,之后在code模式下会生成code,并跳转回 redirect_uri?code=CODE</span><br><span class="line">最初以为需要重写 [AuthorizationEndpoint 实现](http://www.javased.com/?source_dir=spring-security-oauth/spring-security-oauth2/src/main/java/org/springframework/security/oauth2/provider/endpoint/AuthorizationEndpoint.java) 下面 /oauth/authorize 接口,使得最终重定向到redirect_uri后在链接中添加上跳转发生时来源的网址.经过调查没有找到重写 AuthorizationEndpoint 类的方法(spring security 没有提供接口,使得重写类覆盖默认类, 发生作用)</span><br><span class="line">后来发现 跳转时 是 由 window.location.href 实现的,但是无法像request请求一样 拥有 referer header ,即使能够重写 AuthorizationEndpoint 类,也不能从保存的请求中获取 相关header,只能在跳转链接中附上相关信息(暂时没有调研,是否可以在跳转的同时携带相关信息);</span><br><span class="line">问题在于 跳转回redirect_uri是在AuthorizationEndpoint 实现的,具体的地址已经配置好,而且没有找到相关的filter可以在这处理发生后拦截,进行相关逻辑处理,之后想到可以把 redirect_u redirect_uri 中,即redirect_uri=/oauth/code?back_to=原本处理code的地址</span><br><span class="line">以及可以在 跳转链接上 附上 window.location 信息(refer=window.location),然后在 login 中保存相关信息到 当前session,然后在接口中/oauth/code 接口实现中,提取出back_to和 code值,以及附上从session 获得的refer,返回,告知back_to获得token 后应当跳转的地址</span><br><span class="line">完整链接如下:</span><br><span class="line">window.location.href=&apos;http://localhost:8080/oauth/authorize?client_id=test2&amp;redirect_uri=/oauth/code?back_to=http://127.0.0.1/oauth/code&amp;response_type=code&amp;scope=read&amp;refer=&apos;+window.location</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>watch_dog</title>
      <link href="/2019/05/21/watch_dog/"/>
      <url>/2019/05/21/watch_dog/</url>
      
        <content type="html"><![CDATA[<p>由于需要某些程序一直运行，或者能够自动重启，由此接触到看门狗程序这一概念</p>]]></content>
      
      
      
        <tags>
            
            <tag> script </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring security 和 oauth 认证中涉及的环节</title>
      <link href="/2019/05/15/spring%20security%20%E5%92%8C%20oauth%20%E8%AE%A4%E8%AF%81%E4%B8%AD%E6%B6%89%E5%8F%8A%E7%9A%84%E7%8E%AF%E8%8A%82/"/>
      <url>/2019/05/15/spring%20security%20%E5%92%8C%20oauth%20%E8%AE%A4%E8%AF%81%E4%B8%AD%E6%B6%89%E5%8F%8A%E7%9A%84%E7%8E%AF%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<p>spring security 和 oauth 认证中涉及的环节<br>‘’’<br>UsernamePasswordAuthenticationToken继承AbstractAuthenticationToken实现Authentication<br>所以当在页面中输入用户名和密码之后首先会进入到UsernamePasswordAuthenticationToken验证(Authentication)，<br>然后生成的Authentication会被交由AuthenticationManager来进行管理<br>而AuthenticationManager管理一系列的AuthenticationProvider，<br>而每一个Provider都会通UserDetailsService和UserDetail来返回一个<br>以UsernamePasswordAuthenticationToken实现的带用户名和密码以及权限的Authentication<br>url= <a href="https://www.cnblogs.com/softidea/p/6716807.html" target="_blank" rel="noopener">https://www.cnblogs.com/softidea/p/6716807.html</a><br>‘’’</p>]]></content>
      
      
      
        <tags>
            
            <tag> oauth + spring security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维</title>
      <link href="/2019/05/15/%E8%BF%90%E7%BB%B4/"/>
      <url>/2019/05/15/%E8%BF%90%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<p>为了测试整个系统的稳定性，写了一个脚本，模仿整个登录过程，中间出错就报错<br>了解到一个好工具 selenium<br><a href="https://blog.csdn.net/wkb342814892/article/details/81591394" target="_blank" rel="noopener">如何在centos上安装使用selenium-1</a><br><a href="https://www.bbsmax.com/A/A2dmRBKWze/" target="_blank" rel="noopener">如何在centos上安装使用selenium-2</a></p><p>为了更为精确的监控网页，考虑使用selenium模拟打开每个页面去检查其中网络请求是否正常获得，最终的目标是获取类似chrome开发者模式中Network中的效果，但是经调查发现，selenium中没有对这部分进行实现(或者与其最初目标无关，不考虑实现)，找到的可行的方案是使用 selenium + browsermob-proxy,<br><a href="https://browsermob-proxy-py.readthedocs.io/en/latest/" target="_blank" rel="noopener">browsermob-proxy 官方文档</a><br><a href="https://github.com/webmetrics/browsermob-proxy/downloads" target="_blank" rel="noopener">browsermob-proxy 下载</a></p><p><a href="https://stackoverflow.com/questions/48979520/chrome-headless-proxy-server" target="_blank" rel="noopener">示例代码</a></p><p>记录下中间遇到的问题：</p><blockquote><ol><li>端口冲突，报错</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;use_for_temporary.py&quot;, line 160, in &lt;module&gt;</span><br><span class="line">    selenium_example()</span><br><span class="line">  File &quot;use_for_temporary.py&quot;, line 81, in selenium_example</span><br><span class="line">    proxy=server.create_proxy()</span><br><span class="line">  File &quot;/root/anaconda3/lib/python3.7/site-packages/browsermobproxy/server.py&quot;, line 40, in create_proxy</span><br><span class="line">    client = Client(self.url[7:], params)</span><br><span class="line">  File &quot;/root/anaconda3/lib/python3.7/site-packages/browsermobproxy/client.py&quot;, line 38, in __init__</span><br><span class="line">    self.port = jcontent[&apos;port&apos;]</span><br><span class="line">KeyError: &apos;port&apos;</span><br></pre></td></tr></table></figure><p>经过查看源码，大约猜测是网络端口的问题(后来发现在产生的server.log 中把问题说的很清楚 ( ╯□╰ ))，查看相关文档确定 browsermob-proxy 启动的端口默认是8080 <a href="https://cloud.tencent.com/developer/news/365789" target="_blank" rel="noopener">相关文档</a> ,而服务器中已经使用的端口包括这个，考虑更改其启动的配置参数，按照上述文档的方法下修改，无效报错，经过查看与browsermob-proxy 版本对应 的官方文档<a href="https://browsermob-proxy-py.readthedocs.io/en/latest/server.html" target="_blank" rel="noopener">Server 初始化</a> 以及相应解析源码，重新修改配置<br>为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server=Server(&quot;/root/download/browsermob-proxy-2.0-beta-6/bin/browsermob-proxy&quot;,&#123;&quot;host&quot;:&quot;localhost&quot;,&quot;port&quot;:9000&#125;)</span><br></pre></td></tr></table></figure><p>成功</p><blockquote><ol start="2"><li>文件引用问题</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;use_for_temporary.py&quot;, line 159, in &lt;module&gt;</span><br><span class="line">    selenium_example()</span><br><span class="line">  File &quot;use_for_temporary.py&quot;, line 79, in selenium_example</span><br><span class="line">    server.start()</span><br><span class="line">  File &quot;/root/anaconda3/lib/python3.7/site-packages/browsermobproxy/server.py&quot;, line 122, in start</span><br><span class="line">    raise ProxyServerError(message)</span><br><span class="line">browsermobproxy.exceptions.ProxyServerError: The Browsermob-Proxy server process failed to start. Check &lt;_io.TextIOWrapper name=&apos;/root/py_auto/Gateway_auto/server.log&apos; mode=&apos;w&apos; encoding=&apos;UTF-8&apos;&gt;for a helpful error message.</span><br><span class="line"># server.log</span><br><span class="line">错误: 找不到或无法加载主类 org.browsermob.proxy.Main</span><br></pre></td></tr></table></figure><p>原因：我将browsermob-proxy解压后，将其中bin目录下browsermobproxy专门提取出来，放在一个专门目录下(以为是可执行文件)，引用之，后来发现它和windows下使用的browsermobproxy.bat 一样都是个脚本文件，需要在项目的固定位置<br>解决：将引用目录指向目录文件下的browsermobproxy</p><blockquote><ol start="3"><li>工具版本适配问题</li></ol></blockquote><p>问题：使用browsermob-proxy +selenium 时候，出现网络请求异常，在查看browsermob-proxy 产生的har记录文件时发现某些网路请求异常，返回-999(no response)或者0,不是正常的返回，但是单独用requests 模块去做请求时，又没有问题，于是考虑是因为webdriver结束过早，考虑过强制sleep,以及 driver.implict_wait(),但是都起不到作用，或者不够明显。<br>后来思考了下，我想要做的事情是判断页面是否加载正常，静态数据大多没有太多问题，主要是动态数据，即我所关注或者担心的大部属分请求都是ajax异步请求，前面那些方法可能没有太多作用，于是查找是否有有相关手段使selenium 等待所有ajax请求结束，其中提到了selenium的三种等待方式：强制等待(sleep等方法)，隐式等待(driver.implict_wait(),全局效果)，显式等待(在一定时间内等待某一元素的出现)<br>最终采取的是第三种方法，</p><blockquote><p>WebDriverWait(driver, 30).until(lambda s: s.execute_script(“return jQuery.active == 0”))</p></blockquote><p>参考<a href="https://www.cnblogs.com/aoyede/articles/5804184.html" target="_blank" rel="noopener">博客</a></p><p>但是在centos服务器上加上这行代码会出现<br>jQuery/$(如果使用 $.active)  no defined<br>最开始考虑类似与之前的方法，是因为这段脚本在jQuery加载之前执行引起的错误，后来尝试过强制等待后添加这行代码，无论等待多长时间都没有效果 ,开始怀疑是因为服务器环境的特殊性，于是在window笔记本,ubuntu台式机上尝试都没有异常，然后开始怀疑是环境配置的问题，其中包含的环境配置主要有selenium ,chromdriver,google-chrome,browsermob-proxy<br>由于selenium都是用pip安装的最新的，不考虑<br>然后发现centos服务器上的google-chrome是最新版76.0.3809.12   ,而windows上是75.0.3770.8，ubuntu上chromium是 v74.0.3729.6然后依据windowsde 配置调整了chromdriver,google-chrome的配置，但是仍然没有效果，最后发现centos 上的browsermob-proxy 是2.0-beta版本，而其他两个是2.14版本，最后调整之后，发现运行没有问题(暂时弄不明白为什么)<br>记录下正确的版本配置：<br>selenium: 3.141.0<br>chromdriver:75.0.3770.90<br>google-chrome: 75.0.3770.142<br>browsermob-proxy:2.1.4</p><blockquote><p>日志增长的问题</p></blockquote><p>考虑到网关日志增长过大的可能性，考虑到使用脚本定期定量切割日志,重命名，创建新文件，后来发现linux系统中有现成工具 logrotate 可以对日志进行切割，里面的配置完全可以满足个人需求<br>可以使用 man  logrotate 查看配置信息 或者  <a href="https://linux.die.net/man/8/logrotate" target="_blank" rel="noopener">logrotate Linxu 官网档案</a></p><blockquote><p>个人配置</p></blockquote><pre><code>位置：/etc/logrotate.d/kong<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/kong/logs/access.log &#123;</span><br><span class="line">    missingok</span><br><span class="line">    rotate 200</span><br><span class="line">    size 10M</span><br><span class="line">    compress</span><br><span class="line">    delaycompress</span><br><span class="line">    notifempty</span><br><span class="line">    create 644 root root</span><br><span class="line">    dateext</span><br><span class="line">    sharedscripts</span><br><span class="line">    postrotate</span><br><span class="line">            if [ -f /var/run/nginx.pid ]; then</span><br><span class="line">                    kill -USR1 `cat /usr/local/kong/pids/nginx.pid`</span><br><span class="line"></span><br><span class="line">            fi</span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>原本为 cat /var/run/nginx.pid 后来发现,kong的pid信息存放在/usr/local/kong/pids/nginx.pid<br>kill -USR1 在这里指重新加载配置信息，重新建立对日志文件的连接<br>详情 man kill/kill -l 或者查看 <a href="http://www.man7.org/linux/man-pages/man2/kill.2.html" target="_blank" rel="noopener">Linux kill 文档</a>  [Linux  signal 文档](<a href="http://www.man7.org/linux/man-pages/man7/signal.7.html" target="_blank" rel="noopener">http://www.man7.org/linux/man-pages/man7/signal.7.html</a></p><p>包装 elastisearch API接口，简化经网关转发提供给外部使用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/index.html" target="_blank" rel="noopener">Elastisearch 官网开放API 文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">获取某一时间 ddj 服务的访问次数</span><br><span class="line">GET /_count</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">      &quot;bool&quot;:&#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">                &quot;range&quot;: &#123;</span><br><span class="line">                  &quot;@timestamp&quot;: &#123;</span><br><span class="line">                    &quot;gte&quot;: &quot;now-100h/h&quot;,</span><br><span class="line">                    &quot;lte&quot;: &quot;now/h&quot;,</span><br><span class="line">                    &quot;format&quot;: &quot;epoch_millis&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            ,</span><br><span class="line">        &quot;must&quot;: &#123;</span><br><span class="line">                &quot;match&quot;: &#123;</span><br><span class="line">                  &quot;request&quot;: &#123;</span><br><span class="line">                    &quot;query&quot;: &quot;*ddj*&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">获取某一时间 ddj 服务的访问信息，相比于上者更为详细</span><br><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">      &quot;bool&quot;:&#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">                &quot;range&quot;: &#123;</span><br><span class="line">                  &quot;@timestamp&quot;: &#123;</span><br><span class="line">                    &quot;gte&quot;: &quot;now-100h/h&quot;,</span><br><span class="line">                    &quot;lte&quot;: &quot;now/h&quot;,</span><br><span class="line">                    &quot;format&quot;: &quot;epoch_millis&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            ,</span><br><span class="line">        &quot;must&quot;: &#123;</span><br><span class="line">                &quot;match&quot;: &#123;</span><br><span class="line">                  &quot;request&quot;: &#123;</span><br><span class="line">                    &quot;query&quot;: &quot;*ddj*&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,&quot;aggs&quot;: &#123;</span><br><span class="line">            &quot;dateAgg&quot;: &#123;</span><br><span class="line">              &quot;date_histogram&quot;: &#123;</span><br><span class="line">                &quot;field&quot;: &quot;@timestamp&quot;,</span><br><span class="line">                &quot;time_zone&quot;: &quot;Europe/Amsterdam&quot;,</span><br><span class="line">                &quot;interval&quot;: &quot;1m&quot;,</span><br><span class="line">                &quot;min_doc_count&quot;: 1</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来想自己开发一个插件，似乎<a href="https://docs.konghq.com/hub/" target="_blank" rel="noopener">Kong Hub</a>上提供的第三方插件 <a href="https://docs.konghq.com/hub/stone-payments/kong-plugin-template-transformer/" target="_blank" rel="noopener">Template Transformer</a> 可以满足需要，<a href="https://github.com/stone-payments/kong-plugin-template-transformer" target="_blank" rel="noopener">源码</a>可以观摩下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:8001/routes/4f240596-9f55-4b90-a2be-2329be72391e/plugins --data &quot;name=kong-plugin-template-transformer&quot;   --data &quot;config.request_template=&apos; &#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">      &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">                &quot;range&quot;: &#123;</span><br><span class="line">                  &quot;@timestamp&quot;: &#123;</span><br><span class="line">                    &quot;gte&quot;: &quot;now-&#123;&#123;headers.gt&#125;&#125;h/h&quot;,</span><br><span class="line">                    &quot;lte&quot;: &quot;now/h&quot;,</span><br><span class="line">                    &quot;format&quot;: &quot;epoch_millis&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            ,</span><br><span class="line">        &quot;must&quot;: &#123;</span><br><span class="line">                &quot;match&quot;: &#123;</span><br><span class="line">                  &quot;request&quot;: &#123;</span><br><span class="line">                    &quot;query&quot;: &quot;*&#123;&#123;headers.department&#125;&#125;*&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&quot;</span><br><span class="line">&#123;&quot;query&quot;:&#123;&quot;bool&quot;:&#123;&quot;filter&quot;: &#123;&quot;range&quot;: &#123;&quot;@timestamp&quot;:&#123;&quot;gte&quot;: &quot;now-&#123;&#123;headers.gt&#125;&#125;h/h&quot;,&quot;lte&quot;: &quot;now/h&quot;,&quot;format&quot;: &quot;epoch_millis&quot;&#125;&#125;&#125;&#125;&#125;,&quot;size&quot;:0,&quot;aggs&quot;:&#123;&quot;test&quot;:&#123;&quot;terms&quot;:&#123; &quot;field&quot;: &quot;user.keyword&quot;,&quot;size&quot;:&#123;&#123;headers.size&#125;&#125;&#125;&#125;&#125;&#125;&quot;</span><br><span class="line">/api/v1/data/es/list_user</span><br><span class="line">curl -X POST http://localhost:8001/routes/&#123;route&#125;/plugins --data &quot;name=kong-plugin-template-transformer&quot;   --data</span><br><span class="line">&quot;config.request_template=&#123;</span><br><span class="line">      \&quot;query\&quot;: &#123;</span><br><span class="line">        \&quot;bool\&quot;: &#123;</span><br><span class="line">          \&quot;filter\&quot;: &#123;</span><br><span class="line">            \&quot;range\&quot;: &#123;</span><br><span class="line">              \&quot;@timestamp\&quot;: &#123;</span><br><span class="line">                \&quot;gte\&quot;: \&quot;now-&#123;&#123;headers.gt&#125;&#125;h/h\&quot;,</span><br><span class="line">                \&quot;lte\&quot;: \&quot;now/h\&quot;,</span><br><span class="line">                \&quot;format\&quot;: \&quot;epoch_millis\&quot;</span><br><span class="line">                &#125;</span><br><span class="line">               &#125;</span><br><span class="line">              &#125;</span><br><span class="line">             &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">      \&quot;size\&quot;:0,  </span><br><span class="line">      \&quot;aggs\&quot;: &#123;</span><br><span class="line">        \&quot;test\&quot;:&#123;</span><br><span class="line">          \&quot;terms\&quot;:&#123; </span><br><span class="line">          \&quot;field\&quot;: \&quot;user.keyword\&quot;,</span><br><span class="line">          \&quot;size\&quot;:&#123;&#123;headers.size&#125;&#125;</span><br><span class="line">          &#125; </span><br><span class="line">         &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;&quot;</span><br><span class="line"></span><br><span class="line">/api\/v1\/data\/es\/history</span><br><span class="line">curl -X POST http://localhost:8001/routes/&#123;route&#125;/plugins --data &quot;name=kong-plugin-template-transformer&quot;   --data</span><br><span class="line">&quot;config.request_template=&#123;</span><br><span class="line">  \&quot;size\&quot;: &#123;&#123;headers.size&#125;&#125;,</span><br><span class="line">  \&quot;query\&quot;: &#123;</span><br><span class="line">    \&quot;bool\&quot;: &#123;</span><br><span class="line">      \&quot;must\&quot;: [</span><br><span class="line">        &#123; \&quot;match\&quot;: &#123;  \&quot;user\&quot;: \&quot;&#123;&#123;headers.name&#125;&#125;\&quot;  &#125; &#125;, </span><br><span class="line">        &#123; \&quot;match\&quot;: &#123; \&quot;_index\&quot;:\&quot;system-syslog*\&quot; &#125; &#125;]    </span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;,</span><br><span class="line">  \&quot;_source\&quot;: &#123;</span><br><span class="line">    \&quot;includes\&quot;: [\&quot;@timestamp\&quot;,\&quot;referer\&quot;,\&quot;request\&quot;,\&quot;user\&quot;]</span><br><span class="line">    &#125;,  </span><br><span class="line">  \&quot;sort\&quot;: [</span><br><span class="line">    &#123;\&quot;@timestamp\&quot;:&#123;\&quot;order\&quot;:\&quot;desc\&quot; ,\&quot;unmapped_type\&quot;:\&quot;date\&quot; &#125; &#125;,    </span><br><span class="line">    &#123;\&quot;_score\&quot;:&#123;\&quot;order\&quot;:\&quot;asc\&quot; &#125; &#125;  </span><br><span class="line">    ]</span><br><span class="line">    &#125;&quot;</span><br></pre></td></tr></table></figure><p>2019-9-24  更改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST   --url http://localhost:8001/services/-search/routes  --data &apos;paths=/api/v1/data/es/history&apos;</span><br><span class="line">curl -X POST http://localhost:8001/routes/&#123;route_id&#125;/plugins --data &quot;name=kong-plugin-template-transformer&quot;   --data &quot;config.request_template=&#123;</span><br><span class="line">    \&quot;query\&quot;: &#123;</span><br><span class="line">      \&quot;bool\&quot;: &#123;</span><br><span class="line">      \&quot;filter\&quot;: &#123;</span><br><span class="line">                \&quot;range\&quot;: &#123;</span><br><span class="line">                  \&quot;@timestamp\&quot;: &#123;</span><br><span class="line">                    \&quot;gte\&quot;: \&quot;now-&#123;&#123;headers.gt&#125;&#125;h/h\&quot;,</span><br><span class="line">                    \&quot;lte\&quot;: \&quot;now/h\&quot;,</span><br><span class="line">                    \&quot;format\&quot;: \&quot;epoch_millis\&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            ,</span><br><span class="line">        \&quot;must\&quot;: &#123;</span><br><span class="line">                \&quot;match\&quot;: &#123;</span><br><span class="line">                  \&quot;request\&quot;: &#123;</span><br><span class="line">                    \&quot;query\&quot;: \&quot;*&#123;&#123;headers.department&#125;&#125;*\&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST   --url http://localhost:8001/services/-search/routes  --data &apos;paths=/api/v1/data/es/history&apos;</span><br><span class="line">&#123;</span><br><span class="line">  \&quot;size\&quot;: &#123;&#123;headers.size&#125;&#125;,</span><br><span class="line">  \&quot;query\&quot;: &#123;</span><br><span class="line">   \&quot;bool\&quot;: &#123;</span><br><span class="line">      \&quot;must\&quot;: [</span><br><span class="line">        &#123; \&quot;match\&quot;: &#123;  \&quot;user\&quot;: \&quot;&#123;&#123;headers.name&#125;&#125;\&quot;  &#125; &#125;,</span><br><span class="line">        &#123; \&quot;match\&quot;: &#123; \&quot;_index\&quot;:\&quot;system-syslog*\&quot; &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  \&quot;_source\&quot;: &#123;</span><br><span class="line">    \&quot;includes\&quot;: [</span><br><span class="line">     \&quot;@timestamp\&quot;,</span><br><span class="line">      \&quot;referer\&quot;,</span><br><span class="line">      \&quot;request\&quot;,</span><br><span class="line">      \&quot;user\&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  \&quot;sort\&quot;: [</span><br><span class="line">    &#123;\&quot;@timestamp\&quot;:&#123;\&quot;order\&quot;:\&quot;desc\&quot; ,\&quot;unmapped_type\&quot;:\&quot;date\&quot; &#125; &#125;,</span><br><span class="line">    &#123;\&quot;_score\&quot;:&#123;\&quot;order\&quot;:\&quot;asc\&quot; &#125; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST   --url http://localhost:8001/services/-search/routes  --data &apos;paths=/api/v1/data/es/list_user&apos;</span><br><span class="line">curl -X POST http://localhost:8001/routes/ad0226f7-0877-4557-b81b-f30cd227cf61/plugins --data &quot;name=kong-plugin-template-transformer&quot;   --data &quot;config.request_template=&#123;</span><br><span class="line">    \&quot;query\&quot;: &#123;</span><br><span class="line">      \&quot;bool\&quot;: &#123;</span><br><span class="line">      \&quot;filter\&quot;: &#123;</span><br><span class="line">                \&quot;range\&quot;: &#123;</span><br><span class="line">                  \&quot;@timestamp\&quot;: &#123;</span><br><span class="line">                    \&quot;gte\&quot;: \&quot;now-&#123;&#123;headers.gt&#125;&#125;h/h\&quot;,</span><br><span class="line">                    \&quot;lte\&quot;: \&quot;now/h\&quot;,</span><br><span class="line">                    \&quot;format\&quot;: \&quot;epoch_millis\&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">  \&quot;size\&quot;:0,</span><br><span class="line">  \&quot;aggs\&quot;: &#123;</span><br><span class="line">    \&quot;test\&quot;: &#123;</span><br><span class="line">      \&quot;terms\&quot;: &#123;</span><br><span class="line">        \&quot;field\&quot;: \&quot;user.keyword\&quot;,</span><br><span class="line">        \&quot;size\&quot;:&#123;&#123;headers.size&#125;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&quot;</span><br></pre></td></tr></table></figure><p>luarocks make<br>luarocks pack kong-plugin-myplugin 0.1.0-1<br>luarocks install kong-plugin-myplugin-0.1.0-1.all.rock<br>kong restart</p>]]></content>
      
      
      
        <tags>
            
            <tag> python,爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>authen_server</title>
      <link href="/2019/05/14/authen-server/"/>
      <url>/2019/05/14/authen-server/</url>
      
        <content type="html"><![CDATA[<p>2019-5-14 尝试将spring oauth server安装到 实验室服务器上（虽然是初版），做一下记录<br>如何用idea 打包 maven项目<br>‘’’<br>用idea中maven 打开项目，点击idea 右侧的 Maven Projects，<br>点击 LIfecycle -&gt; install -&gt; run maven build 即可<br>‘’’<br>之后 将该项目scp至服务器<br>使用 java -jar *.jar 运行<br>在运行时出现一些错误，如下</p><p>‘’’<br>2019-05-14 17:06:35.986 ERROR 1180706 — [ost-startStop-1] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Exception during pool initialization.</p><p>com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure</p><p>The last packet successfully received from the server was 199 milliseconds ago.  The last packet sent successfully to the server was 192 milliseconds ago.<br>at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ~[na:1.8.0_181]<br>at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) ~[na:1.8.0_181]<br>…<br>…<br>… 154 common frames omitted<br>Caused by: java.security.cert.CertPathValidatorException: Path does not chain with any of the trust anchors<br>at sun.security.provider.certpath.PKIXCertPathValidator.validate(PKIXCertPathValidator.java:154) ~[na:1.8.0_181]<br>at sun.security.provider.certpath.PKIXCertPathValidator.engineValidate(PKIXCertPathValidator.java:80) ~[na:1.8.0_181]<br>at java.security.cert.CertPathValidator.validate(CertPathValidator.java:292) ~[na:1.8.0_181]<br>at com.mysql.jdbc.ExportControlled$X509TrustManagerWrapper.checkServerTrusted(ExportControlled.java:295) ~[mysql-connector-java-5.1.46.jar!/:5.1.46]<br>… 156 common frames omitted</p><p>‘’’<br>经查询(<a href="https://www.jianshu.com/p/b3151ca89def" target="_blank" rel="noopener">https://www.jianshu.com/p/b3151ca89def</a> ）发现是因为SSL配置的原因（暂时没有细究），在源代码 application.yml 文件中将useSSL=true 改为 false即可，重新打包，scp，运行</p><p>在查询过程中发现之后可能会出现的另一个问题，即在长时间未连接mysql时会报类似的 Communications link failure 错误，不过这里是因为mysql默认配置 无连接最长等待时间是8小时，可以通过修改配置文件 mysql.ini 去解决这个错误</p><p>在此之前需要在服务器安装mysql<br>按照官网教程(下面的是Ubuntu下的，如果安装在redhat上，会有一些区别 ，具体参照官方教程 <a href="https://dev.mysql.com/doc/mysql-yum-repo-quick-guide/en/" target="_blank" rel="noopener">https://dev.mysql.com/doc/mysql-yum-repo-quick-guide/en/</a>)</p><ul><li>wget <a href="https://dev.mysql.com/get/mysql-apt-config_0.8.13-1_all.deb" target="_blank" rel="noopener">https://dev.mysql.com/get/mysql-apt-config_0.8.13-1_all.deb</a></li><li>也可以选择检查 文件传输中是否出错 md5sum mysql-apt-config_0.8.13-1_all.deb</li><li>之后运行 dpkg -i mysql-apt-config_0.8.13-1_all.deb，选择你所需要安装的mysql版本，程序会将之添加到apt源中</li><li>运行 sudo apt-get update （–fix-missing）</li><li>自动下载之后需要配置用户名与密码，需要与你在spring程序中配置的一致</li></ul><p>进入数据库 mysql -u root -p ,之后输入密码</p>]]></content>
      
      
      
        <tags>
            
            <tag> oauth </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Machine_learning_course</title>
      <link href="/2019/05/01/Machine_learning_course/"/>
      <url>/2019/05/01/Machine_learning_course/</url>
      
        <content type="html"><![CDATA[<p>2019-5-10<br>机器学习布置作业，6-15前交，内容未知<br>基于主成分分析方法的人脸识别方法</p><ul><li>之前是寻找空间特征，某一局部点</li><li>人脸识别的核心问题是提取特征(人脸的相关性打，冗余信息多？如何去除：主成分分析，如何将一个矩阵变成一个向量)</li><li>PCA方法的优缺点：从压缩能量的角度，PCA是最有效率的，可以用于维度压缩</li><li>PCA  FisherDiscriminant analysis or LDA</li><li>kErnel PCA</li><li>KFDA</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP</title>
      <link href="/2019/04/28/NLP/"/>
      <url>/2019/04/28/NLP/</url>
      
        <content type="html"><![CDATA[<p>2019-4-28 周日下午<br>NLP aligment</p>]]></content>
      
      
      
        <tags>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人脸识别</title>
      <link href="/2019/04/27/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
      <url>/2019/04/27/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>PCA方法学习：解释得比较清楚<br><a href="https://blog.csdn.net/qq_32865355/article/details/80809835" target="_blank" rel="noopener">https://blog.csdn.net/qq_32865355/article/details/80809835</a></p><p>github 开源方案<br><a href="https://github.com/ahhda/Face-Recogntion" target="_blank" rel="noopener">https://github.com/ahhda/Face-Recogntion</a><br><a href="https://github.com/ageitgey/face_recognition" target="_blank" rel="noopener">https://github.com/ageitgey/face_recognition</a></p><p>相关论文<br><a href="https://blog.csdn.net/tMb8Z9Vdm66wH68VX1/article/details/83155487" target="_blank" rel="noopener">https://blog.csdn.net/tMb8Z9Vdm66wH68VX1/article/details/83155487</a></p><p>CNN 实现 人脸识别<br><a href="https://blog.csdn.net/u012162613/article/details/43277187" target="_blank" rel="noopener">https://blog.csdn.net/u012162613/article/details/43277187</a><br><a href="https://blog.csdn.net/zouxy09/article/details/8781543" target="_blank" rel="noopener">https://blog.csdn.net/zouxy09/article/details/8781543</a></p><p>相关github 代码<br><a href="https://github.com/wepe/MachineLearning" target="_blank" rel="noopener">https://github.com/wepe/MachineLearning</a></p><p>faceCascade.detectMultiScale 从图像中找出人脸<br>theano.shared可以看作是将变量设置为全局变量，其值可以在多个函数中共用<br>theano.tensor.dot(X, Y) 简单的看做XY 矩阵相乘 或者说 内积<br>maxpooling 、average_pooling ？？</p><p>tensor库函数解释<br><a href="http://deeplearning.net/software/theano/library/tensor/basic.html" target="_blank" rel="noopener">http://deeplearning.net/software/theano/library/tensor/basic.html</a></p><p>损失函数的分类（交叉熵） <a href="https://www.jianshu.com/p/47172eb86b39" target="_blank" rel="noopener">https://www.jianshu.com/p/47172eb86b39</a></p><p>神经网络 数学公式 表达 <a href="https://blog.csdn.net/sinat_35821976/article/details/80615612" target="_blank" rel="noopener">https://blog.csdn.net/sinat_35821976/article/details/80615612</a></p><p>分类器用的是softmax  <a href="https://www.cnblogs.com/python-frog/p/9380290.html" target="_blank" rel="noopener">https://www.cnblogs.com/python-frog/p/9380290.html</a><br>，LeNet5用的是rbf？？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 模式识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>决策树</title>
      <link href="/2019/04/27/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
      <url>/2019/04/27/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>今天上课提及了决策树，随机森林，Dropout，Deepforest(周志华)<br>目前而言，决策树指对于一个集合，依此以某种确定特征作为分类标准，从而将该集合分为若干类(每个节点都代表一个分类或者一种决策标准)<br>随机森林，指在每个节点，随机选择某个特征从而构建一个线性分类器，将样本分为几部分</p><p>Boosted Cascades VS 随机森林<br>前者是一个不平衡的树，适合不均匀的分类问题</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>slice_window</title>
      <link href="/2019/04/23/slide_window/"/>
      <url>/2019/04/23/slide_window/</url>
      
        <content type="html"><![CDATA[<p>返回滑动窗口的最大值(考虑极端情况起码考虑 空 )<br>给定一个输入序列（数组)，返回窗口范围内的最大值，每次移动一次窗口，并返回一个最大值</p><ul><li>方法1：大顶堆（MaxHeap）  删除离开的元素，加入新的元素，排序  时间复杂度<br>$$ N log^{k} $$</li><li>deque(双端 Queue)</li><li>–入队列</li><li>–维护队列：对于长度为K 的窗口，将窗口范围内最大值之前的数全部删除（忽略），因为在最大值之前的数必然不会成为最大值</li></ul><ul>  <li>JavaScript    <ol>      <li>        第一章        <ul>          <li>const</li>          <li>let</li>        </ul>      </li>      <li>        第二章sdisjfosdklsjfkdddddldddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd        <ul>          <li>function</li>          <li>object</li>        </ul>      </li>    </ol>  </li>  <li>Java    <ol>      <li>        第一章        <ul>          <li>class</li>          <li>package</li>        </ul>      </li>      <li>        第二章        <ul>          <li>private</li>          <li>public</li>        </ul>      </li>    </ol>  </li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map_and_set</title>
      <link href="/2019/04/23/map_and_set/"/>
      <url>/2019/04/23/map_and_set/</url>
      
        <content type="html"><![CDATA[<p>哈希函数，哈希表，哈希碰撞(单个节点变成链表来解决：拉链法)<br>List VS Map VS Set</p><ul><li>List：由数组或者链表实现，插入O(1)，查找O(N)，可重复</li><li>Map ：键值对Key-value</li><li>Set :用哈希表或者二叉树实现；相对于List不允许重复</li></ul><p>HashMap VS TreeMap<br>HashSet VS TreeSet<br>在查询时，哈希表实现 O(1) ，Tree实现 O(log_{n})<br>但是 哈希表的实现是无序的，而树的实现是有序的</p><p>题目：242（Leetcode） Valid Anagrant<br>题意：对给定的两个字符串，判断是否是同一单词的错位变换</p><ul><li>方法1：给两个字符串排序，判断是否相同 算法复杂度 ：<br>$$ O(Nlog^N) $$</li><li>方法2：构造Map，比较Map是否相同算法复杂度<br>$$ O(N) $$</li></ul><p>题目：Two Sum(Three Sum)<br>题意：给定一个数组，以及value，输出数组中和为value的元素下标</p><ul><li>方法1：暴力方法时间复杂度<br>$$<br>O(N^2)<br>$$</li><li>方法2：Set;对于数组的任意元素x，如果元素 value-x 存在，则输出 时间复杂度<br>$$<br>O(N)<br>$$</li></ul><p>那么对于ThreeSum</p><ul><li>方法1：暴力 时间复杂度<br>$$<br>O(N^3)<br>$$</li><li>方法2：枚举a+b,在Set里查询c 时间复杂度<br>$$<br>O(N^2)<br>$$</li><li>方法3：首先排序，枚举a,在剩下的子数组中，b和c各位于最左和最右，根据a+b+c&gt;0/&lt;0 ,来判断移动b或者c 虽然空间复杂度是常数级别的，但修改了原数组 ，时间复杂度<br>$$<br>O(N^2)<br>$$</li><li>方法4：应用ThreeSum的方法,递归(4=1+3;3=1+2) 时间复杂度<br>$$<br>O(N^2)<br>$$</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小技巧总结</title>
      <link href="/2019/04/22/%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
      <url>/2019/04/22/%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>1.git commit 由于没有添加 -m 而进入 vim界面，无法退出，在一个博文找到方法（<a href="https://blog.csdn.net/weixin_42197191/article/details/87015837%EF%BC%89" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42197191/article/details/87015837）</a><br>Ctrl + v + 命令键 实现命令</p><p>2.由于两个电脑同时修改自己的blog markdown文件，导致文件有差异，如何解决，暂时没有找到思路，将某一个电脑的master回退，会导致他的修改丢失（或者提前保存其修改，或许这就是多分支存在的理由）<br>git log 查看最近commit的记录<br>git reset --hard (HEAD～n)/(commit_id)   会退到当前(之前的n个提交记录)/(在git log 中的某个提交记录)<br>git push --force 将当前分支提交<br>it branch --set-upstream-to=<remote origin>/<remote branch> <local branch>  绑定当前本地分支与某个远程分支</local></remote></remote></p><ol start="3"><li>获得 包含某个字符串的进程ID 并且将之作为参数，删除相应进程<br>kill -9 $(ps -ef|grep id | grep -v grep|awk ‘{print $2}’ )。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>manacher</title>
      <link href="/2019/04/22/manacher/"/>
      <url>/2019/04/22/manacher/</url>
      
        <content type="html"><![CDATA[<p>马拉车算法，解决最大回文串问题，有点意思，感觉有点像KMP算法</p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理</title>
      <link href="/2019/04/22/%E4%BB%A3%E7%90%86/"/>
      <url>/2019/04/22/%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>代理给通信带来更多的功能</p><ul><li>拦截：代理可以选择性拦截传输的网络流量，比如一些公司限制员工在上班的时候不能访问某些游戏或者电商网站，再比如把我们和世界隔离开来的 GFW，还有在数据中心中拒绝恶意访问的网关。</li><li>统计：既然所有的流量都经过代理，那么代理也可以用来统计网络中的数据信息，比如了解哪些人在访问哪些网站，通信的应答延迟等。</li><li>缓存：如果通信双方比较”远“，访问比较慢，那么代理可以把最近访问的数据缓存在本地，后面的访问不用访问后端来做到加速。CDN 就是这个功能的典型场景。</li><li>分发(负载均衡)：如果某个通信方有多个服务器后端，代理可以根据某些规则来选择如何把流量发送给多个服务器，也就是我们常说的负载均衡功能，比如著名的 Nginx 软件。</li><li>跳板：如果 A、B 双方因为某些原因不能直接访问，而代理可以和双方通信，那么通过代理，双方可以绕过原来的限制进行通信。VPN，内网穿透。</li><li>注入：既然代理可以看到流量，那么它也可以修改网络流量，可以自动在收到的流量中添加一些数据，比如有些宽带提供商的弹窗广告。</li></ul><p>ssr速度不行安装v2ray<br>参考<a href="https://www.stackcc.com/2019/04/02/v2raysetup/" target="_blank" rel="noopener">网站1</a><a href="https://tlanyan.me/v2ray-tutorial/" target="_blank" rel="noopener">网站2</a><br><a href="https://www.hijk.pw/v2rayn-config-tutorial/" target="_blank" rel="noopener">网站3</a></p><p><a href="https://www.v2rayssr.com/v2raynginx.html" target="_blank" rel="noopener">V2RAY+Nginx+Ws+Tls+Host+Path</a></p><ol><li>域名购买：<a href="https://dcc.godaddy.com/" target="_blank" rel="noopener">狗爹</a><br>[godaddy 域名解析]whetstone.xyz</li></ol><p>export CF_Token=“0gE0NDS31pewoA8ykVN2CqQXC_kKxcp5C2yp_ZNn”</p><p><a href="http://acme.sh" target="_blank" rel="noopener">acme.sh</a> --issue --dns dns_cf -d whetstone.xyz -d www.whetstone.xyz -k ec-256<br>cat ~/.acme.sh/whetstone.xyz_ecc/fullchain.cer &gt; /etc/nginx/ssl/whetstone.xyz.crt<br>cat ~/.acme.sh/whetstone.xyz_ecc/whetstone.xyz.key &gt; /etc/nginx/ssl/whetstone.xyz.key<br>systemctl start nginx<br><a href="http://acme.sh" target="_blank" rel="noopener">acme.sh</a> --installcert -d whetstone.xyz -d www.whetstone.xyz --fullchainpath /etc/nginx/ssl/whetstone.xyz.crt --keypath /etc/nginx/ssl/whetstone.xyz.key --ecc --reloadcmd “systemctl reload nginx”</p>]]></content>
      
      
      
        <tags>
            
            <tag> Microservice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解</title>
      <link href="/2019/04/20/%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/04/20/%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="元注解">元注解</h2><blockquote><p>可以用于修饰注解的注解,称之为元注解</p></blockquote><p>@Retention(RetentionPolicy.VALUE)</p><blockquote><p>确定所修饰注解的生命周期范围</p></blockquote><ul><li>@Retention(RetentionPolicy.CLASS)修饰的注解，表示注解的信息被保留在class文件(字节码文件)中当程序编译时，但不会被虚拟机读取在运行的时候；</li><li>@Retention(RetentionPolicy.SOURCE )修饰的注解,表示注解的信息会被编译器抛弃，不会留在class文件中，注解的信息只会留在源文件中；</li><li>@Retention(RetentionPolicy.RUNTIME )修饰的注解，表示注解的信息被保留在class文件(字节码文件)中当程序编译时，会被虚拟机保留在运行时，所以他们可以用反射的方式读取。RetentionPolicy.RUNTIME 可以让你从JVM中读取Annotation注解的信息，以便在分析程序的时候使用.</li></ul><p>@Traget({ElementType.VALUE,… })</p><blockquote><p>确定所修饰的注解 修饰的对象范围</p></blockquote><ul><li>ElementType.CONSTRUCTOR:用于描述构造器</li><li>ElementType.FIELD:用于描述域</li><li>ElementType.LOCAL_VARIABLE:用于描述局部变量</li><li>ElementType.METHOD:用于描述方法</li><li>ElementType.PACKAGE:用于描述包</li><li>ElementType.PARAMETER:用于描述参数</li><li>ElementType.TYPE:用于描述类、接口(包括注解类型) 或enum声明</li></ul><p>@Bean<br>(@Set @Get)</p><p>@AutoWire<br>public class cla/public void set(class cla)</p><ul><li>自动装配即是，让spring自动满足bean依赖的一种方法，在满足依赖的过程中，会在spring的上下文中匹配某个bean需要的bean;@AutoWire可以注解方法或者变量</li></ul><p>@Component(“name”)</p><ul><li>目前的了解是，加上该注解，就无需告知spring为该类创建Bean;如果有括号，并将该Bean ID标识（命名）为里面的字符串</li></ul><p>@Name</p><ul><li>spring 支持其代替 @Component ，唔，但不了解</li></ul><p>@ComponentScan<br>@ComponentScan(“name”)<br>@ComponentScan(basePackages=“name”/{“name”,“name1”})</p><ol><li>注解:在spring里开启组件扫描，默认扫描与配置类相同的包，扫描所在包以及子包中所有带有@Component注解的类</li><li>注解:指明基础包，可以指明多个基础包</li></ol><p>@ContextConfiguration(classes=*.class)</p><ul><li>从指明的class里加载配置</li></ul><p>@interface</p><blockquote><p>@interface Annotation{ } 定义一个注解 @Annotation，一个注解是一个类</p></blockquote><p>@Pointcut(表达式)</p><blockquote><p>Pointcut表示式(expression)和Pointcut签名(signature),signature 可用于 需要的注解找到该pointcut<br>//Pointcut表示式<br>@Pointcut(“execution(* com.savage.aop.MessageSender.*(…))”)<br>//Point签名<br>private void log(){}</p></blockquote><p>Pointcut 表达式</p><ul><li>execution：用于匹配方法执行的连接点；</li><li>within：用于匹配指定类型内的方法执行；</li><li>this：用于匹配当前AOP代理对象类型的执行方法；注意是AOP代理对象的类型匹配，这样就可能包括引入接口也类型匹配；</li><li>target：用于匹配当前目标对象类型的执行方法；注意是目标对象的类型匹配，这样就不包括引入接口也类型匹配；</li><li>args：用于匹配当前执行的方法传入的参数为指定类型的执行方法；</li><li>@within：用于匹配所以持有指定注解类型内的方法；</li><li>@target：用于匹配当前目标对象类型的执行方法，其中目标对象持有指定的注解；</li><li>@args：用于匹配当前执行的方法传入的参数持有指定注解的执行；</li><li>@annotation：用于匹配当前执行方法持有指定注解的方法；</li></ul><blockquote><p>execution 表达式<br>@Pointcut(execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern)throws-pattern?) )</p></blockquote><ul><li>修饰符匹配（modifier-pattern?）:public/private</li><li>返回值匹配（ret-type-pattern）可以为*表示任何返回值,全路径的类名等</li><li>类路径匹配（declaring-type-pattern?）</li><li>方法名匹配（name-pattern）可以指定方法名 或者 <em>代表所有, set</em> 代表以set开头的所有方法</li><li>参数匹配（(param-pattern)）可以指定具体的参数类型，多个参数间用“,”隔开，各个参数也可以用“<em>”来表示匹配任意类型的参数，如(String)表示匹配一个String参数的方法；(</em>,String) 表示匹配有两个参数的方法，第一个参数可以是任意类型，而第二个参数是String类型；可以用(…)表示零个或多个任意参数</li><li>异常类型匹配（throws-pattern?）</li><li>其中后面跟着“?”的是可选项</li></ul><p>2019-6-27 更新<br>今天在给spring 添加新restful接口时，发现无法访问；最后发现，接口如果不设置访问方法。默认访问方式是GET，奇怪的是，如果设置为POST方式，那么将无法访问，重定位回登录页面？？</p><p>在学习微服务构建时，需要看java代码，看到注解 时十分迷惑，暂时没有自己的见解<br>但是 这边博客说的不错<br><a href="https://blog.csdn.net/briblue/article/details/73824058" target="_blank" rel="noopener">https://blog.csdn.net/briblue/article/details/73824058</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stack+queue</title>
      <link href="/2019/04/15/stack-queue/"/>
      <url>/2019/04/15/stack-queue/</url>
      
        <content type="html"><![CDATA[<p>##stack：<br>先进后出；有压栈，出栈等操作<br>算法题：判断输入字符创是否符合规范，比如“【（）】”和“【（{”，利用栈去做比较好（需要存储正确对应的Map，比如 map={&quot;{&quot;:&quot;}&quot;}）,还可以选择重复循环消除“{}”、“（）”、“【】”等组合</p><p>##Queue：<br>先进先出；</p><p>如何用stack实现queue 以及如何使用Queue 实现stack<br>思路：负负得正；两个stack实现 Queue<br>利用两个栈的之间的元素的转移，实现元素顺序的反转</p><p>##Priority Queue<br>正常进入，按照优先级出<br>实现机制：Heap（二叉堆、多项式堆、斐波拉契堆）、二叉搜索树</p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linked_list</title>
      <link href="/2019/04/12/linked-list/"/>
      <url>/2019/04/12/linked-list/</url>
      
        <content type="html"><![CDATA[<p>链表相关问题<br>双链表 反转<br>链表交换相邻元素<br>判断链表是否有环</p><ul><li>暴力遍历，如果陷入循环中，那么永远无法结束（设置时间1s即可）</li><li>利用多余的数据结构判断是否经过同一个节点</li><li>快慢指针</li></ul><p>$$  \frac{1}{1+sin(x)}   $$</p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>island_count</title>
      <link href="/2019/04/11/island-count/"/>
      <url>/2019/04/11/island-count/</url>
      
        <content type="html"><![CDATA[<p>算法体：被河流围的若干岛屿分别用0和1表示，求岛屿个数以及可能的岛屿面积<br>第一种方法：染色（我更愿意理解为聚类删除）<br>即找到每一个1身边所有的1并将之删除（这符合岛屿的规定，即由1连在一起的集合），可以使用DFS或者BFS来进行删除<br>第二种方法：并查集<br>遍历数组，对于第一个遇到的1 ，将之作为队长，由此BFS/DFS建立 建立并查集，将同一个岛屿的1属于同一个集合；</p><p>应用：朋友圈</p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bullon_filter</title>
      <link href="/2019/04/11/bullon-filter/"/>
      <url>/2019/04/11/bullon-filter/</url>
      
        <content type="html"><![CDATA[<p>极客时间<br>哈希函数：将key隐射到一维数组的特殊位置（很少有错）<br>即使有错也可以 采取二维数组，减小错误率<br>类似于 计算机组成原理 内存与cache映射 中 组相联（还有直接隐射，全相联）</p><p>布隆过滤器：将key分解为若干元素组成，比如说连续的二进制<br>每输入一个key，将相应二进制位赋值为1，由此可以简单的判断不在，但是不能确定是否在，需要进一步判断（比如到后面数据库再核实）</p>]]></content>
      
      
      
        <tags>
            
            <tag> algrithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nlp-2019-4-5</title>
      <link href="/2019/04/06/nlp-2019-4-5/"/>
      <url>/2019/04/06/nlp-2019-4-5/</url>
      
        <content type="html"><![CDATA[<p>隐藏马尔科夫模型<br>EM算法 （迭代计算）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>machine_learning_website</title>
      <link href="/2019/03/31/machine-learning-website/"/>
      <url>/2019/03/31/machine-learning-website/</url>
      
        <content type="html"><![CDATA[<p>上机器学习课程时候，检索的网站，备注一下，以后需要学习<br><a href="https://blog.csdn.net/qq_33273962/article/details/83547342" target="_blank" rel="noopener">https://blog.csdn.net/qq_33273962/article/details/83547342</a></p><p><a href="https://www.cnblogs.com/baiting/p/6101981.html" target="_blank" rel="noopener">https://www.cnblogs.com/baiting/p/6101981.html</a></p><p><a href="https://m.leiphone.com/news/201902/biIqSBpehsaXFwpN.html?uniqueCode=OTEsp9649VqJfUcO" target="_blank" rel="noopener">https://m.leiphone.com/news/201902/biIqSBpehsaXFwpN.html?uniqueCode=OTEsp9649VqJfUcO</a></p><p><a href="https://blog.csdn.net/u014665013/article/details/78970184" target="_blank" rel="noopener">https://blog.csdn.net/u014665013/article/details/78970184</a></p><p><a href="https://m.baidu.com/from=1019471a/s?word=k+s+%E6%A3%80%E9%AA%8C++%E6%8B%9F%E5%90%88&amp;sa=bb&amp;ts=8918111&amp;t_kt=0&amp;ie=utf-8&amp;rsv_t=9789dDDxyBbDgg8gANiHbFLNiH9iyPv%252FBZ08a7iihLsR2SpKsNsS0G5sZ3o5A14&amp;rsv_pq=8183285748722183729&amp;ss=110&amp;tj=1&amp;rqlang=zh&amp;rsv_sug4=7460&amp;inputT=334&amp;oq=k%2Bs%2B%E6%A3%80%E9%AA%8C" target="_blank" rel="noopener">https://m.baidu.com/from=1019471a/s?word=k+s+检验++拟合&amp;sa=bb&amp;ts=8918111&amp;t_kt=0&amp;ie=utf-8&amp;rsv_t=9789dDDxyBbDgg8gANiHbFLNiH9iyPv%2FBZ08a7iihLsR2SpKsNsS0G5sZ3o5A14&amp;rsv_pq=8183285748722183729&amp;ss=110&amp;tj=1&amp;rqlang=zh&amp;rsv_sug4=7460&amp;inputT=334&amp;oq=k%2Bs%2B检验</a></p><p><a href="https://www.cnblogs.com/yunfeifei/p/4019504.html" target="_blank" rel="noopener">https://www.cnblogs.com/yunfeifei/p/4019504.html</a></p><p><a href="https://blog.csdn.net/qq_42686550/article/details/81514233" target="_blank" rel="noopener">https://blog.csdn.net/qq_42686550/article/details/81514233</a></p><p><a href="https://www.cnblogs.com/zackstang/p/8232921.html" target="_blank" rel="noopener">https://www.cnblogs.com/zackstang/p/8232921.html</a></p><p><a href="https://www.cnblogs.com/lianyingteng/p/7755545.html" target="_blank" rel="noopener">https://www.cnblogs.com/lianyingteng/p/7755545.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>log_read</title>
      <link href="/2019/03/29/log-read/"/>
      <url>/2019/03/29/log-read/</url>
      
        <content type="html"><![CDATA[<p>今天搭建对于kong log读取的系统，来源与师兄的经验，一些坑就可以避免了<br>这套系统由4部分组成</p><p>Logstash是一个开元数据收集引擎，具备实时管道功能；Logstash可以动态的将俩字不同来源的数据统一起来，并将数据标准化至你所选择的目的地。这里我们选择的Elasricearch</p><p>Elastricearch 是一个分布式可扩展的实时搜索的分析引擎，一个建立在全文搜索引擎Apache Lucene 基础上的搜索引擎，Elastricsearch 不仅包括全文搜索功能，还可以进行</p><ul><li>分布式实时文件存储，将每一个字段都编入索引，使之可以被搜索</li><li>实时分析的分布式搜索引擎</li><li>可以扩展到上百台服务器上，处理PB级别的结果或者非结构化数据</li></ul><p>FIleBeat  是一个日志文件托运工具，在服务器安装客户端后，FIlebeat可以监控日志目录或者指定的日志文件，追踪读取这些文件（追踪文件的变化，不停的读），并且转发这些信息到elasticsearch或者logstarsh中存放。</p><p>Metricbeat可以定期收集操作系统和服务器的运行指标（CPU，内存，硬盘，IO,读写速度，进程等等），Metricbeat可以将收集到的指标和数据发送到你指定的输出，比如：elasticsearch，最终达成监视服务器的目标。</p><p>Kibana是一个开源的分析和可视化平台，设计用于和Elasticsearch一起工作。你用Kibana来搜索，查看，并和存储在Elasticsearch索引中的数据进行交互。你可以轻松地执行高级数据分析，并且以各种图标、表格和地图的形式可视化数据。Kibana使得理解大量数据变得很容易。它简单的、基于浏览器的界面使你能够快速创建和共享动态仪表板，实时显示Elasticsearch查询的变化。</p><p>在安装的过程中，踩了一些坑，备注一下</p><p><font size="6">kong</font></p><p>Log format</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log_format json_log escape=json &apos;&#123; &quot;@timestamp&quot;: &quot;$time_iso8601&quot;, &apos;  &apos;&quot;remote_addr&quot;: &quot;$remote_addr&quot;, &apos;  &apos;&quot;referer&quot;: &quot;$http_referer&quot;, &apos;  &apos;&quot;request&quot;: &quot;$request&quot;, &apos;  &apos;&quot;status&quot;: $status, &apos;  &apos;&quot;bytes&quot;:$body_bytes_sent, &apos;  &apos;&quot;agent&quot;: &quot;$http_user_agent&quot;, &apos;  &apos;&quot;user&quot;: &quot;$http_username&quot;, &apos; &apos;&quot;x_forwarded&quot;: &quot;$http_x_forwarded_for&quot;, &apos;  &apos;&quot;upstr_addr&quot;: &quot;$upstream_addr&quot;,&apos;  &apos;&quot;upstr_host&quot;: &quot;$upstream_http_host&quot;,&apos;  &apos;&quot;ups_resp_time&quot;: &quot;$upstream_response_time&quot; &#125;&apos;;</span><br><span class="line">access_log logs/access.log json_log;</span><br></pre></td></tr></table></figure><p>在配置logstash时，配置数据输入为json ；之后配置filebeat 时同样配置输入json格式数据，之后出现乱码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">syslog &#123;</span><br><span class="line">     type =&gt; &quot;logs&quot;</span><br><span class="line">     port =&gt; 9044</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>之后出现乱码，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;message&quot; =&gt; &quot;%P\\u001A(%\\xBDi\\t\\x83,\\u001FϘ\\xF5H\\x8E$ofw\\x98\\x9F\\xDD\\xFB\\\&quot;&#123;f7\\x9B\\r%W\\u0003\\x9A\\xE3\\xA3\\xF3\\u&#123;7CBF2&#125;\\xDFnnn\\xBE\\xBB\\xB9\\xF9\\xFE\\xDF\\u0013\\xBC&gt;`P\\x9D\\n&quot;,</span><br></pre></td></tr></table></figure><p>错误提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0] &quot;_grokparsefailure_sysloginput&quot;,</span><br><span class="line">[1] &quot;_jsonparsefailure&quot;</span><br><span class="line">An unexpected error occurred! &#123;:error=&gt;#&lt;Errno::EBADF: Bad file descriptor - Bad file descriptor&gt;, :backtrace=&gt;[&quot;org/jruby/RubyIO.java:3565:in `each&apos;&quot;, &quot;/home/LAB/chengr/ELK/logstash-5.6.3/vendor/bundle/jruby/1.9/gems/logstash-input-syslog-3.2.2/lib/logstash/inputs/syslog.rb:182:in `tcp_receiver&apos;&quot;, &quot;/home/LAB/chengr/ELK/logstash-5.6.3/vendor/bundle/jruby/1.9/gems/logstash-input-syslog-3.2.2/lib/logstash/inputs/syslog.rb:167:in `tcp_listener&apos;&quot;]&#125;</span><br></pre></td></tr></table></figure><p>本来以为是因为 配置filebeat时，对于json输入的配置与logstash的配置出现冲突，以及 FIleBeat中encoding配置的问题，修改之后无效，查看错误时候发现 logstash输入类型和filebeat输出不一致，解析出错(<a href="https://blog.csdn.net/momoudong/article/details/82017852" target="_blank" rel="noopener">https://blog.csdn.net/momoudong/article/details/82017852</a>)<br>最终 logstash 配置 test.conf|filebeat_kong.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">input&#123;</span><br><span class="line">   # file &#123;</span><br><span class="line">   #         path =&gt; &quot;/home/LAB/chengr/kong_log/file.log&quot;</span><br><span class="line">   #      &#125;</span><br><span class="line">   beats &#123;</span><br><span class="line">        type =&gt; &quot;nginx-log&quot; #&quot;logs&quot;</span><br><span class="line">        port =&gt; 9044</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">filter&#123;</span><br><span class="line">    json&#123; #获取nginx log日志</span><br><span class="line">        source =&gt; &quot;message&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    mutate&#123;# 删去logstash转化后保留的messegae字段</span><br><span class="line">            remove_field =&gt; [&quot;message&quot;]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output&#123;</span><br><span class="line">    stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [&quot;10.1.1.46:9200&quot;]</span><br><span class="line">        index =&gt; &quot;system-syslog-%&#123;+YYYY.MM&#125;&quot;</span><br><span class="line">        #document_type =&gt; &quot;logs&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启 logstash 命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ELK目录下</span><br><span class="line">ELK/logstash-5.6.3/bin/logstash -f /usr/local/ELK/logstash-5.6.3/config/test.conf(或filebeat_kong.conf)</span><br></pre></td></tr></table></figure><p>错误2：<br>更改完上一个错误后 发现报如下错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2019-04-01T21:45:13,592][WARN ][logstash.outputs.elasticsearch] Could not index event to Elasticsearch. &#123;:status=&gt;400, :action=&gt;[&quot;index&quot;, &#123;:_id=&gt;nil, :_index=&gt;&quot;system-syslog-2019.04&quot;, :_type=&gt;&quot;log&quot;, :_routing=&gt;nil&#125;, 2019-04-01T13:45:00.925Z bd46 %&#123;message&#125;], :response=&gt;&#123;&quot;index&quot;=&gt;&#123;&quot;_index&quot;=&gt;&quot;system-syslog-2019.04&quot;, &quot;_type&quot;=&gt;&quot;log&quot;, &quot;_id&quot;=&gt;&quot;Cf0l2WkB8VUaRp2hlmvH&quot;, &quot;status&quot;=&gt;400, &quot;error&quot;=&gt;&#123;&quot;type&quot;=&gt;&quot;illegal_argument_exception&quot;, &quot;reason&quot;=&gt;&quot;Rejecting mapping update to [system-syslog-2019.04] as the final mapping would have more than 1 type: [log, logs]&quot;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>百度后有人是因logstash输出类型与elasticsearch 要求不同导致，即更改logstash输出类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document_type =&gt; &quot;logs&quot;</span><br></pre></td></tr></table></figure><p>filebeat 配置filebeat.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">filebeat.prospectors:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- input_type: log</span><br><span class="line"> # encoding: UTF-8</span><br><span class="line">  paths:</span><br><span class="line">    - /home/LAB/chengr/kong_log/file.log</span><br><span class="line">  json.keys_under_root: true #在一次部署中发现这一行不能识别，最终注释之解决</span><br><span class="line">  #json.add_error_key: true</span><br><span class="line">  #json.message_key: log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output.logstash:</span><br><span class="line">  #The Logstash hosts</span><br><span class="line">  hosts: [&quot;10.1.1.46:9044&quot;]</span><br></pre></td></tr></table></figure><p>开启filebeat 命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ELK/filebeat-5.6.4-linux-x86_64/filebeat -path.config /usr/local/ELK/filebeat-5.6.4-linux-x86_64/</span><br></pre></td></tr></table></figure><p>elastcisearch 配置 config/elasticsearch.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cluster.name: my-es-cluster</span><br><span class="line">node.name: es-node-1</span><br><span class="line">path.data: /home/LAB/chengr/ELK/data/data-es</span><br><span class="line">path.logs: /home/LAB/chengr/ELK/log/log-es</span><br><span class="line">network.host: 10.1.1.46</span><br><span class="line">http.port: 9200</span><br></pre></td></tr></table></figure><p>开启 elastcisearch 命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ELK/elasticsearch-6.4.2/bin/elasticsearch</span><br></pre></td></tr></table></figure><p>kibana 配置 config/kibana.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.port: 5601</span><br><span class="line">elasticsearch.url: &quot;http://10.1.1.46:9200&quot;</span><br></pre></td></tr></table></figure><p>开启 kibana 命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ELK/kibana-6.4.2-linux-x86_64/bin/kibana</span><br></pre></td></tr></table></figure><p>10.1.1.45   10.1.1.46 两台服务器以及192.168.1.242 主机（可显示）搭配<br>filebeat 两台服务器 上各配置一个，指向在10.1.1.46 上的 logstash ，logstash指向10.1.1.46上的elasticsearch ，指向 192.168.1.242上的kibana</p><p>2019-5-8<br>部署在实际机器上时将配置中ip改为对应的IP</p><p>kibana 添加邮件预警</p><ul><li><a href="http://www.cnblogs.com/small-k/p/8551960.html" target="_blank" rel="noopener">http://www.cnblogs.com/small-k/p/8551960.html</a></li><li><a href="https://blog.51cto.com/10546390/2051676" target="_blank" rel="noopener">https://blog.51cto.com/10546390/2051676</a></li></ul><p>2019-5-19 Error</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2019-05-19 16:46:00.000highemail html alarmwatcher_titleActionError: html email action : obligatory options in email: from and to </span><br><span class="line">&#123;</span><br><span class="line">  &quot;@timestamp&quot;: &quot;2019-05-19T08:46:00.031Z&quot;,</span><br><span class="line">  &quot;error&quot;: true,</span><br><span class="line">  &quot;report&quot;: false,</span><br><span class="line">  &quot;watcher&quot;: &quot;watcher_title&quot;,</span><br><span class="line">  &quot;action&quot;: &quot;email html alarm&quot;,</span><br><span class="line">  &quot;level&quot;: &quot;high&quot;,</span><br><span class="line">  &quot;message&quot;: &quot;ActionError: html email action : obligatory options in email: from and to&quot;,</span><br><span class="line">  &quot;type&quot;: &quot;sentinl-alarm&quot;,</span><br><span class="line">  &quot;_index&quot;: &quot;watcher_alarms-2019.05.19&quot;,</span><br><span class="line">  &quot;id&quot;: &quot;ClxEz2oBFTrgm4Wv5XBg&quot;</span><br><span class="line">#原因：这是由于在action 的Email属性中没有指明 to与 from 的邮箱</span><br></pre></td></tr></table></figure><p>配置kong日志格式更改  /etc/kong/kong.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nigin_http_log_format= log_json &apos;&#123; &quot;@timestamp&quot;: &quot;$time_iso8601&quot;, &apos;</span><br><span class="line">&apos;&quot;remote_addr&quot;: &quot;$remote_addr&quot;, &apos;</span><br><span class="line">&apos;&quot;referer&quot;: &quot;$http_referer&quot;, &apos;</span><br><span class="line">&apos;&quot;request&quot;: &quot;$request&quot;, &apos;</span><br><span class="line">&apos;&quot;status&quot;: $status, &apos;</span><br><span class="line">&apos;&quot;bytes&quot;:$body_bytes_sent, &apos;</span><br><span class="line">&apos;&quot;agent&quot;: &quot;$http_user_agent&quot;, &apos;</span><br><span class="line">&apos;&quot;x_forwarded&quot;: &quot;$http_x_forwarded_for&quot;, &apos;</span><br><span class="line">&apos;&quot;upstr_addr&quot;: &quot;$upstream_addr&quot;,&apos;</span><br><span class="line">&apos;&quot;upstr_host&quot;: &quot;$upstream_http_host&quot;,&apos;</span><br><span class="line">&apos;&quot;ups_resp_time&quot;: &quot;$upstream_response_time&quot; &#125;&apos;;</span><br><span class="line"></span><br><span class="line">nginx_proxy_access_log logs/access.log log_json;</span><br></pre></td></tr></table></figure><p>ps:<a href="https://docs.konghq.com/0.13.x/configuration/?_ga=2.242544130.102618566.1558236281-1173907870.1558236281#proxy_access_log" target="_blank" rel="noopener">kong 相关配置文件</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kong</title>
      <link href="/2019/03/26/kong/"/>
      <url>/2019/03/26/kong/</url>
      
        <content type="html"><![CDATA[<h2 id="kong">Kong</h2><p><a href="https://konghq.com/" target="_blank" rel="noopener">官网</a></p><h2 id="相关概念">相关概念</h2><p>consumer</p><blockquote></blockquote><p>service</p><blockquote></blockquote><p>route</p><blockquote></blockquote><p>upstream</p><blockquote></blockquote><p>plugin</p><blockquote><p><a href="https://docs.konghq.com/hub/" target="_blank" rel="noopener">官网</a> 包含 官方插件以及第三方插件<br><a href="https://github.com/walkdeadtobe/my_kong_plugin" target="_blank" rel="noopener">个人自定义插件</a></p></blockquote><h2 id="相关操作">相关操作</h2><p>创造 consumers</p><blockquote><p>curl -i -X POST  --url <a href="http://localhost:8001/consumers" target="_blank" rel="noopener">http://localhost:8001/consumers</a> --data “username=dzk”<br>给相应consumer 添加 basic-auth<br>curl -i -X POST  --url <a href="http://localhost:8001/consumers/e2dacbf6-117d-404f-8c40-58c305e4e669/basic-auth" target="_blank" rel="noopener">http://localhost:8001/consumers/e2dacbf6-117d-404f-8c40-58c305e4e669/basic-auth</a> --data “username=dzk” --data “password=dzk”<br>添加 ACL<br>curl -X POST <a href="http://localhost:8001/consumers/e2dacbf6-117d-404f-8c40-58c305e4e669/acls" target="_blank" rel="noopener">http://localhost:8001/consumers/e2dacbf6-117d-404f-8c40-58c305e4e669/acls</a> --data “group=group2”</p></blockquote><p>给相应服务添加 basic-auth ACL</p><blockquote><p>curl -X POST <a href="http://localhost:8001/services/ddj/plugins" target="_blank" rel="noopener">http://localhost:8001/services/ddj/plugins</a> --data “name=basic-auth” --data “config.hide_credentials=true”<br>curl -X POST <a href="http://localhost:8001/services/ddj/plugins" target="_blank" rel="noopener">http://localhost:8001/services/ddj/plugins</a> --data “name=acl” --data “config.whitelist=group1” --data “config.hide_groups_header=true”</p></blockquote><p>为kong添加 访问 admin 的外部服务</p><blockquote><p><a href="https://docs.gelato.io/guides/advanced-kong-integration" target="_blank" rel="noopener">https://docs.gelato.io/guides/advanced-kong-integration</a><br>curl -i -X POST  --url <a href="http://localhost:8001/services/" target="_blank" rel="noopener">http://localhost:8001/services/</a>  --data ‘name=admin’ --data ‘url=http://localhost:8001’<br>curl -i -X POST   --url <a href="http://localhost:8001/services/admin/routes" target="_blank" rel="noopener">http://localhost:8001/services/admin/routes</a>  --data ‘paths=/admin’ --data ‘strip_path=true’</p></blockquote><p>kong发送的信息不含用户consumer信息，使用datadog的log功能进行统计</p><p>datadog-agent 相关命令</p><blockquote><p>/etc/init.d/datadog-agent restart、stop<br>sudo datadog-agent check kong/status<br>systemctl start datadog-agent</p></blockquote><p>kong 数据库操作</p><blockquote><p>su - postgres<br>pslq<br>\c kong 切换数据库kong<br>select * from pg_tables 查看当前数据库所有的表</p></blockquote><p>更新 2019-4-18<br>给服务ACL 服务whitelist 添加 多个 group<br>出现问题，提交bug，kong开发大佬解决 ，附链接 <a href="https://github.com/Kong/kong/issues/4523" target="_blank" rel="noopener">https://github.com/Kong/kong/issues/4523</a><br>给插件 CORS 添加多个header<br>curl -X PATCH <a href="http://localhost:8001/plugins/8f407ede-33d2-43c3-b528-cb1f8a4ebec1" target="_blank" rel="noopener">http://localhost:8001/plugins/8f407ede-33d2-43c3-b528-cb1f8a4ebec1</a> <br>–data “config.headers=Origin” <br>–data “config.headers=X-Requested-With” <br>–data “config.headers=Content-Type” <br>–data “config.headers=Authorization” <br>–data “config.headers=Accept” <br>–data “config.headers=Accept-Version” <br>–data “config.headers=Content-Length” <br>–data “config.headers=Content-MD5” <br>–data “config.headers=Date” <br>–data “config.headers=X-Auth-Token”</p><p>更新 2019-6-22<br>在查询kong的服务数目时，发现postgresql数据库的services数目与 curl <a href="http://localhost:8001/services" target="_blank" rel="noopener">http://localhost:8001/services</a> 数目不同，最后在github源码中发现 在api中设置最大返回值为100;唔在考虑从源码编译修改，但是安装会很蛋疼</p><h2 id="插件使用">插件使用</h2><p>kong_datadog_agent</p><blockquote><p>更爱配置文件后出现</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2019/03/27 22:48:13 config.load While parsing config: yaml: line 291: did not find expected key</span><br><span class="line">Cannot setup config, exiting: unable to load Datadog config file: While parsing config: yaml: line 291: did not find expected key</span><br><span class="line">Error: unable to load Datadog config file: While parsing config: yaml: line 291: did not find expected key</span><br></pre></td></tr></table></figure><blockquote><p>最终发现是因为 更改配置时，没有对齐行开始（坑爹）</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> kong plugin consumer service route </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bp+rbf+lstm</title>
      <link href="/2019/03/23/bp-rbf-lstm/"/>
      <url>/2019/03/23/bp-rbf-lstm/</url>
      
        <content type="html"><![CDATA[<p>fisher +感知器  属于   线性分类器</p><p>人工神经网络（DP）  对比    径向基函数（RBF：神经元不只是感知器）<br>LSTM<br>模式识别 思考题 5000男+5000女 特征 分类</p>]]></content>
      
      
      
        <tags>
            
            <tag> deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABAC</title>
      <link href="/2019/03/20/ABAC/"/>
      <url>/2019/03/20/ABAC/</url>
      
        <content type="html"><![CDATA[<p>ABAC:Attribute Based Access Control<br>abaC 介绍视频： <a href="https://www.youtube.com/watch?v=cgTa7YnGfHA" target="_blank" rel="noopener">https://www.youtube.com/watch?v=cgTa7YnGfHA</a><br>+<br><a href="https://www.youtube.com/watch?v=gskKUIa0_6A" target="_blank" rel="noopener">https://www.youtube.com/watch?v=gskKUIa0_6A</a><br>An Attribute Based Access Control Model for RESTful Service：一篇相关论文，其视频：<a href="https://www.youtube.com/watch?v=hDlr66-4paI" target="_blank" rel="noopener">https://www.youtube.com/watch?v=hDlr66-4paI</a></p><p>相关概念延伸：XACML</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多元正态分布密度</title>
      <link href="/2019/03/18/Multivariate-normal-distribution-density/"/>
      <url>/2019/03/18/Multivariate-normal-distribution-density/</url>
      
        <content type="html"><![CDATA[<p>公式推到 建议 word<br><a href="https://blog.csdn.net/qq_23869697/article/details/80610361" target="_blank" rel="noopener">https://blog.csdn.net/qq_23869697/article/details/80610361</a><br><a href="https://baike.baidu.com/item/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5/9822183?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/协方差矩阵/9822183?fr=aladdin</a></p><p>$$ \varphi ([u_{1},u_{2}…,u_{d}]^{T})\begin{cases}<br>&amp; \text{1       if } \left | u_{j} \right |\leq \frac{1}{2} \space , \space j=1,2,…,d \<br>&amp; \text{0       esle }<br>\end{cases} $$</p><p>$$ x\in R^{d} $$</p><p>$$ V=h^{d} $$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 模式识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>素数问题：艾拉欧拉筛法</title>
      <link href="/2019/03/18/%E7%B4%A0%E6%95%B0%E9%97%AE%E9%A2%98%EF%BC%9A%E8%89%BE%E6%8B%89%E6%AC%A7%E6%8B%89%E7%AD%9B%E6%B3%95/"/>
      <url>/2019/03/18/%E7%B4%A0%E6%95%B0%E9%97%AE%E9%A2%98%EF%BC%9A%E8%89%BE%E6%8B%89%E6%AC%A7%E6%8B%89%E7%AD%9B%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>参考博客</p><p><a href="https://blog.csdn.net/hzaukotete/article/details/81103528" target="_blank" rel="noopener">https://blog.csdn.net/hzaukotete/article/details/81103528</a></p><p><a href="https://blog.csdn.net/qq_39763472/article/details/82428602" target="_blank" rel="noopener">https://blog.csdn.net/qq_39763472/article/details/82428602</a></p><p>$$  J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，行内公式示例}  $$<br>$ \ \ \ $<br>$$ \int_{0}^{1}{\frac{\pi}{2}}\sin(x)\space dx $$<br>$$ \int_{0}^{} $$<br>$$ \space{12pt}  $$</p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>microservice-about-resource</title>
      <link href="/2019/03/14/microservice-about-resource/"/>
      <url>/2019/03/14/microservice-about-resource/</url>
      
        <content type="html"><![CDATA[<p>Ouath 2.0 授权协议 相关 <a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a>   + <a href="https://www.cnblogs.com/flashsun/p/7424071.html" target="_blank" rel="noopener">https://www.cnblogs.com/flashsun/p/7424071.html</a></p><p>MOngodb 数据库操作<br><a href="http://www.runoob.com/mongodb/mongodb-analyzing-queries.html" target="_blank" rel="noopener">http://www.runoob.com/mongodb/mongodb-analyzing-queries.html</a><br>+<br><a href="https://docs.spring.io/spring-data/mongodb/docs/current/reference/html/#mongodb-connectors" target="_blank" rel="noopener">https://docs.spring.io/spring-data/mongodb/docs/current/reference/html/#mongodb-connectors</a></p><p>API 网关测试<br><a href="https://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/11/08/kong-features-06-production-and-benchmark.html#%E4%BB%8E%E8%AF%B7%E6%B1%82%E7%AB%AF%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AEpod" target="_blank" rel="noopener">https://www.lijiaocn.com/项目/2018/11/08/kong-features-06-production-and-benchmark.html#从请求端直接访问pod</a><br>+<br><a href="https://www.codercto.com/a/48944.html" target="_blank" rel="noopener">https://www.codercto.com/a/48944.html</a></p><p>微服务授权（服务注册与发现等） 以及系列化 博客<br><a href="https://segmentfault.com/a/1190000007689560" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007689560</a><br>+<br><a href="https://www.cnblogs.com/bluedoctor/p/8967951.html" target="_blank" rel="noopener">https://www.cnblogs.com/bluedoctor/p/8967951.html</a><br>+<br><a href="http://emacoo.cn/arch/microservice-overview/" target="_blank" rel="noopener">http://emacoo.cn/arch/microservice-overview/</a></p><p>单点登录<br><a href="https://yq.aliyun.com/articles/636281" target="_blank" rel="noopener">https://yq.aliyun.com/articles/636281</a></p><p>kong网关<br><a href="http://www.blogjava.net/coolfiry/archive/2018/01/05/433005.html" target="_blank" rel="noopener">http://www.blogjava.net/coolfiry/archive/2018/01/05/433005.html</a></p><p>$$ \int_{0}^{1}{\frac{\pi}{2}}\sin(x)\space dx $$</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>KNN</title>
      <link href="/2019/03/14/KNN/"/>
      <url>/2019/03/14/KNN/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def knearestEstimate(sampleSet,k):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    K近邻非参数估计方法</span><br><span class="line">    Args:</span><br><span class="line">        sampleSet:样本向量的集合</span><br><span class="line">        k:用于计算近邻数Kn的常数</span><br><span class="line">    Returns:</span><br><span class="line">        估计的概率密度函数</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    n,d=np.shape(sampleset)</span><br><span class="line">    m=(k*n**0.5)</span><br><span class="line">    def probability(sample):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        K近邻非参数估计得到的概率密度函数</span><br><span class="line">        Args:</span><br><span class="line">            sampleSet:概率密度待估计的样本向量</span><br><span class="line">        Returns:</span><br><span class="line">            估计的概率密度</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        dist=[]</span><br><span class="line">        for p in sampleSet-sample:</span><br><span class="line">            dist.append((np.sum(p**2))**0.5)</span><br><span class="line">        np.sort(np.array(dist))</span><br><span class="line">        r=dist[int(m)]</span><br><span class="line">        v=math.pi**(d/2)*r**d/math.gamma(d/2+1)</span><br><span class="line">        return m/n/v</span><br><span class="line">    return probability</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.sum(p**2))**0.5</span><br></pre></td></tr></table></figure><p>即  $$ \sqrt{(x_{1}-y_{1})^2+(x_{2}-y_{2})^2} $$</p><p>n纬球体的体积公式为(<a href="https://spaces.ac.cn/archives/3154" target="_blank" rel="noopener">https://spaces.ac.cn/archives/3154</a>) $$ V_{n}®= \frac{2\pi^{\frac{n}{2}}}{ \Gamma (\frac{n}{2})}r^{n-1} $$</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>service discovery and register</title>
      <link href="/2019/03/13/service-discovery-and-register/"/>
      <url>/2019/03/13/service-discovery-and-register/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/uzGF5b4sn1DeSc1F1FOGRA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/uzGF5b4sn1DeSc1F1FOGRA</a></p><p>微信 上关于微服务发现的推文<br>服务发现背后的基本思想是对于服务的每一个新实例（或应用程序），能够识别当前环境和存储相关信息。存储的注册表信息本身通常采用键/值对的格式，由于服务发现经常用于分布式系统，所以要求这些信息可伸缩、支持容错和分布式集群中的所有节点</p><p>做到服务发现之前首先需要做到的是提供服务注册表，供服务消毒费查询<br>同时注册表应当保持高可用，大多以键值对的形式存在</p><p>Zookeeper</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>openresty_source_compile</title>
      <link href="/2019/03/08/openresty-source-compile/"/>
      <url>/2019/03/08/openresty-source-compile/</url>
      
        <content type="html"><![CDATA[<p>最近调研APIGateway，目前主要在研究 kong 的东西，打算在服务器上布置环境，测试其性能<br>系统环境：<br>操作系统版本：Linux version 4.4.0-134-generic (buildd@lgw01-amd64-033) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.10) )</p><p>用户目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">×××@bd45:~$ tree -L 1  </span><br><span class="line">.  </span><br><span class="line">|-- apr  </span><br><span class="line">|-- apr-1.4.5  </span><br><span class="line">|-- apr-1.4.5.tar.gz  </span><br><span class="line">|-- apr-util  </span><br><span class="line">|-- apr-util-1.3.12  </span><br><span class="line">|-- apr-util-1.3.12.tar.gz  </span><br><span class="line">|-- download_file?file_path=dists%2Fkong-community-edition-1.0.3.xenial.all.deb </span><br><span class="line">|-- httpd  </span><br><span class="line">|-- httpd-2.4.38  </span><br><span class="line">|-- httpd-2.4.38.tar.gz  </span><br><span class="line">|-- kong  </span><br><span class="line">|-- kong_source  </span><br><span class="line">|-- lua-5.3.4  </span><br><span class="line">|-- lua-5.3.4.tar.gz  </span><br><span class="line">|-- luarocks  </span><br><span class="line">|-- nginx  </span><br><span class="line">|-- nginx-1.15.9  </span><br><span class="line">|-- nginx-1.15.9.tar.gz  </span><br><span class="line">|-- openresty  </span><br><span class="line">|-- openresty-1.13.6.2  </span><br><span class="line">|-- openresty-1.13.6.2.tar.gz</span><br><span class="line">|-- openssl</span><br><span class="line">|-- openssl-1.0.2r</span><br><span class="line">|-- openssl-1.0.2r.tar.gz</span><br><span class="line">|-- pcre</span><br><span class="line">|-- pcre-8.43</span><br><span class="line">|-- pcre-8.43.tar.gz</span><br><span class="line">|-- postgresql</span><br><span class="line">|-- postgresql-11.2</span><br><span class="line">|-- postgresql-11.2.tar.gz</span><br><span class="line">|-- siege</span><br><span class="line">|-- siege-4.0.4</span><br><span class="line">`-- siege-4.0.4.tar.gz</span><br></pre></td></tr></table></figure><p>安装pcre</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -# -O  https://ftp.pcre.org/pub/pcre/pcre-8.43.tar.gz</span><br><span class="line">./configure --prefix=/home/LAB/chengr/pcre </span><br><span class="line">./configure --prefix=/home/LAB/chengr/nginx --with-pcre=/home/LAB/chengr/pcre-8.43</span><br></pre></td></tr></table></figure><p>安装zlib</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://prdownloads.sourceforge.net/libpng/zlib-1.2.11.tar.gz</span><br><span class="line"> ./configure  --prefix=/home/LAB/chengr/zlib</span><br><span class="line"> make &amp;&amp; make check &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>安装 nginx，官网配置说明 ：<a href="https://nginx.org/en/docs/configure.html" target="_blank" rel="noopener">https://nginx.org/en/docs/configure.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -# -O http://nginx.org/download/nginx-1.15.8.tar.gz</span><br><span class="line">tar -zvxf nginx-1.15.8.tar.gz</span><br><span class="line">cd nginx-1.15.8</span><br><span class="line">(./configure: error: the HTTP rewrite module requires the PCRE library.)</span><br><span class="line">(./configure: error: the HTTP magzip module requires the zlib library.)</span><br><span class="line">与nginx模块一起编译，要求指定源码目录</span><br><span class="line">./configure --prefix=/home/LAB/chengr/nginx  --with-pcre=/home/LAB/chengr/pcre-8.39  --with-zlib=/home/LAB/chengr/zlib-1.2.11</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>下载openssl(配置openresty)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -# -O https://www.openssl.org/source/openssl-1.0.2r.tar.gz(https://www.openssl.org/source/)</span><br><span class="line">tar -zvxf openssl-1.0.2r.tar.gz</span><br><span class="line">./config --prefix=/home/LAB/chengr/openssl  -fPIC no-gost no-shared no-zlib</span><br><span class="line">make depend</span><br></pre></td></tr></table></figure><p>安装luarock:<br>按照教程来 <a href="https://github.com/luarocks/luarocks/wiki/Installation-instructions-for-Unix" target="_blank" rel="noopener">https://github.com/luarocks/luarocks/wiki/Installation-instructions-for-Unix</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（其中configure 改为./configure    --prefix=/home/LAB/chengr/luarocks   --lua-suffix=jit    --with-lua=/home/LAB/chengr/openresty/luajit    --with-lua-include=/home/LAB/chengr/openresty/luajit/include/luajit-2.1）</span><br><span class="line">make</span><br><span class="line">  make install</span><br><span class="line">  make bootstrap</span><br></pre></td></tr></table></figure><p>安装 openresty 官网教程：<a href="https://openresty.org/cn/installation.html" target="_blank" rel="noopener">https://openresty.org/cn/installation.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">curl -# -O https://openresty.org/download/openresty-1.13.6.2.tar.gz  </span><br><span class="line">tar -xzvf openresty-1.13.6.2.tar.gz  </span><br><span class="line">cd cd openresty-1.13.6.2  </span><br><span class="line">mkdir openresty  </span><br><span class="line">./configure --prefix=/home/LAB/chengr/openresty  --with-luajit --with-stream   --with-http_iconv_module --with-http_realip_module   --with-ld-opt=&quot;-Wl,-rpath,/usr/local/lib&quot;  --with-http_stub_status_module   --with-http_ssl_module --with-http_sub_module  </span><br><span class="line">//按照kong官网要求加上如下配置  </span><br><span class="line">   --with-pcre-jit </span><br><span class="line">   --with-http_ssl_module </span><br><span class="line">   --with-http_realip_module </span><br><span class="line">   --with-http_stub_status_module </span><br><span class="line">   --with-http_v2_module   </span><br><span class="line">   --with-openssl=/home/LAB/chengr/openssl-1.0.2r</span><br><span class="line"></span><br><span class="line">make   </span><br><span class="line">sudo make install</span><br><span class="line">【】</span><br></pre></td></tr></table></figure><p>安装postgresql （官网教程：<a href="https://www.postgresql.org/docs/current/install-procedure.html%EF%BC%89" target="_blank" rel="noopener">https://www.postgresql.org/docs/current/install-procedure.html）</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -# -O https://ftp.postgresql.org/pub/source/v11.2/postgresql-11.2.tar.gz</span><br></pre></td></tr></table></figure><p>按安装性能测试工具：siege ab</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -# -O http://download.joedog.org/siege/siege-4.0.4.tar.gz</span><br><span class="line">tar -zvxf siege-4.0.4.tar.gz   </span><br><span class="line">cd siege-4.0.4</span><br><span class="line">./configure --prefix=/home/LAB/chengr/siege  </span><br><span class="line">make     </span><br><span class="line">sudo make install   </span><br><span class="line"> siege/bin/siege –help</span><br></pre></td></tr></table></figure><hr><p>ab（需要提前安装 apr 、apr-util、pcre、openssl）<br>apr</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://archive.apache.org/dist/apr/apr-1.4.5.tar.gz</span><br><span class="line">tar -zxf apr-1.4.5.tar.gz  </span><br><span class="line">cd  apr-1.4.5  </span><br><span class="line">./configure --prefix=/home/LAB/chengr/apr  </span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>apr-util</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://archive.apache.org/dist/apr/apr-util-1.3.12.tar.gz</span><br><span class="line">tar -zxf apr-util-1.3.12.tar.gz</span><br><span class="line">cd apr-util-1.3.12</span><br><span class="line">./configure --prefix=/home/LAB/chengr/apr-util --with-apr=/home/LAB/chengr/apr/</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>pcre</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://jaist.dl.sourceforge.net/project/pcre/pcre/8.39/pcre-8.39.tar.gz</span><br><span class="line">tar -zxf pcre-8.39.tar.gz</span><br><span class="line">cd pcre-8.10</span><br><span class="line">./configure --prefix=/home/LAB/chengr/pcre</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>最终安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd httpd-2.4.38</span><br><span class="line">./configure --prefix=/home/LAB/chengr/httpd --with-apr=/home/LAB/chengr/apr --with-apr-util=/home/LAB/chengr/apr-util --with-pcre=/home/LAB/chengr/pcre --enable-ssl --with-ssl=/home/LAB/chengr/openssl</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>curl -# -O <a href="https://www-us.apache.org/dist//httpd/httpd-2.4.38.tar.gz" target="_blank" rel="noopener">https://www-us.apache.org/dist//httpd/httpd-2.4.38.tar.gz</a></p><p>按照教程安装 <a href="https://www.cnblogs.com/chevin/p/10222681.html" target="_blank" rel="noopener">https://www.cnblogs.com/chevin/p/10222681.html</a></p><p>（下载 httpd wget <a href="https://www.apache.org/dist/httpd/httpd-2.4.38.tar.gz" target="_blank" rel="noopener">https://www.apache.org/dist/httpd/httpd-2.4.38.tar.gz</a> ）</p><p>./config --prefix=/home/LAB/chengr/openssl  -fPIC no-gost no-shared no-zlib<br>make depend<br>解决：<a href="http://www.bubuko.com/infodetail-621556.html" target="_blank" rel="noopener">http://www.bubuko.com/infodetail-621556.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">chengr@bd46:~$ tree -L 2 -d</span><br><span class="line">.</span><br><span class="line">|-- apr</span><br><span class="line">|   |-- bin</span><br><span class="line">|   `-- lib</span><br><span class="line"></span><br><span class="line">|-- apr-util</span><br><span class="line">|   |-- bin</span><br><span class="line">|   `-- lib</span><br><span class="line">|-- httpd</span><br><span class="line">|   |-- bin</span><br><span class="line">|   |-- build</span><br><span class="line">|   |-- cgi-bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|-- openssl</span><br><span class="line">|   |-- bin</span><br><span class="line">|   |-- lib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|   `-- VMS</span><br><span class="line">|-- pcre</span><br><span class="line">|   |-- bin</span><br><span class="line">|   |-- lib</span><br><span class="line"></span><br><span class="line">|-- siege</span><br><span class="line">|   |-- bin</span><br></pre></td></tr></table></figure><p>添加到环境变量中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#add for apr 2019-3-10</span><br><span class="line">export APR_HOME=/home/LAB/chengr/apr</span><br><span class="line">export PATH=$PATH:$APR_HOME/bin</span><br><span class="line">#export LIB_PATH+=$APR_HOME/lib</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#add for apr-util 2019-3-10</span><br><span class="line">export APRUTIL_HOME=/home/LAB/chengr/apr-util</span><br><span class="line">export PATH=$PATH:$APRUTIL_HOME/bin</span><br><span class="line">#export LIB_PATH+=$APRUTIL_HOME/lib</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#add for httpd 2019-3-10</span><br><span class="line">export HTTPD_HOME=/home/LAB/chengr/httpd</span><br><span class="line">export PATH=$PATH:$HTTPD_HOME/bin</span><br><span class="line">#export LIB_PATH+=$HTTPD_HOME/lib</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#add for openssl 2019-3-10</span><br><span class="line">export OPENSSL_HOME=/home/LAB/chengr/openssl</span><br><span class="line">export PATH=$PATH:$OPENSSL_HOME/bin</span><br><span class="line">#export LIB_PATH+=$OPENSSL_HOME/lib</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#add for pcre 2019-3-10</span><br><span class="line">export PCRE_HOME=/home/LAB/chengr/pcre</span><br><span class="line">export PATH=$PATH:$PCRE_HOME/bin</span><br><span class="line">#export LIB_PATH+=$HTTPD_HOME/lib</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#add for siege 2019-3-10</span><br><span class="line">export SIEGE_HOME=/home/LAB/chengr/siege</span><br><span class="line">export PATH=$PATH:$SIEGE_HOME/bin</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#add for luarocks 2019-3-10</span><br><span class="line">export LUAROCKS_HOME=/home/LAB/chengr/luarocks</span><br><span class="line">export PATH=$PATH:$LUAROCKS_HOME/bin</span><br><span class="line">#export LIB_PATH+=$LUAROCKS_HOME/lib</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#add for nginx 2019-3-10</span><br><span class="line">export NGINX_HOME=/home/LAB/chengr/nginx</span><br><span class="line">export PATH=$PATH:$NGINX_HOME/sbin</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#add for openresty 2019-3-10</span><br><span class="line">export OPENRESTY_HOME=/home/LAB/chengr/openresty</span><br><span class="line">export PATH=$PATH:$OPENRESTY_HOME/bin</span><br><span class="line">#export LIB_PATH+=$OPENRESTY_HOME/lib</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#add for postgresql 2019-3-10</span><br><span class="line">export POSTGRESQL_HOME=/home/LAB/chengr/postgresql</span><br><span class="line">export PATH=$PATH:$POSTGRESQL_HOME/bin</span><br><span class="line">#export LIB_PATH+=$POSTGRESQL_HOME/lib</span><br><span class="line">#end</span><br></pre></td></tr></table></figure><p>jhipster<br><a href="https://blog.csdn.net/zhao50632/article/details/54582177" target="_blank" rel="noopener">https://blog.csdn.net/zhao50632/article/details/54582177</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>nginx+mongodb</title>
      <link href="/2019/03/06/nginx-mongodb/"/>
      <url>/2019/03/06/nginx-mongodb/</url>
      
        <content type="html"><![CDATA[<br>  install luarock:https://blog.csdn.net/kgzhang/article/details/72885199  <br>  install lua_nginx_moudle https://www.cnblogs.com/uglyliu/p/8534473.html<br>install nginx-gridfx https://blog.csdn.net/jameshadoop/article/details/52665342  + https://blog.csdn.net/caiwenfeng_for_23/article/details/44230513 +https://github.com/mdirolf/nginx-gridfs<p>./configure --user=nginx --group=nginx --prefix=/usr/local/nginx  --with-http_realip_module --with-http_stub_status_module --with-http_ssl_module --with-http_flv_module --with-http_gzip_static_module --with-cc-opt=-Wno-error --with-stream --add-module=/opt/nginx_module/ngx_devel_kit --add-module=/opt/nginx_module/lua-nginx-module --add-module=/opt/nginx_module/nginx-gridfs</p><p>./configure --user=nginx --group=nginx --prefix=/usr/local/nginx --with-cc-opt=-Wno-error --add-module=/opt/nginx_module/ngx_devel_kit --add-module=/opt/nginx_module/lua-nginx-module --add-module=/opt/nginx_module/nginx-gridfs</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>API_Key</title>
      <link href="/2019/03/06/API-Key/"/>
      <url>/2019/03/06/API-Key/</url>
      
        <content type="html"><![CDATA[<h2 id="how-kong-generate-api-key-in-plugin-key-auth">How Kong  generate api key in plugin key-auth</h2><p>在 github <a href="https://github.com/Kong/kong" target="_blank" rel="noopener">https://github.com/Kong/kong</a> ，我们可以看到关于Kong的代码<br>在https://github.com/eyolas/kong-plugin-key-auth-referer/blob/master/kong/plugins/key-auth-referer/daos.lua 上，我们可以看到其中包含代码<br><code>local utils = require &quot;kong.tools.utils&quot;</code><br><code> key = {type = &quot;string&quot;, required = false, unique = true, default = utils.random_string}</code><br>按照目录搜索<code>https://github.com/Kong/kong/blob/master/kong/tools/utils.lua</code>，从中可以查询到函数<code>random_string</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local function random_string()</span><br><span class="line">    -- get 24 bytes, which will return a 32 char string after encoding</span><br><span class="line">    -- this is done in attempt to maintain backwards compatibility as</span><br><span class="line">    -- much as possible while improving the strength of this function</span><br><span class="line">    return encode_base64(get_rand_bytes(24, true))</span><br><span class="line">           :gsub(&quot;/&quot;, char(rand(48, 57)))  -- 0 - 10</span><br><span class="line">           :gsub(&quot;+&quot;, char(rand(65, 90)))  -- A - Z</span><br><span class="line">           :gsub(&quot;=&quot;, char(rand(97, 122))) -- a - z</span><br><span class="line">  end</span><br></pre></td></tr></table></figure><p>由此可知，当使用key-auth插件，但不指明key值时，就会默认自动生成 24位字符，对于产生的特殊字符进行替换</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
