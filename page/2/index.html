<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/06/工作求职/剑指offer/4_解决面试题的思路/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/06/工作求职/剑指offer/4_解决面试题的思路/" itemprop="url">剑指offer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-06T11:11:41+08:00">
                2020-07-06
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-07-06T11:34:54+08:00" content="2020-07-06">
                2020-07-06
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="解决面试题的思路">解决面试题的思路</h1>
<h2 id="面试题19二叉树的镜像">面试题19：二叉树的镜像</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。二叉树结点的定义如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                    m_nValue;</span><br><span class="line">    BinaryTreeNode*        m_pLeft;</span><br><span class="line">    BinaryTreeNode*        m_pRight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解析">解析</h3>
<p>如果画图分析过，很容易就会发现，其实要得到一棵二叉树的镜像，只需要把每个结点的左右子结点都进行交换就可以了。</p>
<p>在每一轮交换中，我们先记住原来的左子结点，然后把当前结点的左子结点指针改为指向右子结点，最后把当前结点的右子结点指针改为指向原来的左子结点就可以了。</p>
<p>使用递归的话，注意结束条件是到达叶结点。特别地，要记得处理输入为空指针的状况。处理完当前结点后，若左子结点不为NULL，就继续处理左子结点，右子结点同理；</p>
<p>使用迭代的话，其实也很类似，可以用栈来模拟，递归本身就是一种栈结构。</p>
<p>递归解法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MirrorRecursively</span><span class="params">(BinaryTreeNode *pNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((pNode == <span class="literal">NULL</span>) || (pNode-&gt;m_pLeft == <span class="literal">NULL</span> &amp;&amp; pNode-&gt;m_pRight))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    BinaryTreeNode *pTemp = pNode-&gt;m_pLeft;</span><br><span class="line">    pNode-&gt;m_pLeft = pNode-&gt;m_pRight;</span><br><span class="line">    pNode-&gt;m_pRight = pTemp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pNode-&gt;m_pLeft)</span><br><span class="line">        MirrorRecursively(pNode-&gt;m_pLeft);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pNode-&gt;m_pRight)</span><br><span class="line">        MirrorRecursively(pNode-&gt;m_pRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代解法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MirrorIteratively</span><span class="params">(BinaryTreeNode* pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;BinaryTreeNode*&gt; stackTreeNode;</span><br><span class="line">    stackTreeNode.push(pRoot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(stackTreeNode.size() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode *pNode = stackTreeNode.top();</span><br><span class="line">        stackTreeNode.pop();</span><br><span class="line"></span><br><span class="line">        BinaryTreeNode *pTemp = pNode-&gt;m_pLeft;</span><br><span class="line">        pNode-&gt;m_pLeft = pNode-&gt;m_pRight;</span><br><span class="line">        pNode-&gt;m_pRight = pTemp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;m_pLeft)</span><br><span class="line">            stackTreeNode.push(pNode-&gt;m_pLeft);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;m_pRight)</span><br><span class="line">            stackTreeNode.push(pNode-&gt;m_pRight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题20顺时针打印矩阵">面试题20：顺时针打印矩阵</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。例如：如果输入如下矩阵</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1   2   3   4</span><br><span class="line">5   6   7   8</span><br><span class="line">9   10  11  12</span><br><span class="line">13  14  15  16</span><br></pre></td></tr></table></figure>
<blockquote>
<p>则依次打印出数字 <code>1、2、3、4、8、12、16、15、14、13、9、5、6、7、11、10</code>。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>题目要求从外向里顺时针打印一个矩阵，其实可以把这个矩阵从外向里分为若干层，每一层从左上角开始（比如上面例子中的1和6）。这样题目的要求就变为依次顺时针打印每一层的数字。我们会发现，<strong>每一层左上角的行坐标和列坐标都是相等的</strong>。</p>
<p>那么我们可以用一个循环来打印出所有的层，但是到底有多少层呢？或者会说，每一层左上角的坐标 <code>(start, start)</code> 最大可以是多少呢？通过举例分析，我们会发现，<strong>给定任意一个矩阵，层数是行数的一半和列数的一半这两者中的较小者</strong>。具体来说，写为代码就是 <code>columns &gt; start * 2 &amp;&amp; rows &gt; start * 2</code>（注意坐标从0开始），不满足这个条件时退出循环即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMatrixClockwisely</span><span class="params">(<span class="keyword">int</span>** numbers, <span class="keyword">int</span> columns, <span class="keyword">int</span> rows)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">NULL</span> || columns &lt;= <span class="number">0</span> || rows &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(columns &gt; start * <span class="number">2</span> &amp;&amp; rows &gt; start * <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PrintMatrixInCircle(numbers, columns, rows, start);</span><br><span class="line"></span><br><span class="line">        ++start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了某一层左上角的坐标之后，怎么顺时针打印这一层的数字呢？可以分为四个操作。</p>
<ol>
<li>从左到右打印一行</li>
<li>从上到下打印一列</li>
<li>从右到左打印一行</li>
<li>从下到上打印一列</li>
</ol>
<p>但是，必须注意到，<strong>不是所有情况下都能完整地进行这四个操作的</strong>。当行列数不同时，<strong>最内层的矩阵有可能退化为只有一行/一列甚至只有一个数字</strong>。那么进行每个操作的前提条件是什么呢？</p>
<p>操作1是必然会进行的，如果只有一行或一个数字，那么操作1结束后其他操作就不需要了；</p>
<p>进行操作2的前提是终止行号大于起始行号，即至少要有两行；</p>
<p>进行操作3的前提是至少有两行两列。只有1列的话，完成操作1和2就打印完了；</p>
<p>进行操作4的前提是至少有三行两列；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMatrixInCircle</span><span class="params">(<span class="keyword">int</span>** numbers, <span class="keyword">int</span> columns, <span class="keyword">int</span> rows, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> endX = columns - <span class="number">1</span> - start; <span class="comment">// 所在层的最大横坐标</span></span><br><span class="line">    <span class="keyword">int</span> endY = rows - <span class="number">1</span> - start;    <span class="comment">// 所在列的最大纵坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从左到右打印一行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= endX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> number = numbers[start][i];</span><br><span class="line">        printNumber(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从上到下打印一列</span></span><br><span class="line">    <span class="keyword">if</span>(start &lt; endY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= endY; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> number = numbers[i][endX];</span><br><span class="line">            printNumber(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从右到左打印一行</span></span><br><span class="line">    <span class="keyword">if</span>(start &lt; endX &amp;&amp; start &lt; endY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = endX - <span class="number">1</span>; i &gt;= start; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> number = numbers[endY][i];</span><br><span class="line">            printNumber(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从下到上打印一列</span></span><br><span class="line">    <span class="keyword">if</span>(start &lt; endX &amp;&amp; start &lt; endY - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = endY - <span class="number">1</span>; i &gt;= start + <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> number = numbers[i][start];</span><br><span class="line">            printNumber(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNumber</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题21包含min函数的栈">面试题21：包含min函数的栈</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min、push及pop的时间复杂度都是O(1)。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>要实现带min函数的栈，难度不仅在于每次入栈，最小元素都会变动；还在于每次出栈一个元素，最小元素也会变动。如果我们只用一个int类型来记录最小元素，那么出栈时我们就不得不把所有剩余元素都检查一遍才能更新最小元素。</p>
<p>更好的方法是在数据栈之外再维护一个辅助栈。每次把新元素压入数据栈，如果新元素比辅助栈的栈顶（当前最小元素）小，就把新元素也压入辅助栈；如果新元素较大，就把辅助栈栈顶元素再一次压入辅助栈。</p>
<p>出栈时，同时把数据栈和辅助栈的栈顶出栈即可。按照前面入栈的操作，此时辅助栈栈顶的元素必然也是数据栈中最小的元素。</p>
<p>要获取最小元素的值只需要访问辅助栈的栈顶就可以了。</p>
<p>以上三个操作的时间复杂度都是O(1)，符合题目要求。还有一个小细节需要注意一下，就是在调用pop和min时应检查一下栈是否非空。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">StackWithMin</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StackWithMin(<span class="keyword">void</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~StackWithMin(<span class="keyword">void</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T&amp; <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T&amp; <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">size_t</span> size() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;T&gt;   m_data;     <span class="comment">// 数据栈，存放栈的所有元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;T&gt;   m_min;      <span class="comment">// 辅助栈，存放栈的最小元素</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> StackWithMin&lt;T&gt;::push(<span class="keyword">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 把新元素添加到辅助栈</span></span><br><span class="line">    m_data.push(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当辅助栈为空或者新元素比之前的最小元素小时，把新元素插入辅助栈里；</span></span><br><span class="line">    <span class="comment">// 否则把之前的最小元素重复插入辅助栈里</span></span><br><span class="line">    <span class="keyword">if</span>(m_min.size() == <span class="number">0</span> || value &lt; m_min.top())</span><br><span class="line">        m_min.push(value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        m_min.push(m_min.top());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> StackWithMin&lt;T&gt;::pop()</span><br><span class="line">&#123;</span><br><span class="line">    assert(m_data.size() &gt; <span class="number">0</span> &amp;&amp; m_min.size() &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    m_data.pop();</span><br><span class="line">    m_min.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">const</span> T&amp; StackWithMin&lt;T&gt;::min() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(m_data.size() &gt; <span class="number">0</span> &amp;&amp; m_min.size() &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m_min.top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T&amp; StackWithMin&lt;T&gt;::top()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_data.top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">const</span> T&amp; StackWithMin&lt;T&gt;::top() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_data.top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> StackWithMin&lt;T&gt;::empty() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_data.empty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">size_t</span> StackWithMin&lt;T&gt;::size() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_data.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题22栈的压入-弹出序列">面试题22：栈的压入、弹出序列</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的数字均不想等。例如序列 <code>1、2、3、4、5</code> 是某栈的压栈序列，序列 <code>4、5、3、2、1</code> 是该压栈序列对应的一个弹出序列，但 <code>4、3、5、1、2</code> 就不可能是该压栈序列的弹出序列。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>要实现题目要求，其实思路还是蛮清晰的。我们每次检查弹出序列的头部元素，如果此时栈内没有该元素，就按照压栈序列的顺序将数字压入辅助栈，直到辅助栈的栈顶和弹出序列的头部元素相同。这时可以从辅助栈弹出一个元素，而弹出序列的头部也往后移动一位，继续下一次检查。</p>
<p>要注意循环的终止条件和匹配成功的条件。当匹配完弹出序列最后一位时顺利退出，但此时还应检查压栈序列的数是否已全部用完，否则仍然不算成功匹配；另外，在压栈的过程中，有可能压入了所有数字后仍然无法匹配到弹出序列，此时也应退出循环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* pPush, <span class="keyword">const</span> <span class="keyword">int</span>* pPop, <span class="keyword">int</span> nLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> bPossible = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pPush != <span class="literal">NULL</span> &amp;&amp; pPop != <span class="literal">NULL</span> &amp;&amp; nLength &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>* pNextPush = pPush;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>* pNextPop = pPop;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stackData;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 全部pop完就停止</span></span><br><span class="line">        <span class="keyword">while</span>(pNextPop - pPop &lt; nLength)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当辅助栈的栈顶元素不是要弹出的元素</span></span><br><span class="line">            <span class="comment">// 先压入一些数字入栈</span></span><br><span class="line">            <span class="keyword">while</span>(stackData.empty() || stackData.top() != *pNextPop)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果所有数字都压入辅助栈了，退出循环</span></span><br><span class="line">                <span class="keyword">if</span>(pNextPush - pPush == nLength)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                stackData.push(*pNextPush);</span><br><span class="line"></span><br><span class="line">                pNextPush ++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 所有数字都已压入辅助栈却无法与弹出序列匹配就直接退出</span></span><br><span class="line">            <span class="keyword">if</span>(stackData.top() != *pNextPop)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            stackData.pop();</span><br><span class="line">            pNextPop ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 辅助栈空了，并且弹出序列也匹配到了最后，就说明匹配成功</span></span><br><span class="line">        <span class="keyword">if</span>(stackData.empty() &amp;&amp; pNextPop - pPop == nLength)</span><br><span class="line">            bPossible = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bPossible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题23从上往下打印二叉树">面试题23：从上往下打印二叉树</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。例如输入下面的二叉树，则依次打印出 <code>8、6、10、5、7、9、11</code>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     8</span><br><span class="line">   /   \</span><br><span class="line">  6     10</span><br><span class="line"> / \    / \</span><br><span class="line">5   7  9  11</span><br></pre></td></tr></table></figure>
<blockquote>
<p>二叉树结点的定义如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                    m_nValue;</span><br><span class="line">    BinaryTreeNode*        m_pLeft;</span><br><span class="line">    BinaryTreeNode*        m_pRight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解析">解析</h3>
<p>这题比较简单，其实就是BFS遍历二叉树，我们可以用队列进行模拟。每次出队队首元素，打印该元素，如果它有子结点，就把子结点放到队列尾部。然后继续下一次出队即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintFromTopToBottom</span><span class="params">(BinaryTreeNode* pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;BinaryTreeNode *&gt; dequeTreeNode;</span><br><span class="line"></span><br><span class="line">    dequeTreeNode.push_back(pRoot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(dequeTreeNode.size())</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode *pNode = dequeTreeNode.front();</span><br><span class="line">        dequeTreeNode.pop_front();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, pNode-&gt;m_nValue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;m_pLeft)</span><br><span class="line">            dequeTreeNode.push_back(pNode-&gt;m_pLeft);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;m_pRight)</span><br><span class="line">            dequeTreeNode.push_back(pNode-&gt;m_pRight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题24二叉搜索树的后序遍历序列">面试题24：二叉搜索树的后序遍历序列</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true，否则返回false。假设输入的数组的任意两个数字都互不相同。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>先举个例子吧，给定一棵BST：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     8</span><br><span class="line">   /   \</span><br><span class="line">  6     10</span><br><span class="line"> / \    / \</span><br><span class="line">5   7  9  11</span><br></pre></td></tr></table></figure>
<p>可以看到，它的特点就是：<strong>对于任意一个有子结点的结点来说，左子树上的元素都比它小，右子树上的元素都比它大</strong>。</p>
<p>它的后序遍历序列是 <code>5,7,6,9,11,10,8</code>，我们发现最后一个点对应着BST的根结点，而前面的序列可以分为两部分，<strong>由第一个大于根结点的数开始是右子树，前面的部分是左子树</strong>。</p>
<p>题目要求的是判断一个序列是否BST的后序遍历序列，我们可以基于上面说到的规律利用递归的方式来实现：</p>
<ol>
<li>每次接收到一个序列，首先取出根结点（序列的最后一个元素）；</li>
<li>然后在除根结点外的序列中找出第一个比根结点大的元素（有可能没有，也即右子树为空），把序列分割为左子树部分和右子树部分；</li>
<li>然后检查右子树部分是否所有元素都比根结点大（左子树在步骤2已经完成检验了）；</li>
<li>通过步骤3，则递归判断左右子树两个序列是否BST，注意检查是否有左右子树；</li>
<li>未通过步骤3，则返回错误。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BST：Binary Search Tree，二叉搜索树</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> sequence[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sequence == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> root = sequence[length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在二叉搜索树中左子树的结点小于根结点</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; length - <span class="number">1</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence[i] &gt; root)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在二叉搜索树中右子树的结点大于根结点</span></span><br><span class="line">    <span class="keyword">int</span> j = i;</span><br><span class="line">    <span class="keyword">for</span>(; j &lt; length - <span class="number">1</span>; ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence[j] &lt; root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断左子树是不是二叉搜索树</span></span><br><span class="line">    <span class="keyword">bool</span> left = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">        left = VerifySquenceOfBST(sequence, i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断右子树是不是二叉搜索树</span></span><br><span class="line">    <span class="keyword">bool</span> right = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; length - <span class="number">1</span>)</span><br><span class="line">        right = VerifySquenceOfBST(sequence + i, length - i - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (left &amp;&amp; right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题25二叉树中和为某一值的路径">面试题25：二叉树中和为某一值的路径</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。二叉树结点的定义如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                    m_nValue;</span><br><span class="line">    BinaryTreeNode*        m_pLeft;</span><br><span class="line">    BinaryTreeNode*        m_pRight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解析">解析</h3>
<p>由于题目要求打印出所有符合要求的路径，所以我们需要遍历整棵树。而且我们需要对每条路径上的点进行求和。有没有办法可以同时实现这两点呢？</p>
<p>我们可以使用DFS进行前序遍历，这样就能对单条路径上的点进行求和了，当需要计算另外一条路径时，我们只需要把不属于另一路径的点丢掉就可以了。</p>
<p>具体来说：我们用前序遍历访问到某一结点时，把该结点添加到路径上，并累加它的值。</p>
<ul>
<li>如果当前结点是叶结点，并且路径中结点值的和为输入的整数，则将路径打印出来；</li>
<li>如果当前结点不是叶结点，则继续访问它的左右子结点。</li>
</ul>
<p>在访问完当前结点后，递归函数会自动返回到它的父结点处，我们需要做的就是在返回之前把它从路径中拿走，并且从结点和中减去该结点的值。</p>
<p>我们可以使用vector来存储路径，迭代器允许我们输出vector的每一个点。此外，一定要特别注意哪些参数需使用引用传递，哪些采用值传递。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindPath</span><span class="params">(BinaryTreeNode* pRoot, <span class="keyword">int</span> expectedSum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">int</span> currentSum = <span class="number">0</span>;</span><br><span class="line">    FindPath(pRoot, expectedSum, path, currentSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindPath</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BinaryTreeNode*   pRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>               expectedSum,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>&amp;              currentSum</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    currentSum += pRoot-&gt;m_nValue;</span><br><span class="line">    path.push_back(pRoot-&gt;m_nValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是叶结点，并且路径上结点的和等于输入的值</span></span><br><span class="line">    <span class="comment">// 打印出这条路径</span></span><br><span class="line">    <span class="keyword">bool</span> isLeaf = pRoot-&gt;m_pLeft == <span class="literal">NULL</span> &amp;&amp; pRoot-&gt;m_pRight == <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(currentSum == expectedSum &amp;&amp; isLeaf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"A path is found: "</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = path.begin();</span><br><span class="line">        <span class="keyword">for</span>(; iter != path.end(); ++ iter)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, *iter);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是叶结点，则遍历它的子结点</span></span><br><span class="line">    <span class="keyword">if</span>(pRoot-&gt;m_pLeft != <span class="literal">NULL</span>)</span><br><span class="line">        FindPath(pRoot-&gt;m_pLeft, expectedSum, path, currentSum);</span><br><span class="line">    <span class="keyword">if</span>(pRoot-&gt;m_pRight != <span class="literal">NULL</span>)</span><br><span class="line">        FindPath(pRoot-&gt;m_pRight, expectedSum, path, currentSum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在返回到父结点之前，在路径上删除当前结点，</span></span><br><span class="line">    <span class="comment">// 并在currentSum中减去当前结点的值</span></span><br><span class="line">    currentSum -= pRoot-&gt;m_nValue;</span><br><span class="line">    path.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题26复杂链表的复制">面试题26：复杂链表的复制</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>请实现函数 <code>ComplexListNode* Clone(ComplexListNode* pHead)</code>，复制一个复杂链表。在复杂链表中，每个结点除了有一个 <code>m_pNext</code> 指针指向下一个结点外，还有一个 <code>m_pSibling</code> 指向链表中的任意结点或者NULL。结点的C++定义如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ComplexListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                 m_nValue;</span><br><span class="line">    ComplexListNode*    m_pNext;</span><br><span class="line">    ComplexListNode*    m_pSibling;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解析">解析</h3>
<p>首先要清楚复制的意思，不是简单的声明一个头结点，然后赋值为给出链表的头结点就可以了。这样操作时依然会影响到原链表。要真的实现复制，就必须另外构造一个新的链表。</p>
<p>最简单的做法是分两个步骤，第一步先逐个构造新链表的结点，赋值为原链表中对应的值；第二步，根据原链表中每个结点的指向，对新链表各结点的sibling指针复制。第二步的时间复杂度是O(n^2)，因为每次找新链表中的sibling，都需要遍历一次新链表。</p>
<p>有没有O(n)的解法呢？有的。</p>
<p>这个方法具体来说分为三步，要充分理解整个流程最好是画图出来对照着看：</p>
<ol>
<li>
<p>在原链表上复制每个结点，把复制结点的next指针指向对应原结点的next结点，对应原结点的next指针指向复制结点。比如：<br><br>
复制前：<code>1 -&gt; 2 -&gt; 3 -&gt; 4</code><br><br>
复制后：<code>1 -&gt; 1 -&gt; 2 -&gt; 2 -&gt; 3 -&gt; 3 -&gt; 4 -&gt; 4</code></p>
</li>
<li>
<p>遍历一次复制后的链表，为每个复制结点设置sibling指针，因为复制的sibling结点就在原链表sibling结点的后面，所以可以在O(1)时间内找到。</p>
</li>
<li>
<p>把链表分割为原链表和复制链表，只需要遍历一遍链表，重新设置next指针即可。</p>
</li>
</ol>
<p>以上三个步骤都只需遍历一次链表，因此它的时间复杂度是O(n)的。一定要注意对空指针的处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ComplexListNode* <span class="title">Clone</span><span class="params">(ComplexListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CloneNodes(pHead);</span><br><span class="line">    ConnectSiblingNodes(pHead);</span><br><span class="line">    <span class="keyword">return</span> ReconnectNodes(pHead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CloneNodes</span><span class="params">(ComplexListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ComplexListNode* pNode = pHead;</span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ComplexListNode* pCloned = <span class="keyword">new</span> ComplexListNode();</span><br><span class="line">        pCloned-&gt;m_nValue = pNode-&gt;m_nValue;</span><br><span class="line">        pCloned-&gt;m_pNext = pNode-&gt;m_pNext;</span><br><span class="line">        pCloned-&gt;m_pSibling = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        pNode-&gt;m_pNext = pCloned;</span><br><span class="line"></span><br><span class="line">        pNode = pCloned-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConnectSiblingNodes</span><span class="params">(ComplexListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ComplexListNode* pNode = pHead;</span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ComplexListNode* pCloned = pNode-&gt;m_pNext;</span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;m_pSibling != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pCloned-&gt;m_pSibling = pNode-&gt;m_pSibling-&gt;m_pNext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pNode = pCloned-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ComplexListNode* <span class="title">ReconnectNodes</span><span class="params">(ComplexListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ComplexListNode* pNode = pHead;</span><br><span class="line">    ComplexListNode* pClonedHead = <span class="literal">NULL</span>;</span><br><span class="line">    ComplexListNode* pClonedNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先分割出复制链表的链表头</span></span><br><span class="line">    <span class="keyword">if</span>(pNode != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pClonedHead = pClonedNode = pNode-&gt;m_pNext;</span><br><span class="line">        pNode-&gt;m_pNext = pClonedNode-&gt;m_pNext;</span><br><span class="line">        pNode = pNode-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐步把复制链表和原链表分割开来</span></span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pClonedNode-&gt;m_pNext = pNode-&gt;m_pNext;</span><br><span class="line">        pClonedNode = pClonedNode-&gt;m_pNext;</span><br><span class="line"></span><br><span class="line">        pNode-&gt;m_pNext = pClonedNode-&gt;m_pNext;</span><br><span class="line">        pNode = pNode-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pClonedHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题27二叉搜索树与双向链表">面试题27：二叉搜索树与双向链表</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整书中结点指针的指向。比如二叉搜索树：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     10</span><br><span class="line">   /    \</span><br><span class="line">  6      14</span><br><span class="line"> / \    /  \</span><br><span class="line">4   8  12  16</span><br></pre></td></tr></table></figure>
<p>转换为双向链表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 ⇆ 6 ⇆ 8 ⇆ 10 ⇆ 12 ⇆ 14 ⇆ 16</span><br></pre></td></tr></table></figure>
<blockquote>
<p>二叉树结点的定义如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                    m_nValue;</span><br><span class="line">    BinaryTreeNode*        m_pLeft;</span><br><span class="line">    BinaryTreeNode*        m_pRight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解析">解析</h3>
<p>我们可以首先观察一下BST和对应双向链表的关系，不难发现双向链表的顺序其实就是BST的中序遍历顺序。在转换的时候，我们按着中序遍历的顺序来走，把BST中每个结点的左子结点设置为遍历的上一个结点，右子结点设置为遍历的下一个结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">Convert</span><span class="params">(BinaryTreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinaryTreeNode *pLastNodeInList = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 注意这里是按引用传递指针，因为我们希望它在函数中</span></span><br><span class="line">    <span class="comment">// 的修改能够保留下来。</span></span><br><span class="line">    ConvertNode(pRootOfTree, &amp;pLastNodeInList);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pLastNodeInList指向双向链表的尾结点，</span></span><br><span class="line">    <span class="comment">// 我们需要返回头结点，一路往左即可</span></span><br><span class="line">    BinaryTreeNode *pHeadOfList = pLastNodeInList;</span><br><span class="line">    <span class="keyword">while</span>(pHeadOfList != <span class="literal">NULL</span> &amp;&amp; pHeadOfList-&gt;m_pLeft != <span class="literal">NULL</span>)</span><br><span class="line">        pHeadOfList = pHeadOfList-&gt;m_pLeft;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pHeadOfList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConvertNode</span><span class="params">(BinaryTreeNode* pNode, BinaryTreeNode** pLastNodeInList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pNode == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    BinaryTreeNode *pCurrent = pNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 中序遍历BST ***/</span></span><br><span class="line">    <span class="comment">// 先访问左子树，把左子树转换为有序链表</span></span><br><span class="line">    <span class="keyword">if</span> (pCurrent-&gt;m_pLeft != <span class="literal">NULL</span>)</span><br><span class="line">        ConvertNode(pCurrent-&gt;m_pLeft, pLastNodeInList);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把左子结点设置为中序遍历的上一个结点</span></span><br><span class="line">    <span class="comment">// 左子结点非空时，把左子结点的右子结点设置为当前结点</span></span><br><span class="line">    pCurrent-&gt;m_pLeft = *pLastNodeInList;</span><br><span class="line">    <span class="keyword">if</span>(*pLastNodeInList != <span class="literal">NULL</span>)</span><br><span class="line">        (*pLastNodeInList)-&gt;m_pRight = pCurrent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问当前结点，链表尾变为当前结点</span></span><br><span class="line">    *pLastNodeInList = pCurrent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后访问右子树，把右子树也转换为有序链表</span></span><br><span class="line">    <span class="keyword">if</span> (pCurrent-&gt;m_pRight != <span class="literal">NULL</span>)</span><br><span class="line">        ConvertNode(pCurrent-&gt;m_pRight, pLastNodeInList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果对为什么要传递指针变量的地址还有疑惑，不妨看看下面这个程序的效果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> b, <span class="keyword">int</span>* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    c = &amp;b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2: "</span>  &lt;&lt; *c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> b, <span class="keyword">int</span>** c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *c = &amp;b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"4: "</span>  &lt;&lt; **c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *c = &amp;a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1: "</span> &lt;&lt; *c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    func1(b, c);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3: "</span>  &lt;&lt; *c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    func2(b,&amp;c);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"5: "</span>  &lt;&lt; *c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="number">5</span></span><br><span class="line"><span class="number">2</span>: <span class="number">4</span></span><br><span class="line"><span class="number">3</span>: <span class="number">5</span></span><br><span class="line"><span class="number">4</span>: <span class="number">4</span></span><br><span class="line"><span class="number">5</span>: <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>只有按引用传递指针变量时，在函数中修改指针指向才会生效</strong>。</p>
<h2 id="面试题28字符串的排列">面试题28：字符串的排列</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出有字符a、b、c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>这题有一定难度，最好还是举例来分析，并检验代码是否能得到正确结果。</p>
<p>思路是这样的：</p>
<ol>
<li>依次选择字符串中一个字符作为首字符固定下来</li>
<li>从余下字符中依次选择一个字符作为第2个字符固定下来</li>
<li>从余下字符中依次选择一个字符作为第3个字符固定下来<br><br>
… …</li>
<li>当余下字符只剩下结束符<code>'\0'</code>时，整个字符串已经固定好，可以打印。</li>
<li>回到上一层中，尝试另一个字符</li>
</ol>
<p>采用递归的方式来实现就可以了。注意！在递归中，我们采取的方式是把固定部分以外的字符串的第一个字符依次替换为剩余字符中的一个，这就改变了原来的字符串，如果我们尝试完这一轮（即固定替换字符时的所有排列组合）递归后没有把字符换回来，回溯时就会发生错乱，从而影响到下一层（即固定部分最后一个字符的下一种可能）的递归（这里需要自己举例分析一下）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="keyword">char</span>* pStr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pStr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Permutation(pStr, pStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="keyword">char</span>* pStr, <span class="keyword">char</span>* pBegin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*pBegin == <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, pStr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 固定pBegin前的字符串，尝试pBegin处字符的所有可能取值</span></span><br><span class="line">        <span class="comment">// 注意取值只能从pBegin及其后的字符中选取，否则就会和出现</span></span><br><span class="line">        <span class="comment">// 重复打印。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span>* pCh = pBegin; *pCh != <span class="string">'\0'</span>; ++ pCh)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将字符交换到pBegin处</span></span><br><span class="line">            <span class="keyword">char</span> temp = *pCh;</span><br><span class="line">            *pCh = *pBegin;</span><br><span class="line">            *pBegin = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 固定新的字符，继续递归直到固定所有字符</span></span><br><span class="line">            Permutation(pStr, pBegin + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把pBegin换回来，否则会影响到下一轮的递归</span></span><br><span class="line">            <span class="comment">// 从而造成重复打印字符串。</span></span><br><span class="line">            temp = *pCh;</span><br><span class="line">            *pCh = *pBegin;</span><br><span class="line">            *pBegin = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/06/工作求职/剑指offer/3_高质量的代码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/06/工作求职/剑指offer/3_高质量的代码/" itemprop="url">剑指offer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-06T11:11:41+08:00">
                2020-07-06
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-07-06T11:34:45+08:00" content="2020-07-06">
                2020-07-06
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="高质量的代码">高质量的代码</h1>
<h2 id="面试题11数值的整数次方">面试题11：数值的整数次方</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>实现函数 <code>double Power(double base, int exponent)</code>，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>乍看之下，这道题其实挺简单的，似乎写个循环就好了，但其实包含了很多小的细节。</p>
<p>比方说从减少时间复杂度的角度考虑，直接用循环求一个数的n次方，复杂度是O(n)；而如果采用<strong>快速求幂</strong>：</p>
<ol>
<li>a^n = a^(n/2) · a^(n/2),    n为偶数</li>
<li>a^n = a^(n/2) · a^(n/2) · a, n为奇数</li>
</ol>
<p>复杂度就变为了O(log n)</p>
<p>更深入地，如何判断一个数是奇数还是偶数呢？直接<strong>用求余运算符（%）的效率不如使用位运算</strong>。我们可以通过判断一个数与1相与的结果来判断，因为奇数的二进制表示最右边一位必然是1。</p>
<p>有了上面这些分析，基本的框架就搭起来了。但是！还有很多细节没注意到！</p>
<p>如果指数为0，应该怎么处理呢？指数是负数的话前面的计算方法还成立吗？如果底数为0，又应该怎么处理呢？</p>
<p>首先，指数为0的求幂应该返回结果1，特别地，0的0次方在数学上是没有意义的，返回0或者1都可以，具体可以跟面试官沟通一下。</p>
<p>然后，对于指数为负的状况，我们可以先把指数变为绝对值，然后求幂，最后取倒数即可。特别地，取倒数时<strong>不应该用1作为被除数</strong>，而应用1.0。因为题目中给出的底数是double类型，返回值也是double类型。如果我们用1作为被除数，那么当底数是1是，求倒数得到的就会变成了int类型。</p>
<p>最后，针对底数为0的问题，我们要注意到<strong>对0求负数幂是不可能的</strong>，因为0无法作为分母。这时候应该返回什么呢？可以选择返回0，但是怎样<strong>和正常返回0的情况作区分</strong>呢？我们可以再设置一个全局标志。虽然直接返回数值允许我们在调用这个函数时可以直接赋值，但如果<strong>忘记检查全局标志</strong>依然会出错。</p>
<p>最后的最后，还有一个小细节，在检查底数是否为0时，不能直接使用 <code>base == 0</code> 来判定。因为<strong>计算机中表示小数（double类型和float类型）是有误差的</strong>，所以如果要判断两个小数是否相等，我们应该看它们的<strong>差的绝对值是否足够小</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> g_InvalidInput = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_InvalidInput = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(equal(base, <span class="number">0.0</span>) &amp;&amp; exponent &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        g_InvalidInput = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> absExponent = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(exponent);</span><br><span class="line">    <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)</span><br><span class="line">        absExponent = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(-exponent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> result = PowerWithUnsignedExponent(base, absExponent);</span><br><span class="line">    <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)</span><br><span class="line">        result = <span class="number">1.0</span> / result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">PowerWithUnsignedExponent</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">unsigned</span> <span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> result = PowerWithUnsignedExponent(base, exponent &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    result *= result;</span><br><span class="line">    <span class="keyword">if</span>((exponent &amp; <span class="number">0x1</span>) == <span class="number">1</span>)</span><br><span class="line">        result *= base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((num1 - num2 &gt; <span class="number">-0.0000001</span>)</span><br><span class="line">        &amp;&amp; (num1 - num2 &lt; <span class="number">0.0000001</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题12打印1到最大的n位数">面试题12：打印1到最大的n位数</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>初看这条题，容易产生好简单的错觉。如果我们不需要考虑<strong>大数问题</strong>，那这条题将没有任何难度。而事实上，题目所说的n位数很可能是超出int甚至long long所能表示的，因此我们只能用字符串或者数组来进行表示了。</p>
<p>考虑字符串表示的方法，最直观的做法是<strong>模拟加法</strong>来实现，代码中的解法一就是这样做的。但是这样写的代码不太简洁，有没有更好的思路呢？</p>
<p>其实，题目要求按顺序打印出从1最大的n位十进制数，这个数的每一位无非就只有10种可能，也即我们可以把它想像成一个<strong>排列组合问题</strong>。只要我们按顺序罗列出所有排列组合就可以了。</p>
<p>可以使用<strong>递归</strong>的方式来实现，递归结束的条件就是设置完最后一位的数值。</p>
<p>最后要注意，使用字符串来表示数字，从索引0到n-1分别对应着数字的最高位到最低位。但不是所有数都是n位数，有可能是两位数、三位数等等，因此输出时要把高位的0过滤掉。特别注意，按照前面的思路，我们有可能得到n位全是0这种排列，按题目要求是从1开始输出，所以我们也要注意避免输出数字0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigits_2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="comment">// 避免不合法的输入</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* number = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line">    number[n] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次尝试最高位数字的10种可能</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        number[<span class="number">0</span>] = i + <span class="string">'0'</span>; <span class="comment">//int转为对应char</span></span><br><span class="line">        Print1ToMaxOfNDigitsRecursively(number, n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用递归来完成数字各个位置的设置，并尝试所有的可能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigitsRecursively</span><span class="params">(<span class="keyword">char</span>* number, <span class="keyword">int</span> length, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 索引为length-1时，数字设置完成，打印当前数字</span></span><br><span class="line">    <span class="keyword">if</span>(index == length - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PrintNumber(number);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未设置完成则依次尝试右边一位的10种可能</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        number[index + <span class="number">1</span>] = i + <span class="string">'0'</span>;</span><br><span class="line">        Print1ToMaxOfNDigitsRecursively(number, length, index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串number表示一个数字，数字有若干个0开头</span></span><br><span class="line"><span class="comment">// 打印出这个数字，并忽略开头的0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintNumber</span><span class="params">(<span class="keyword">char</span>* number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isBeginning0 = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> nLength = <span class="built_in">strlen</span>(number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isBeginning0 &amp;&amp; number[i] != <span class="string">'0'</span>)</span><br><span class="line">            isBeginning0 = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!isBeginning0)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, number[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!isBeginning0)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\t"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题13在o1时间删除链表结点">面试题13：在O(1)时间删除链表结点</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。链表结点与函数的定义如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>       m_nValue;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void DeleteNode(ListNode** pListHead, ListNode* pToBeDeleted);</span><br></pre></td></tr></table></figure>
<h3 id="解析">解析</h3>
<p>最常规的一种思路是遍历链表找到这个结点，删除它并把它前一结点的指针指向下一结点。但这样做复杂度是O(n)，而题目要求的是O(1)的时间复杂度，怎么做到呢？</p>
<p>其实不难，所谓O(1)意思是<strong>处理的时间与输入规模无关</strong>。我们可以直接从要删除的结点下手，把下一结点的内容复制到要删除的结点中，然后把要删除的结点的指针指向下下个结点，并把下一结点删除掉。这样做和前面的效果是一样的。</p>
<p>但是！注意了，如果<strong>要删除的结点是尾</strong>结点就无法这样做了，因为没有下一结点，这时只能顺序遍历来删除。还有一个细节，如果<strong>链表只有一个结点</strong>，那么除了删除，还要把头结点设置为NULL。</p>
<p>此外，以上分析都是基于链表中存在待删除结点来讨论的，如果要删除的结点不在链表中就会出错，这就需要调用函数的人自己注意了。要确定一个结点是否在链表中还是需要O(n)的时间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(ListNode** pListHead, ListNode* pToBeDeleted)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pListHead || !pToBeDeleted)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要删除的结点不是尾结点</span></span><br><span class="line">    <span class="keyword">if</span>(pToBeDeleted-&gt;m_pNext != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pNext = pToBeDeleted-&gt;m_pNext;</span><br><span class="line">        pToBeDeleted-&gt;m_nValue = pNext-&gt;m_nValue;</span><br><span class="line">        pToBeDeleted-&gt;m_pNext = pNext-&gt;m_pNext;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> pNext;</span><br><span class="line">        pNext = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表只有一个结点，删除头结点（也是尾结点）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(*pListHead == pToBeDeleted)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pToBeDeleted;</span><br><span class="line">        pToBeDeleted = <span class="literal">NULL</span>;</span><br><span class="line">        *pListHead = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表中有多个结点，删除尾结点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pNode = *pListHead;</span><br><span class="line">        <span class="keyword">while</span>(pNode-&gt;m_pNext != pToBeDeleted)</span><br><span class="line">        &#123;</span><br><span class="line">            pNode = pNode-&gt;m_pNext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pNode-&gt;m_pNext = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">delete</span> pToBeDeleted;</span><br><span class="line">        pToBeDeleted = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题14调整数组顺序使奇数位于偶数前面">面试题14：调整数组顺序使奇数位于偶数前面</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>这条题的思路其实不难，我们<strong>维护两个指针</strong>即可。指针1初始化指向数组的第一个元素，并向后移动；指针2初始化指向数组的最后一个元素，并向前移动。</p>
<p>首先往后移动指针1，当指针1指向偶数时，开始往前移动指针2，直至指针2指向奇数。注意，在这两个过程中，有可能指针1和指针2会相遇，这表示数组已经调整完毕。如果没有相遇，就证明还需继续调整，将此时指针1和指针2所指的数字交换位置，再继续下一轮的查找，直至两指针相遇时结束。</p>
<p>这道题其实可以做很多扩展，可能不是针对奇偶数重排，而是素数非素数，正数负数等等。<strong>考虑扩展性</strong>的话，我们不妨把判断部分分离出来写成一个函数，在重排时<strong>把判断函数作为一个参数传入</strong>即可。</p>
<p>具体来说，这里依然使用位运算来实现判断奇偶，把这个操作封装为一个函数，传入参数为int型变量，返回值为bool型变量。</p>
<p>在声明重排函数的参数时，格式就是 <code>返回值类型 (*函数别名)(函数的参数类型)</code>。其中函数别名根据自己喜欢来取就可以了。</p>
<p>在调用重排函数时，我们传入函数名就可以了，不需要作其他处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReorderOddEven_2</span><span class="params">(<span class="keyword">int</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Reorder(pData, length, isEven);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reorder</span><span class="params">(<span class="keyword">int</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">int</span> length, <span class="keyword">bool</span> (*func)(<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pData == <span class="literal">NULL</span> || length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *pBegin = pData;</span><br><span class="line">    <span class="keyword">int</span> *pEnd = pData + length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pBegin &lt; pEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 向后移动pBegin</span></span><br><span class="line">        <span class="keyword">while</span>(pBegin &lt; pEnd &amp;&amp; !func(*pBegin))</span><br><span class="line">            pBegin ++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向前移动pEnd</span></span><br><span class="line">        <span class="keyword">while</span>(pBegin &lt; pEnd &amp;&amp; func(*pEnd))</span><br><span class="line">            pEnd --;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pBegin &lt; pEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = *pBegin;</span><br><span class="line">            *pBegin = *pEnd;</span><br><span class="line">            *pEnd = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题15链表中的倒数第k个结点">面试题15：链表中的倒数第k个结点</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>输入一个链表，输出该链表中倒数第k个结点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾结点是倒数第1个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个结点是值为4的结点。链表结点定义如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>       m_nValue;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解析">解析</h3>
<p>由于这是一个单向链表，所以就不存在先走到链表尾部，再倒退k-1步的可能了。</p>
<p>最普通的一个思路是，使用一个指针，先遍历一次整个链表，得到链表长度n。倒数第k个结点是链表中的第n-k+1个结点。我们只要然后重新从链表头开始走n-k步就能走到它了。</p>
<p>但是这样需要遍历两次，有没有<strong>只遍历一次</strong>就能找到它的方法呢？</p>
<p>有的。类似上一道题，我们维护两个指针就可以了。指针1先走，在指针1走了k-1步之后指针2再走。这样当指针1到底尾结点时，指针2所指的就是倒数第k个结点。</p>
<p>上面的解法有3个很大的漏洞：</p>
<ol>
<li>
<p><strong>链表头结点是空指针</strong>，遍历这样的链表会造成访问空指针指向的内存，引起程序崩溃，所以要额外处理。</p>
</li>
<li>
<p><strong>链表结点数目少于k</strong>，如果我们直接让指针1在循环中走k-1步而不加判断，同样会访问到空指针指向的内存。</p>
</li>
<li>
<p><strong>k为0</strong>，如果我们定义k是unsigned int型，那么k-1就是unsigned int型能表示的最大整数4294967295（即二进制的0xFFFFFFFF，最高位不需用于标识符号），循环的次数将会非常恐怖… 所以我们必须对k值是否合法也做一个判断。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pListHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 空指针处理和合法k值检查</span></span><br><span class="line">    <span class="keyword">if</span>(pListHead == <span class="literal">NULL</span> || k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ListNode *pAhead = pListHead;</span><br><span class="line">    ListNode *pBehind = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针1走k-1步</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pAhead-&gt;m_pNext != <span class="literal">NULL</span>) <span class="comment">// 对链表长度不足k作出处理</span></span><br><span class="line">            pAhead = pAhead-&gt;m_pNext;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针2开始走，直到指针1走到链表尾时停止</span></span><br><span class="line">    pBehind = pListHead;</span><br><span class="line">    <span class="keyword">while</span>(pAhead-&gt;m_pNext != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pAhead = pAhead-&gt;m_pNext;</span><br><span class="line">        pBehind = pBehind-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pBehind;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题16反转链表">面试题16：反转链表</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。链表结点定义如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>       m_nValue;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解析">解析</h3>
<p>关于链表的题目，其实最好画图来把过程中的各个步骤都理清楚。要实现反转链表，我们需要维护三个指针，一个指向当前结点，一个指向上一结点，还有一个指向下一结点。</p>
<p>当我们实现反转时，其实是把原链表中上一结点变成当前结点的下一结点，但这样就会使得链表发生断裂，原链表中下一结点就找不到了，所以我们要先记住它。</p>
<p>在每一个翻转过程中，有以下步骤：</p>
<ol>
<li>得到当前结点的下一结点</li>
<li>判断下一结点是否NULL，也即是否到达原链表的链表尾
<ul>
<li>若下一结点为NULL，说明当前结点就是反转链表的链表头</li>
</ul>
</li>
<li>把当前结点的指针指向上一结点</li>
<li>更新
<ul>
<li>当前结点变为上一结点</li>
<li>下一结点变为当前结点</li>
</ul>
</li>
<li>当前结点为NULL时结束，否则继续下一次反转</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* pReversedHead = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* pNode = pHead;</span><br><span class="line">    ListNode* pPrev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pNext = pNode-&gt;m_pNext;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pNext == <span class="literal">NULL</span>)</span><br><span class="line">            pReversedHead = pNode;</span><br><span class="line"></span><br><span class="line">        pNode-&gt;m_pNext = pPrev;</span><br><span class="line"></span><br><span class="line">        pPrev = pNode;</span><br><span class="line">        pNode = pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pReversedHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题17合并两个排序的链表">面试题17：合并两个排序的链表</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。例如下面的链表1和链表2可以合并为链表3。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">链表1： 1 -&gt; 3 -&gt; 5 -&gt; 7</span><br><span class="line">链表2： 2 -&gt; 4 -&gt; 6 -&gt; 8</span><br><span class="line">链表3： 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8</span><br></pre></td></tr></table></figure>
<blockquote>
<p>链表结点定义如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>       m_nValue;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解析">解析</h3>
<p>这题其实写成代码不算难，但还是要理清思路。合并两个<strong>递增排序链表</strong>，我们可以采取递归的方式。</p>
<p>令<strong>递归函数返回合并链表的链表头</strong>，在每次递归中，我们先对两个链表的链表头进行判断，取较小的一个作为合并链表的头结点（并在函数结束时返回）。然后，还要重新设置这个结点的next指针，它指向的是两个链表未被并入的结点中最小的那个结点。要实现这一点，我们只需要令这一轮头结点被并入的链表的头结点指针往后移动一个位置，然后继续递归合并两个链表就可以了。<strong>下一轮递归返回的链表头就是当前合并链表的头结点的next指针指向的结点</strong>。</p>
<p>关键是<strong>递归结束条件的设置</strong>，有以下三种情况：</p>
<ol>
<li>
<p>链表1的头结点为NULL而链表2不是，此时返回链表2的头结点即可，因为链表2本身也是递增排序，所以合并后依然能保持递增排序；</p>
</li>
<li>
<p>链表2的头结点为NULL而链表1不是，此时返回链表1的头结点即可，因为链1本身也是递增排序，所以合并后依然能保持递增排序；</p>
</li>
<li>
<p>链表1和链表2的头结点都是NULL，此时返回NULL即可。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里实际已经包含了三种递归结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(pHead1 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> pHead2;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pHead2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> pHead1;</span><br><span class="line"></span><br><span class="line">    ListNode* pMergedHead = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pHead1-&gt;m_nValue &lt; pHead2-&gt;m_nValue)</span><br><span class="line">    &#123;</span><br><span class="line">        pMergedHead = pHead1;</span><br><span class="line">        pMergedHead-&gt;m_pNext = Merge(pHead1-&gt;m_pNext, pHead2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pMergedHead = pHead2;</span><br><span class="line">        pMergedHead-&gt;m_pNext = Merge(pHead1, pHead2-&gt;m_pNext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pMergedHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题18树的子结构">面试题18：树的子结构</h2>
<blockquote>
<p>题目：输入两棵二叉树A和B，判断B是不是A的子结构。二叉树结点的定义如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                    m_nValue;</span><br><span class="line">    BinaryTreeNode*        m_pLeft;</span><br><span class="line">    BinaryTreeNode*        m_pRight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解析">解析</h3>
<p>树的结构要比链表更加复杂，但是只要分析得好，这一题不算太难。</p>
<p>我们将整个判断过程分为两个步骤：</p>
<ol>
<li>寻找树A中与树B根结点值相同的结点R；</li>
<li>分析树A中以结点R为根结点的子树是否和树B的结构一样。</li>
</ol>
<p>具体来说可以实现两个递归函数。</p>
<p>函数1执行步骤1。输入两棵树的根结点，如果树A根结点与B的不同，则把它左右子树的根结点作为树A的根节点传入函数1来递归查找；如果两棵树根结点相同就调用函数2。递归的终止条件有两种情形：</p>
<ol>
<li>树A或树B的根节点为NULL，有可能是因为输入了空指针，也可能是递归查找到达了树A的叶结点处仍然没匹配上，这两种情况都是返回false；</li>
<li>这一轮成功匹配上，匹配上之后就不需要再递归查找了，所以我们在 调用函数2得到结果后，先判断有没匹配成功，没有再看左子树，左子树也没有才看右子树。</li>
</ol>
<p>函数2执行步骤2。输入两棵树的当前结点，如果树B当前结点为NULL，说明匹配成功了；否则如果树A当前结点为NULL，说明A已经到叶结点但还没匹配完，也即匹配失败。另外，只要在这一轮中，两棵树的当前结点值不同，也算匹配失败。如果经过以上判断后，仍然没有得到匹配结果，那就说明目前还是能匹配上的，下一步继续递归地检查两棵树当前结点的左子树和右子树是否也能匹配。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果到了叶结点依然没匹配上或者传入的树是空指针就直接返回false</span></span><br><span class="line">    <span class="keyword">if</span>(pRoot1 != <span class="literal">NULL</span> &amp;&amp; pRoot2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1-&gt;m_nValue == pRoot2-&gt;m_nValue)</span><br><span class="line">            result = DoesTree1HaveTree2(pRoot1, pRoot2);</span><br><span class="line">        <span class="comment">// 实际隐藏了一个递归结束的条件</span></span><br><span class="line">        <span class="comment">// 成功匹配时，不会再继续递归搜索左右子树了</span></span><br><span class="line">        <span class="comment">// 因此成功匹配的那一轮就停下了并返回结果</span></span><br><span class="line">        <span class="keyword">if</span>(!result)</span><br><span class="line">            result = HasSubtree(pRoot1-&gt;m_pLeft, pRoot2);</span><br><span class="line">        <span class="keyword">if</span>(!result)</span><br><span class="line">            result = HasSubtree(pRoot1-&gt;m_pRight, pRoot2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DoesTree1HaveTree2</span><span class="params">(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pRoot1 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pRoot1-&gt;m_nValue != pRoot2-&gt;m_nValue)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DoesTree1HaveTree2(pRoot1-&gt;m_pLeft, pRoot2-&gt;m_pLeft) &amp;&amp;</span><br><span class="line">        DoesTree1HaveTree2(pRoot1-&gt;m_pRight, pRoot2-&gt;m_pRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/06/工作求职/剑指offer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/06/工作求职/剑指offer/" itemprop="url">工作求职/剑指offer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-06T11:11:41+08:00">
                2020-07-06
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-08-30T13:28:44+08:00" content="2020-08-30">
                2020-08-30
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>《工作求职/剑指offer》阅读笔记<br>
全书共8章，因此，我的笔记也分为相应的8个章节，可以从以下目录访问</p>
<h3 id="面试的流程"><a href="/2020/07/06/工作求职/剑指offer/1_面试的流程/" title="面试的流程">面试的流程</a></h3>
<p>面试环节以及注意问题</p>
<h3 id="面试需要的基础知识"><a href="/2020/07/06/工作求职/剑指offer/2_面试需要的基础知识/" title="面试需要的基础知识">面试需要的基础知识</a></h3>
<p>从编程语言、数据结构、算法三个方面总结程序员的面试知识点。</p>
<h3 id="高质量的代码"><a href="/2020/07/06/工作求职/剑指offer/3_高质量的代码/" title="高质量的代码">高质量的代码</a></h3>
<p>讨论影响代码质量的3个要素（规范性、完整性、鲁棒性），强调高质量代码除完成基本功能外，还能考虑特殊情况，并对非法输入进行合理处理。</p>
<h3 id="解决面试题的思路"><a href="/2020/07/06/工作求职/剑指offer/4_解决面试题的思路/" title="解决面试题的思路">解决面试题的思路</a></h3>
<p>总结编程面试中解决难题的有效思考模式，如在面试中遇到复杂难题，可以利用画图、举例和分解将其化繁为简，先形成清晰思路再动手编程。</p>
<h3 id="优化时间和空间效率"><a href="/2020/07/06/工作求职/剑指offer/5_优化时间和空间效率/" title="优化时间和空间效率">优化时间和空间效率</a></h3>
<p>介绍优化时间效率和用空间换时间的常用算法。</p>
<h3 id="面试中的各项能力"><a href="/2020/07/06/工作求职/剑指offer/6_面试中的各项能力/" title="面试中的各项能力">面试中的各项能力</a></h3>
<p>总结应聘者如何充分表现学习和沟通能力，并通过具体面试题讨论如何培养知识迁移、抽象建模和发散思维能力。</p>
<h3 id="两个面试案例"><a href="/2020/07/06/工作求职/剑指offer/7_两个面试案例/" title="两个面试案例">两个面试案例</a></h3>
<p>分析总结哪些面试举动是不良行为，而哪些表现又是面试官所期待的行为。</p>
<h3 id="英文版新增面试题"><a href="/2020/07/06/工作求职/剑指offer/8_英文版新增面试题/" title="英文版新增面试题">英文版新增面试题</a></h3>
<p>优选久经欧美知名企业面试考验的经典题目，帮助国内读者开阔视野、增补技能。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/06/工作求职/剑指offer/8_英文版新增面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/06/工作求职/剑指offer/8_英文版新增面试题/" itemprop="url">剑指offer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-06T11:11:41+08:00">
                2020-07-06
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-07-06T11:35:25+08:00" content="2020-07-06">
                2020-07-06
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="英文版新增面试题">英文版新增面试题</h1>
<h2 id="面试题51数组中重复的数字">面试题51：数组中重复的数字</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组 <code>{2,3,1,0,2,5,3}</code>，那么对应的输出是重复的数字2或者3。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>这里介绍一个复杂度O(n)的方法，思想和借助哈希表排序类似，但是由于题目给了非常棒的前提条件，在<strong>长度为n</strong>的数组里的<strong>所有数字都在0到n-1的范围内</strong>，如果没有重复元素，那么必定每个数字都能被放入自己对应的位置上，我们不需要额外的辅助内容。</p>
<p>具体来说，我们依次遍历数组，当数字i不在位置i上时，把它交换到位置i上；如果发现位置i上的数等于数字i，就说明找到重复元素了。</p>
<p>为什么这种方法遍历一次数组必然就能找到重复元素呢？因为如果存在两个重复数字，那么在把前面那一个放到正确位置上后，遍历到后面那一个时会再一次检查到这个位置，此时必然能发现数字的重复。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span>) <span class="comment">// 合法性检验</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)    <span class="comment">// 合法性检验</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] &lt; <span class="number">0</span> || numbers[i] &gt; length - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(numbers[i] != i) <span class="comment">// 如果数字已经和序号一致就不用处理了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果发现数字和对应位置上的数相等，就说明已经找到重复元素了</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == numbers[numbers[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                *duplication = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果不相等，就把数字交换到它正确的位置上</span></span><br><span class="line">            <span class="keyword">int</span> temp = numbers[i];</span><br><span class="line">            numbers[i] = numbers[temp];</span><br><span class="line">            numbers[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题52构建乘积数组">面试题52：构建乘积数组</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>给定一个数组 <code>A[0,1,...,n-1]</code>，请构建一个数组 <code>B[0,1,...,n-1]</code>，其中B中的元素 <code>B[i] = A[0] × A[1] × ... × A[i-1] × A[i+1] × ... × A[n-1]</code>。不能使用除法。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>一定要看清楚题目，这题要求数组B的每一个元素B[i]等于数组A除A[i]以外所有元素的积。</p>
<p>不能用除法，但是我们不妨从另外一个角度去想这个问题。<strong>B[i]根据i的位置可以划分为两部分来求解</strong>，它等于数组A中位置i之前的元素之积 * 数组A中位置i之后的元素之积。可以画出下图这样的矩阵：</p>
<p><img src="https://github.com/familyld/Coding_Interviews/blob/master/graph/52_ArrayConstruction.jpg?raw=true" alt="matrix"></p>
<p>矩阵第i行对应着B[i]乘积的各个因子，其中位置i用1来代替。按照上面说的那样，我们可以把B[i]分成两部分，假设B[i] = C[i] * D[i]。那么C就对应着数组A中位置i之前的元素之积，D就对应着数组A中位置i之后的元素之积（1同时算入C和D中）。</p>
<p>我们可以从上往下计算出C[i]，初始化 <code>C[0] = 1</code>，有通项公式 <code>C[i] = C[i-1] *A[i]</code>;</p>
<p>我们可以从下往上计算出D[i]，初始化 <code>D[n-1] = 1</code>，有通项公式 <code>D[i] = D[i+1] *A[i+1]</code>;</p>
<p>写成代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; array1, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; array2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length1= array1.size();</span><br><span class="line">    <span class="keyword">int</span> length2 = array2.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有两数组长度相等，且数组长度大于1才是合法输入</span></span><br><span class="line">    <span class="keyword">if</span>(length1 == length2 &amp;&amp; length2 &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        array2[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 初始化C[0]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length1; ++i)</span><br><span class="line">        &#123;   <span class="comment">// 对应从上往下计算出C[i]</span></span><br><span class="line">            array2[i] = array2[i - <span class="number">1</span>] * array1[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> temp = <span class="number">1</span>; <span class="comment">// 初始化D[n-1]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length1 - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            temp *= array1[i + <span class="number">1</span>]; <span class="comment">// 对应从下往上计算出D[i]</span></span><br><span class="line">            array2[i] *= temp;     <span class="comment">// 对应B[i] = C[i] * D[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题53正则表达式匹配">面试题53：正则表达式匹配</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>请实现一个函数用来匹配包含 <code>'.'</code> 和 <code>'*'</code> 的正则表达式。模式中的字符 <code>'.'</code> 表示任意一个字符，而 <code>'*'</code> 表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如字符串 <code>&quot;aaa&quot;</code> 与模式 <code>&quot;a.a&quot;</code> 和 <code>&quot;ab*ac*a&quot;</code> 匹配，但与 <code>&quot;aa.a&quot;</code> 及 <code>&quot;ab*a&quot;</code> 均不匹配。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>这题其实还是蛮好分析的，我们用两个指针分别指向字符串和模式，如果两个指针都走到最后，也即同时遇到结束符 <code>'\0</code> 则匹配成功；如果模式用完了，字符串还有未匹配上的部分，就匹配失败；两个指针都未到达最后时，我们需要注意以下 <code>'.'</code> 和 <code>'*'</code> 的处理。<code>'.'</code> 比较简单，因为想匹配什么都可以； <code>'*'</code> 的处理就复杂一点，因为我们有多种选择。每一轮匹配的流程可以概括如下：</p>
<hr>
<p>判断模式的下一位字符是否 <code>'*'</code> 号：</p>
<ul>
<li>是
<ul>
<li>当前字符可以匹配
<ol>
<li>模式的当前字符仅匹配一次（也即当*号不存在，字符串指针和模式指针各往后移一步）</li>
<li>模式的当前字符匹配多次（字符串指针往后移，模式指针不动）</li>
<li>模式的当前字符匹配零次（同时忽略模式当前字符和*号，字符串指针不动，模式指针后移两步）</li>
</ol>
</li>
<li>当前字符不能匹配
<ol>
<li>模式的当前字符匹配零次（同时忽略模式当前字符和*号，字符串指针不动，模式指针后移两步）</li>
</ol>
</li>
</ul>
</li>
<li>否
<ul>
<li>当前字符可以匹配
<ol>
<li>继续下一次匹配（字符串指针和模式指针各往后移一步）</li>
</ol>
</li>
<li>当前字符不能匹配
<ol>
<li>返回匹配失败</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<p>使用递归的方式来实现即可，特别注意一点，虽然 <code>'.'</code> 可以匹配字符串的任意字符，但是结束符 <code>'\0'</code> 是不属于字符串的内容部分的，在写判断条件时必须把这一点加上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">NULL</span> || pattern == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> matchCore(str, pattern);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 字符串和模式同时到达尾部，匹配成功</span></span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模式已经到了最后，字符串还有未匹配的字符，匹配失败</span></span><br><span class="line">    <span class="keyword">if</span>(*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模式的下一位是*号</span></span><br><span class="line">    <span class="keyword">if</span>(*(pattern + <span class="number">1</span>) == <span class="string">'*'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 模式能匹配当前字符，则分三种情况：匹配一个，匹配多个，匹配零个</span></span><br><span class="line">        <span class="keyword">if</span>(*pattern == *str || (*pattern == <span class="string">'.'</span> &amp;&amp; *str != <span class="string">'\0'</span>))</span><br><span class="line">                   <span class="comment">// move on the next state</span></span><br><span class="line">            <span class="keyword">return</span> matchCore(str + <span class="number">1</span>, pattern + <span class="number">2</span>)</span><br><span class="line">                   <span class="comment">// stay on the current state</span></span><br><span class="line">                || matchCore(str + <span class="number">1</span>, pattern)</span><br><span class="line">                   <span class="comment">// ignore a '*'</span></span><br><span class="line">                || matchCore(str, pattern + <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 模式不能匹配当前字符，忽略*号</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                   <span class="comment">// ignore a '*'</span></span><br><span class="line">            <span class="keyword">return</span> matchCore(str, pattern + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模式的下一位不是*号，但是能匹配当前字符，就继续匹配</span></span><br><span class="line">    <span class="keyword">if</span>(*str == *pattern || (*pattern == <span class="string">'.'</span> &amp;&amp; *str != <span class="string">'\0'</span>))</span><br><span class="line">        <span class="keyword">return</span> matchCore(str + <span class="number">1</span>, pattern + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模式的下一位不是*号，而且匹配不了当前字符，直接返回匹配失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题54表示数值的字符串">面试题54：表示数值的字符串</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串<code>&quot;+100&quot;</code>、<code>&quot;5e2&quot;</code>、<code>&quot;-123&quot;</code>、<code>&quot;3.1416&quot;</code>及<code>&quot;-1E-16&quot;</code>都表示数值，但<code>&quot;12e&quot;</code>、<code>&quot;1a3.14&quot;</code>、<code>&quot;1.2.3&quot;</code>、<code>&quot;+-5&quot;</code>及<code>&quot;12e+5.4&quot;</code>都不是。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>我们首先弄清楚怎样的字符串才表示数值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[符号位] 整数部分 [.小数部分] [e|E [符号位] 指数部分]</span><br></pre></td></tr></table></figure>
<p>可以概括如下：</p>
<ul>
<li>最前面一位可以是符号位，但不是必需的；</li>
<li>整数部分是最基础的，但<strong>一些小数可以不需要整数部分</strong>（比如：<code>.5</code>）；</li>
<li>整数部分后可以接小数点和小数部分，它们不是必需的，但<strong>出现了小数点就必须有小数部分</strong>；</li>
<li>整数部分后可以接指数符号和指数部分，它们不是必需的，但<strong>出现了指数符号就必须有指数部分</strong>；</li>
<li>指数部分最前面一位可以是符号位，但不是必需的；</li>
<li>除了正负号、数字、小数点、大小写指数符号外不能出现其他字符；</li>
<li>小数点、大小写指数符号最多出现一次，正负号在整数部分和指数部分也各最多出现一次。</li>
</ul>
<p>没有什么诀窍，按着这些规则编写代码，仔细检查有没有漏掉的情况就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存在符号位就先跳过</span></span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">'+'</span> || *str == <span class="string">'-'</span>)</span><br><span class="line">        ++str;</span><br><span class="line">    <span class="comment">// 如果只有符号位，则不是数值</span></span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> numeric = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> hasDigits = scanDigits(&amp;str); <span class="comment">// 跳过整数部分</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*str != <span class="string">'\0'</span>) <span class="comment">// 如果整数部分后还有字符</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 检测到小数点</span></span><br><span class="line">        <span class="keyword">if</span> (*str == <span class="string">'.'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++str; <span class="comment">// 跳过小数点</span></span><br><span class="line">            <span class="keyword">if</span> (*str == <span class="string">'e'</span> || *str == <span class="string">'E'</span>) <span class="comment">// 小数点后直接接指数部分，非数值</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!hasDigits &amp;&amp; *str == <span class="string">'\0'</span>) <span class="comment">// 没有整数部分也没有小数部分，非数值</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            scanDigits(&amp;str); <span class="comment">// 跳过小数部分</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测到指数符号</span></span><br><span class="line">            <span class="keyword">if</span> (*str == <span class="string">'e'</span> || *str == <span class="string">'E'</span>)</span><br><span class="line">                numeric = isExponential(&amp;str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测到指数符号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*str == <span class="string">'e'</span> || *str == <span class="string">'E'</span>)</span><br><span class="line">            numeric = isExponential(&amp;str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测到非法字符</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            numeric = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一直到字符串最后都没有出现非法字符</span></span><br><span class="line">    <span class="comment">// 如果出现了非法字符必然不会扫描到结束符</span></span><br><span class="line">    <span class="keyword">return</span> numeric &amp;&amp; *str == <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">scanDigits</span><span class="params">(<span class="keyword">char</span>** str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* pBefore = *str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过数字部分</span></span><br><span class="line">    <span class="keyword">while</span> (**str != <span class="string">'\0'</span> &amp;&amp; **str &gt;= <span class="string">'0'</span> &amp;&amp; **str &lt;= <span class="string">'9'</span>)</span><br><span class="line">        ++(*str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回是否存在数字部分（如果指针发生了移动就说明存在）</span></span><br><span class="line">    <span class="keyword">return</span> *str &gt; pBefore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isExponential</span><span class="params">(<span class="keyword">char</span>** str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (**str != <span class="string">'e'</span> &amp;&amp; **str != <span class="string">'E'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    ++(*str); <span class="comment">// 跳过指数符号</span></span><br><span class="line">    <span class="comment">// 如果存在符号位就提哦啊过符号位</span></span><br><span class="line">    <span class="keyword">if</span> (**str == <span class="string">'+'</span> || **str == <span class="string">'-'</span>)</span><br><span class="line">        ++(*str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 符号位后没有数字，也即没有指数部分，非数值</span></span><br><span class="line">    <span class="keyword">if</span> (**str == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过指数部分</span></span><br><span class="line">    scanDigits(str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果指数部分后面还有其它字符则非数值</span></span><br><span class="line">    <span class="keyword">return</span> (**str == <span class="string">'\0'</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题55字符流中第一个不重复的字符">面试题55：字符流中第一个不重复的字符</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，但从字符流中制度处前两个字符 <code>&quot;go&quot;</code> 时，第一个只出现一次的字符是 <code>'g'</code>。当从该字符流中读出前六个字符 <code>&quot;gooogle&quot;</code> 时，第一个只出现一次的字符是 <code>'l'</code>。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>这题其实不难，输入是数据流，所以也可以把它看作是一道大数据的题目，非常有意思。</p>
<p>这里我们实现一个类，通过维护一个哈希表和索引来实现题目的功能。因为是字符流，而字符只有256种可能，所以我们开一个长度为256的哈希表就可以了，索引则用来记录当前流过的字符在字符流中的位置。</p>
<p>哈希表的每一个格子对应一个字符的不同状态，比如做以下设定：</p>
<ol>
<li>字符未出现过，则哈希值为-1；</li>
<li>字符出现超过一次，则哈希值为-2；</li>
<li>字符仅出现了一次，哈希值为它在字符流中的位置（大于0）。</li>
</ol>
<p>这样，当我们从字符流中取得一个字符时，我们可以用O(1)时间来检查一下字符的哈希值，哈希值为-2则不再关心，只对索引进行更新（索引加一）；哈希值为-1则把哈希值更新为当前索引，然后索引加一。</p>
<p>当我们要求第一个只出现一次的字符时，我们同样可以用O(1)时间找到答案（与输入规模，也即字符流的长度无关）。我们只需要遍历一次哈希表，找到只出现一次，且出现位置最前（索引值最小）的那个字符就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CharStatistics</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CharStatistics() : index (<span class="number">0</span>) <span class="comment">// 构造时index初始化为0</span></span><br><span class="line">    &#123;   <span class="comment">// 哈希表全部初始化为-1，即未出现过</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)</span><br><span class="line">            occurrence[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 未出现过则把哈希表对应的值更新为在字符串中出现的位置</span></span><br><span class="line">        <span class="keyword">if</span>(occurrence[ch] == <span class="number">-1</span>)</span><br><span class="line">            occurrence[ch] = index;</span><br><span class="line">        <span class="comment">// 已经出现过则更新为-2，不再关心</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(occurrence[ch] &gt;= <span class="number">0</span>)</span><br><span class="line">            occurrence[ch] = <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">        index++; <span class="comment">// 没插入一个字符，索引加一</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch = <span class="string">'\0'</span>; <span class="comment">// 初始化为终止符</span></span><br><span class="line">        <span class="comment">// 把最小索引初始化为int型能表示的最大整数</span></span><br><span class="line">        <span class="keyword">int</span> minIndex = numeric_limits&lt;<span class="keyword">int</span>&gt;::max();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i) <span class="comment">// 遍历一次整个哈希表</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 每次找到一个只出现一次的数并且在字符串中位置比最小索引前</span></span><br><span class="line">            <span class="comment">// 就更新字符和最小索引</span></span><br><span class="line">            <span class="keyword">if</span>(occurrence[i] &gt;= <span class="number">0</span> &amp;&amp; occurrence[i] &lt; minIndex)</span><br><span class="line">            &#123;</span><br><span class="line">                ch = (<span class="keyword">char</span>)i; <span class="comment">// 从ASCII码值转换回字符</span></span><br><span class="line">                minIndex = occurrence[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// occurrence[i]: A character with ASCII value i;</span></span><br><span class="line">    <span class="comment">// occurrence[i] = -1: The character has not found;</span></span><br><span class="line">    <span class="comment">// occurrence[i] = -2: The character has been found for mutlple times</span></span><br><span class="line">    <span class="comment">// occurrence[i] &gt;= 0: The character has been found only once</span></span><br><span class="line">    <span class="keyword">int</span> occurrence[<span class="number">256</span>]; <span class="comment">// 哈希表</span></span><br><span class="line">    <span class="keyword">int</span> index;           <span class="comment">// 索引，当前处于字符串的位置，或者说目前字符流的长度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="面试题56链表中环的入口结点">面试题56：链表中环的入口结点</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>一个链表中包含环，如何找出环的入口结点？例如，在图8.3的链表中，环的入口结点是结点3。</p>
</blockquote>
<p><img src="https://github.com/familyld/Coding_Interviews/blob/master/graph/56_EntryNodeInListLoop.jpg?raw=true" alt="ring"></p>
<h3 id="解析">解析</h3>
<p>这题可以分为三个步骤来完成：</p>
<ol>
<li>判断链表中有没有环</li>
<li>计算环的结点数</li>
<li>找到环的入口结点</li>
</ol>
<p>先分析第一步，判断链表中有没有环，可以用一快一慢两个指针来实现。为什么可以这样做不妨看看知乎上的一个问题：<a href="https://www.zhihu.com/question/23208893" target="_blank" rel="noopener">为什么用快慢指针找链表的环，快指针和慢指针一定会相遇？</a>，还是挺有意思的。如果链表中存在环，那么快指针必然会从后追上慢指针，发生相遇；如果链表中没有环，那么快指针就会走到尾结点。</p>
<p>接下来，如果存在环，我们就计算一下环中结点的数目。怎么办到呢？其实很简单，我们同样使用两个指针，一个指针固定不动在第一步快慢指针相遇的地方，另一个指针一边往前移动一边计数，那么当这两个指针再次相遇时，所得的计数就是环中结点的数目了。</p>
<p>最后，怎么找到环的入口结点呢？其实可能有人还没想明白第二步的作用，可以回忆一下<a href="https://github.com/familyld/Coding_Interviews/blob/master/C%2B%2B/15_KthNodeFromEnd/README.md" target="_blank" rel="noopener">面试题15：链表中的倒数第k个结点</a>。其实我们统计环中结点的数目就是为第三步服务的！要找到环的入口结点，实际上和这一题有异曲同工之妙。</p>
<p>假设我们把环的入口结点看作环的第一个结点（例子中的3），那么环的最后一个结点（例子中的6）就是环中连接到入口结点的那个结点，我们可以把它看作链表的最后一个结点。这时如果我们把环拿掉，其实这道题就变得跟面试题15一模一样了。</p>
<p>假设环中结点数为k，那么我们现在要找的就是整个链表的倒数第k个结点。同样使用两个指针，第一个指针先走k步，然后第二个指针再走，此时两个指针之间隔着k-1个结点。当第一个指针和第二个指针相遇时，它们指向的结点就是环的入口结点了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">MeetingNode</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ListNode* pSlow = pHead-&gt;m_pNext;</span><br><span class="line">    <span class="keyword">if</span>(pSlow == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ListNode* pFast = pSlow-&gt;m_pNext;</span><br><span class="line">    <span class="keyword">while</span>(pFast != <span class="literal">NULL</span> &amp;&amp; pSlow != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pFast == pSlow) <span class="comment">// 返回相遇的结点</span></span><br><span class="line">            <span class="keyword">return</span> pFast;</span><br><span class="line"></span><br><span class="line">        pSlow = pSlow-&gt;m_pNext; <span class="comment">// 慢指针走一步</span></span><br><span class="line"></span><br><span class="line">        pFast = pFast-&gt;m_pNext; <span class="comment">// 快指针走两步</span></span><br><span class="line">        <span class="keyword">if</span>(pFast != <span class="literal">NULL</span>)       <span class="comment">// 注意判断第二步是否能走</span></span><br><span class="line">            pFast = pFast-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不存在环，返回NULL</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* meetingNode = MeetingNode(pHead);</span><br><span class="line">    <span class="keyword">if</span>(meetingNode == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取环中结点的数目</span></span><br><span class="line">    <span class="keyword">int</span> nodesInLoop = <span class="number">1</span>;</span><br><span class="line">    ListNode* pNode1 = meetingNode;</span><br><span class="line">    <span class="keyword">while</span>(pNode1-&gt;m_pNext != meetingNode)</span><br><span class="line">    &#123;</span><br><span class="line">        pNode1 = pNode1-&gt;m_pNext;</span><br><span class="line">        ++nodesInLoop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让指针1先走nodesInLoop步</span></span><br><span class="line">    pNode1 = pHead;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodesInLoop; ++i)</span><br><span class="line">        pNode1 = pNode1-&gt;m_pNext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针1、2同时移动</span></span><br><span class="line">    ListNode* pNode2 = pHead;</span><br><span class="line">    <span class="keyword">while</span>(pNode1 != pNode2) <span class="comment">// 相遇时停止</span></span><br><span class="line">    &#123;</span><br><span class="line">        pNode1 = pNode1-&gt;m_pNext;</span><br><span class="line">        pNode2 = pNode2-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pNode1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题57删除链表中重复的结点">面试题57：删除链表中重复的结点</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>在一个排序的链表中，如何删除重复的结点？例如：</p>
</blockquote>
<p>删除前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; 2 -&gt; 3 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5</span><br></pre></td></tr></table></figure>
<p>删除后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; 2 -&gt; 5</span><br></pre></td></tr></table></figure>
<h3 id="解析">解析</h3>
<p>这题我们需要注意的就是删除重复结点前，需要记住前面的那一个非重复结点，保证删除完毕后，前一个个非重复结点依然能连接到下一个非重复结点，链表不会发生锻炼。</p>
<p>另一个需要注意的点就是，头结点是有可能被删除的，所以调用函数时要按引用传递头结点指针，否则无法进行修改和删除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteDuplication</span><span class="params">(ListNode** pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead == <span class="literal">NULL</span> || *pHead == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    ListNode* pPreNode = <span class="literal">NULL</span>; <span class="comment">// 前一结点初始为NULL，因为头结点没有前一结点</span></span><br><span class="line">    ListNode* pNode = *pHead;</span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>) <span class="comment">// 遍历链表直到到达尾部</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *pNext = pNode-&gt;m_pNext; <span class="comment">// 取得下一结点</span></span><br><span class="line">        <span class="keyword">bool</span> needDelete = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 如果下一结点和当前结点值相同，就说明需要删除</span></span><br><span class="line">        <span class="keyword">if</span>(pNext != <span class="literal">NULL</span> &amp;&amp; pNext-&gt;m_nValue == pNode-&gt;m_nValue)</span><br><span class="line">            needDelete = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不用删除的话就继续遍历下一结点</span></span><br><span class="line">        <span class="comment">// 把前一结点更新为当前结点</span></span><br><span class="line">        <span class="keyword">if</span>(!needDelete)</span><br><span class="line">        &#123;</span><br><span class="line">            pPreNode = pNode;</span><br><span class="line">            pNode = pNode-&gt;m_pNext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除结点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从当前结点开始删除值相同的结点</span></span><br><span class="line">            <span class="keyword">int</span> value = pNode-&gt;m_nValue;</span><br><span class="line">            ListNode* pToBeDel = pNode;</span><br><span class="line">            <span class="keyword">while</span>(pToBeDel != <span class="literal">NULL</span> &amp;&amp; pToBeDel-&gt;m_nValue == value)</span><br><span class="line">            &#123;</span><br><span class="line">                pNext = pToBeDel-&gt;m_pNext;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">delete</span> pToBeDel;</span><br><span class="line">                pToBeDel = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">                pToBeDel = pNext;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果发现是头结点被删除了，则把头结点改为（删除完重复结点后的）下一结点</span></span><br><span class="line">            <span class="keyword">if</span>(pPreNode == <span class="literal">NULL</span>)</span><br><span class="line">                *pHead = pNext;</span><br><span class="line">            <span class="comment">// 否则就把前一结点的next指针指向（删除完重复结点后的）下一结点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pPreNode-&gt;m_pNext = pNext;</span><br><span class="line"></span><br><span class="line">            pNode = pNext; <span class="comment">// 继续遍历下一结点，前一结点不需移动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题58二叉树的下一个结点">面试题58：二叉树的下一个结点</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？树中的结点除了有两个分别指向左右子结点的指针以外，还有一个指向父结点的指针。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                    m_nValue;</span><br><span class="line">    BinaryTreeNode*        m_pLeft;</span><br><span class="line">    BinaryTreeNode*        m_pRight;</span><br><span class="line">    BinaryTreeNode*        m_pParent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解析">解析</h3>
<p>所谓中序遍历，也即对于每个结点来说，首先访问左子树，然后再访问自身，最后访问右子树。在写代码时我们考虑一下三种情况：</p>
<ol>
<li>结点有右子树：下一结点为右子树的最左子结点</li>
<li>结点无右子树：
<ul>
<li>该结点是父结点的左子结点：下一结点为父结点</li>
<li>该结点是父结点的右子结点：需要一直往上搜索，直到找到一个结点是其父结点的左子结点，则其父结点就是下一结点。若不存在则说明遍历结束。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">GetNext</span><span class="params">(BinaryTreeNode* pNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pNode == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    BinaryTreeNode* pNext = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(pNode-&gt;m_pRight != <span class="literal">NULL</span>)</span><br><span class="line">    &#123; <span class="comment">// 有右子树则下一结点为右子树的最左子结点</span></span><br><span class="line">        BinaryTreeNode* pRight = pNode-&gt;m_pRight;</span><br><span class="line">        <span class="keyword">while</span>(pRight-&gt;m_pLeft != <span class="literal">NULL</span>)</span><br><span class="line">            pRight = pRight-&gt;m_pLeft;</span><br><span class="line"></span><br><span class="line">        pNext = pRight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;m_pParent != <span class="literal">NULL</span>)</span><br><span class="line">    &#123; <span class="comment">// 没有右子树但是有父结点就说明仍然可以找到下一结点</span></span><br><span class="line">        BinaryTreeNode* pCurrent = pNode;</span><br><span class="line">        BinaryTreeNode* pParent = pNode-&gt;m_pParent;</span><br><span class="line">        <span class="keyword">while</span>(pParent != <span class="literal">NULL</span> &amp;&amp; pCurrent == pParent-&gt;m_pRight)</span><br><span class="line">        &#123; <span class="comment">// 往上找直到找到一个结点属于父结点的左子树，则下一结点为父结点</span></span><br><span class="line">            pCurrent = pParent;</span><br><span class="line">            pParent = pParent-&gt;m_pParent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pNext = pParent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题59对称的二叉树">面试题59：对称的二叉树</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。例如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     8</span><br><span class="line">   /   \</span><br><span class="line">  6     6</span><br><span class="line"> / \   / \</span><br><span class="line">5   7 7   5</span><br></pre></td></tr></table></figure>
<blockquote>
<p>是一棵对称二叉树。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>前序遍历、中序遍历、后序遍历都是先访问左子结点再访问右子结点，而如果我们想要判断一棵树是否对称二叉树，我们可以创造一种遍历方式是先访问右子结点再访问左子结点的。如果使用两种对应遍历方式所得的遍历序列都相同，就说明这棵树是对称二叉树。</p>
<p>书中以前序遍历为例编写代码，但实际上中序遍历和后序遍历也是可以的~</p>
<p>特别注意，一种特殊情况如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">7</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">7</span>     <span class="number">7</span></span><br><span class="line"> / \   /</span><br><span class="line"><span class="number">7</span>   <span class="number">7</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>这种情况如果我们只是按上面的方式来比较是无法正确判断出的，怎么应对呢？我们只需要把NULL也考虑进来就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(BinaryTreeNode* pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isSymmetrical(pRoot, pRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 同为NULL，则仍然认为是一样的，并且因为到达底部而返回</span></span><br><span class="line">    <span class="keyword">if</span>(pRoot1 == <span class="literal">NULL</span> &amp;&amp; pRoot2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一方为NULL，而另一方不是，说明不对称，返回false</span></span><br><span class="line">    <span class="keyword">if</span>(pRoot1 == <span class="literal">NULL</span> || pRoot2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结点值不同，说明不对称，返回false</span></span><br><span class="line">    <span class="keyword">if</span>(pRoot1-&gt;m_nValue != pRoot2-&gt;m_nValue)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结点值相同，继续进行比较，树1先访问左结点再访问右结点，树2则相反</span></span><br><span class="line">    <span class="keyword">return</span> isSymmetrical(pRoot1-&gt;m_pLeft, pRoot2-&gt;m_pRight)</span><br><span class="line">        &amp;&amp; isSymmetrical(pRoot1-&gt;m_pRight, pRoot2-&gt;m_pLeft);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题60把二叉树打印成多行">面试题60：把二叉树打印成多行</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印到一行。例如，打印下面的二叉树：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     8</span><br><span class="line">   /   \</span><br><span class="line">  6     10</span><br><span class="line"> / \   /  \</span><br><span class="line">5   7 9    11</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果是：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">6   10</span><br><span class="line">5   7   9   11</span><br></pre></td></tr></table></figure>
<h3 id="解析">解析</h3>
<p>这题思路很简单，就是考查BFS的，逐层遍历一棵树只需要用队列模拟就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(BinaryTreeNode* pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;BinaryTreeNode*&gt; nodes;</span><br><span class="line">    nodes.push(pRoot);</span><br><span class="line">    <span class="keyword">int</span> nextLevel = <span class="number">0</span>;   <span class="comment">// 下一层需要打印的结点数</span></span><br><span class="line">    <span class="keyword">int</span> toBePrinted = <span class="number">1</span>; <span class="comment">// 当前层需要打印的结点数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty()) <span class="comment">// 整棵树打印完毕时停止</span></span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* pNode = nodes.front();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, pNode-&gt;m_nValue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;m_pLeft != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nodes.push(pNode-&gt;m_pLeft);</span><br><span class="line">            ++nextLevel;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;m_pRight != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nodes.push(pNode-&gt;m_pRight);</span><br><span class="line">            ++nextLevel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首结点出队，当前层需要打印的结点数减一</span></span><br><span class="line">        nodes.pop();</span><br><span class="line">        --toBePrinted;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若当前层打印完毕，则进行换行，开始打印下一层</span></span><br><span class="line">        <span class="keyword">if</span>(toBePrinted == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            toBePrinted = nextLevel;</span><br><span class="line">            nextLevel = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题61按之字形顺序打印二叉树">面试题61：按之字形顺序打印二叉树</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三层再按照从左到右的顺序打印，其他行以此类推。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>这题和上一题比难度就上升了，显然这不是一个简单的BFS，我们要使用什么容器和往容器中存放结点的顺序都需要认真去考虑。</p>
<p>这里使用两个栈再加上一点小trick来实现，注意栈的特性的先进后出，后进先出。</p>
<p>我们注意当奇数层是顺着打印，偶数层是倒着打印。所以！<strong>奇数层应该倒着入栈，偶数层则顺着入栈</strong>。</p>
<p>明白这一点之后就好办了，我们使用两个栈来存放，一个栈用来存放当前打印的那一层，另一个栈用来存放下一层的结点值。如果只使用一个栈是不行的，当层数更高时会发生顺序的错乱。使用两个栈时我们只需要判断一下当前栈是否为空就知道这一层是否打印完毕要转换到另一个栈了。</p>
<p>具体来说，举个例子，比如下面这棵树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">         1</span><br><span class="line">      /      \</span><br><span class="line">    2          3</span><br><span class="line">  /  \       /   \</span><br><span class="line"> 4    5     6     7</span><br><span class="line">/ \  / \   / \   / \</span><br><span class="line">8 9 10 11 12 13 14 15</span><br></pre></td></tr></table></figure>
<p>| 步骤 | 操作 | Stack1中的结点 | Stack2中的结点 |<br>
|: - :|: - :|: - :|: - :|<br>
| 1 | 打印结点1 | 2,3 |  |<br>
| 2 | 打印结点3 | 2 | 7,6 |<br>
| 3 | 打印结点2 |  | 7,6,5,4 |<br>
| 4 | 打印结点4 | 8,9 | 7,6,5 |<br>
| 5 | 打印结点5 | 8,9,10,11 | 7,6 |<br>
| 6 | 打印结点6 | 8,9,10,11,12,13 | 7 |<br>
| 7 | 打印结点6 | 8,9,10,11,12,13,14,15 |  |</p>
<p>对于奇数层的结点而言，下一层要逆着打，所以先存左子结点，再存右子结点，这样下一层就会先打印右子结点再打印左子结点；</p>
<p>对于偶数层的结点而言，下一层要顺着打，所以先存右子结点，再存左子结点，这样下一层就会先打印左子结点再打印右子结点；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(BinaryTreeNode* pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用两个栈，0号栈存的必然是奇数层结点，1号栈存的必然是偶数层结点</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;BinaryTreeNode*&gt; levels[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> current = <span class="number">0</span>; <span class="comment">// 指示存放当前层结点值的栈</span></span><br><span class="line">    <span class="keyword">int</span> next = <span class="number">1</span>;    <span class="comment">// 指示存放下一层结点值的栈</span></span><br><span class="line"></span><br><span class="line">    levels[current].push(pRoot);</span><br><span class="line">    <span class="comment">// 两个栈都为空时，说明整棵树已经打印完毕</span></span><br><span class="line">    <span class="keyword">while</span>(!levels[<span class="number">0</span>].empty() || !levels[<span class="number">1</span>].empty())</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* pNode = levels[current].top();</span><br><span class="line">        levels[current].pop();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, pNode-&gt;m_nValue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(current == <span class="number">0</span>)</span><br><span class="line">        &#123; <span class="comment">// 当前打印的是0号栈，则下一层为偶数层，先存左子结点，再存右子结点</span></span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;m_pLeft != <span class="literal">NULL</span>)</span><br><span class="line">                levels[next].push(pNode-&gt;m_pLeft);</span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;m_pRight != <span class="literal">NULL</span>)</span><br><span class="line">                levels[next].push(pNode-&gt;m_pRight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">// 当前打印的是1号栈，则下一层为奇数层，先存右子结点，再存左子结点</span></span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;m_pRight != <span class="literal">NULL</span>)</span><br><span class="line">                levels[next].push(pNode-&gt;m_pRight);</span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;m_pLeft != <span class="literal">NULL</span>)</span><br><span class="line">                levels[next].push(pNode-&gt;m_pLeft);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前层打印完毕，打印下一层</span></span><br><span class="line">        <span class="keyword">if</span>(levels[current].empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            current = <span class="number">1</span> - current;</span><br><span class="line">            next = <span class="number">1</span> - next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题62序列化二叉树">面试题62：序列化二叉树</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>首先要理解一下什么是序列化，什么是反序列化？</p>
<p>其实，我们谈论到的很多数据结构比方说树，甚至一些更复杂的自定定义的对象，是没法直接保存或传输的，只有程序运行时可以用。当我们需要保存到硬盘或者进行传输时就必须进行序列化，然后要放入程序时就要重新反序列化解析出来。可以如下定义：</p>
<ul>
<li>序列化： 将数据结构或对象转换成二进制串的过程。</li>
<li>反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。</li>
</ul>
<p>不过这题我们在程序中只需要把二叉树转换为字符串就可以了。</p>
<p>前面有一道题是通过前序遍历序列和中序遍历序列构造出一棵二叉树的，这里其实也可以用这样的思路，把二叉树序列化成前序遍历序列和中序遍历序列这两个序列来存储，然后反序列化时按这两个序列重新构造二叉树就可以了。但这种思路有两个很大的缺点就是：（1）不能有数值重复的结点；（2）要整个序列读出来才可以进行反序列化。</p>
<p>事实上不用这么复杂，我们只需要选择一种遍历方式就可以了，关键是用一个特殊的符号来表示NULL，这样在反序列化时我们就可以知道什么时候到达底部了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Serialize</span><span class="params">(BinaryTreeNode* pRoot, ostream&amp; stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>) <span class="comment">// 使用$标识NULL</span></span><br><span class="line">    &#123;</span><br><span class="line">        stream &lt;&lt; <span class="string">"$,"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    stream &lt;&lt; pRoot-&gt;m_nValue &lt;&lt; <span class="string">','</span>; <span class="comment">// 序列化当前结点，以逗号为分隔</span></span><br><span class="line">    Serialize(pRoot-&gt;m_pLeft, stream);</span><br><span class="line">    Serialize(pRoot-&gt;m_pRight, stream);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从输入流中每次读出一个结点的值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ReadStream</span><span class="params">(istream&amp; stream, <span class="keyword">int</span>* number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stream.eof())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">32</span>];</span><br><span class="line">    buffer[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    stream &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stream.eof() &amp;&amp; ch != <span class="string">','</span>)</span><br><span class="line">    &#123; <span class="comment">// 遇到EOF表示序列已读完，而遇到逗号则说明这个结点的值读完了</span></span><br><span class="line">        buffer[i++] = ch;</span><br><span class="line">        stream &gt;&gt; ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断读出的是否数字，并进行相应的转换</span></span><br><span class="line">    <span class="keyword">bool</span> isNumeric = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; buffer[<span class="number">0</span>] != <span class="string">'$'</span>)</span><br><span class="line">    &#123; <span class="comment">// i大于0说明上一步有读出过内容，读出内容不为$即结点是数值，进行转换</span></span><br><span class="line">        *number = atoi(buffer);</span><br><span class="line">        isNumeric = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isNumeric;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Deserialize</span><span class="params">(BinaryTreeNode** pRoot, istream&amp; stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">if</span>(ReadStream(stream, &amp;number))</span><br><span class="line">    &#123; <span class="comment">// 如果读出数字就构造结点，否则表示已到达底部，递归返回</span></span><br><span class="line">        *pRoot = <span class="keyword">new</span> BinaryTreeNode();</span><br><span class="line">        (*pRoot)-&gt;m_nValue = number;</span><br><span class="line">        (*pRoot)-&gt;m_pLeft = <span class="literal">NULL</span>;</span><br><span class="line">        (*pRoot)-&gt;m_pRight = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        Deserialize(&amp;((*pRoot)-&gt;m_pLeft), stream);</span><br><span class="line">        Deserialize(&amp;((*pRoot)-&gt;m_pRight), stream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题特别注意一下传参的方式，一些参数是需要使用指针传递/引用传递的（修改实参而非形参的值），否则会无法正确修改它在内存中的值，从而导致错误。不妨看看这篇文章：<a href="http://www.cnblogs.com/Romi/archive/2012/08/09/2630014.html" target="_blank" rel="noopener">C/C++中函数参数传递详解</a>。参数中带<code>&amp;</code>表示按引用传递。</p>
<h2 id="面试题63二叉树搜索树的第k个结点">面试题63：二叉树搜索树的第k个结点</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>给定一棵二叉搜索树，请找出其中的第k大的结点。例如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     5</span><br><span class="line">   /   \</span><br><span class="line">  3     7</span><br><span class="line"> / \   / \</span><br><span class="line">2   4 6   8</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这棵二叉搜索树里，按结点数值大小顺序第三个结点是4。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>这题思路很简单，对于一棵BST搜索第k大的结点，只需要用前序遍历来检索就可以了，前序遍历访问到的第k个结点就是题目所求。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">KthNode</span><span class="params">(BinaryTreeNode* pRoot, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span> || k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> KthNodeCore(pRoot, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BinaryTreeNode* <span class="title">KthNodeCore</span><span class="params">(BinaryTreeNode* pRoot, <span class="keyword">unsigned</span> <span class="keyword">int</span>&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinaryTreeNode* target = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pRoot-&gt;m_pLeft != <span class="literal">NULL</span>) <span class="comment">// 先访问左子结点</span></span><br><span class="line">        target = KthNodeCore(pRoot-&gt;m_pLeft, k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(target == <span class="literal">NULL</span>) <span class="comment">// 然后访问当前结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="comment">// 若此时k已为1，则当前结点为所求</span></span><br><span class="line">            target = pRoot;</span><br><span class="line"></span><br><span class="line">        k--;       <span class="comment">// 每次访问完后k值减一</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(target == <span class="literal">NULL</span> &amp;&amp; pRoot-&gt;m_pRight != <span class="literal">NULL</span>) <span class="comment">// 若当前结点不是，继续访问右子结点</span></span><br><span class="line">        target = KthNodeCore(pRoot-&gt;m_pRight, k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题64数据流中的中位数">面试题64：数据流中的中位数</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>这条题目其实和第5章的 面试题30：最小的k个数 有一点联系，面试题30通过维持一个大小为k的最大堆来实现从数据流中确定最小k个数的功能。而这一题要求得到数据流的中位数，这要更难一些。一是我们没有办法确定堆的大小；二是有可能从数据流中读出了偶数个数值，此时需要所有数值排序之后中间两个数的平均值。</p>
<p>无法确定堆的大小，其实更准确一点来说，假设我们要找出从数据流中读取k个数时的中位数，我们必须把前面的k-1个数都保存下来因为我们并不知道k的取值，任意一个数字都可能会是取某个k值时的中位数，不能丢掉。</p>
<p>而为了更有效地插入新数字（O(log n)复杂度）和查询中位数（O(1)复杂度），我们可以同时维护两个堆，一个最大堆，一个最小堆，以中位数划分，最大堆保存排序后数组的前半部分，最小堆则保存后半部分。我们要注意保持数据平均地分到这两个堆中，也即堆的大小相差不超过1。当从数据流中读取了奇数个数值时，取最小堆的顶部为中位数；当从数据流中读取了偶数个数值时，取最大堆顶部和最小堆顶部两个数值的平均值为中位数。</p>
<p>为了保证正确取得中位数我们要保证最大堆里的数都比最小堆里的小，这就对插入操作有所要求。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">DynamicArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(T num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(((min.size() + max.size()) &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123; <span class="comment">// 此时从数据流中读取了奇数个数值</span></span><br><span class="line">            <span class="keyword">if</span>(max.size() &gt; <span class="number">0</span> &amp;&amp; num &lt; max[<span class="number">0</span>])</span><br><span class="line">            &#123; <span class="comment">// 保证要加入最小堆的数字比最大堆的所有数字都更大</span></span><br><span class="line">                max.push_back(num);</span><br><span class="line">                push_heap(max.begin(), max.end(), less&lt;T&gt;());</span><br><span class="line"></span><br><span class="line">                num = max[<span class="number">0</span>]; <span class="comment">// 如果新数字没有堆顶大，就会交换两者的值</span></span><br><span class="line"></span><br><span class="line">                pop_heap(max.begin(), max.end(), less&lt;T&gt;());</span><br><span class="line">                max.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把新数字加入最小堆</span></span><br><span class="line">            min.push_back(num);</span><br><span class="line">            push_heap(min.begin(), min.end(), greater&lt;T&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">// 此时从数据流中读取了偶数个数值</span></span><br><span class="line">            <span class="keyword">if</span>(min.size() &gt; <span class="number">0</span> &amp;&amp; min[<span class="number">0</span>] &lt; num)</span><br><span class="line">            &#123;</span><br><span class="line">                min.push_back(num);</span><br><span class="line">                push_heap(min.begin(), min.end(), greater&lt;T&gt;());</span><br><span class="line"></span><br><span class="line">                num = min[<span class="number">0</span>]; <span class="comment">// 如果新数字没有堆顶小，就会交换两者的值</span></span><br><span class="line"></span><br><span class="line">                pop_heap(min.begin(), min.end(), greater&lt;T&gt;());</span><br><span class="line">                min.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把新数字加入最大堆</span></span><br><span class="line">            max.push_back(num);</span><br><span class="line">            push_heap(max.begin(), max.end(), less&lt;T&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">GetMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = min.size() + max.size();</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> exception(); <span class="comment">//"No numbers are available"</span></span><br><span class="line"></span><br><span class="line">        T median = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>((size &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            median = min[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            median = (min[<span class="number">0</span>] + max[<span class="number">0</span>]) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> median;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; min;</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意这里实现堆结构的方式和第30题不同，这里使用STL的 <code>push_heap</code>，<code>pop_heap</code> 函数以及vector来实现堆，并且以比较仿函数less和greater来实现最大堆和最小堆。</p>
<h2 id="面试题65滑动窗口的最大值">面试题65：滑动窗口的最大值</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。例如，如果输入数组 <code>{2,3,4,2,6,2,5,1}</code> 及滑动窗口的大小3，那么一共存在6个滑动窗口，它们的最大值分别为 <code>{4,4,6,6,6,5}</code>。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>这题其实也挺有意思的，稍微修改一下题目就可以用来考查数据流、大数据处理这样的问题了。这题的关键其实是要我们明白哪些数字有可能成为滑动窗口里的最大值（应当保存），哪些数字则不会（应当舍弃）。简单来说，有以下几个问题需要考虑：</p>
<ol>
<li>使用什么数据结构进行存储？（方便删除，插入和比较）</li>
<li>一个在当前滑动窗口非最大值的数字是否仍有可能成为另一个滑动窗口的最大值？</li>
<li>新加入滑动窗口的数字可能对已存储的数字带来什么影响？</li>
<li>怎样确定数字超出了滑动窗口的范围？</li>
</ol>
<p>针对问题1，我们可以使用一个两端开口的队列（deque）来存储那些滑动窗口内可能的最大值，前后都可以pop，并且可以使用 <code>front()</code> 函数和 <code>back()</code> 函数容易地取得队首和队尾，非常方便。注意，这个队列存储的是<strong>可能的最大值</strong>，也可以理解为它是一个中转站。我们还需要用另一个数据结构来存储<strong>真正的每个滑动窗口的最大值</strong>，这个数据结构要求就没有那么高，用vector就可以了。</p>
<p>针对问题2，当前滑动窗口非最大值的数字是有可能成为另一个滑动窗口的最大值的。举个例子，序列 <code>{6,5,4}</code>，窗口大小为2，那么第一个滑动窗口 <code>{6,5}</code> 里面最大值是6，但5也应当被存储下来，因为在下一个滑动窗口 <code>{5,4}</code> 中5就是最大值。</p>
<p>针对问题3，可以分两种情况讨论，一是窗口内存在比新数字小的数；二是窗口内存在的数都比新数字大。在情况一中，那些比新数字小的数我们可以都pop掉，因为它们比新数字小所以肯定不可能是当前窗口的最大值了，而往后滑动时，它们存在于窗口时新数字也一定在，所以依然不可能成为窗口内的最大值，因此可以把它们都扔掉；但在情况二中，尽管新数字比当前窗口内的数字都小，在窗口往后滑动时，新数字依然有可能成为窗口内的最大值，比方说上一段举出的例子，因此这种情况下依然要把新数字入队。考虑好这两种情况就能<strong>保证队列的队首永远是当前窗口的最大值</strong>。</p>
<p>针对问题4，我们在队列中存储时可以不要存数值，而是存储它在数组中的索引。这样当往后移动窗口，加入新数字时，我们只需要把队列中索引值小于 新数字索引-窗口大小 的索引值出队就可以了。</p>
<p>想清楚以上四个问题后，不难写出以下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows;</span><br><span class="line">    <span class="keyword">if</span>(num.size() &gt;= size &amp;&amp; size &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; index;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 索引队列的初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!index.empty() &amp;&amp; num[i] &gt;= num[index.back()])</span><br><span class="line">                index.pop_back();</span><br><span class="line"></span><br><span class="line">            index.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 往后移动滑动窗口，直到到达数组尾部，i为新加入数字（窗口尾部）的索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = size; i &lt; num.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 索引队列的队首是当前窗口的最大值，存入maxInWindows数组中</span></span><br><span class="line">            maxInWindows.push_back(num[index.front()]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把索引队列里比窗口尾部数字小的都pop掉，它们不可能成为最大值了</span></span><br><span class="line">            <span class="keyword">while</span>(!index.empty() &amp;&amp; num[i] &gt;= num[index.back()])</span><br><span class="line">                index.pop_back();</span><br><span class="line">            <span class="comment">// 把滑出了滑动窗口的也pop掉</span></span><br><span class="line">            <span class="keyword">if</span>(!index.empty() &amp;&amp; index.front() &lt;= (<span class="keyword">int</span>)(i - size))</span><br><span class="line">                index.pop_front();</span><br><span class="line"></span><br><span class="line">            index.push_back(i); <span class="comment">// 把新数字（当前窗口尾部）的索引加入索引队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        maxInWindows.push_back(num[index.front()]); <span class="comment">// 最后一个滑动窗口的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxInWindows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题66矩阵中的路径">面试题66：矩阵中的路径</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如下面的矩阵：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a    b    c    e</span><br><span class="line">s    f    c    s</span><br><span class="line">a    d    e    e</span><br></pre></td></tr></table></figure>
<blockquote>
<p>包含了一条字符串 <code>&quot;bcced&quot;</code> 的路径。但矩阵中不包含字符串 <code>&quot;abcb&quot;</code> 的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>这题其实思路相当简单，我们可以直接枚举以矩阵的每一个格子作为路径开头进行深搜的情况，直到能完整匹配字符串就停止。特别注意要使用和输入矩阵同规模的visited矩阵来标记走过的路径，避免重复走过一个格子两次的情况。</p>
<p>使用一个二重循环来实现枚举就可以了，注意每一次深搜时除了要注意是否匹配，还要注意边界的判断。当发现路径不合适要递归返回时，必须把路径长度减一并且设置好visited矩阵对应的值，这样才算把当前格子移出了路径。另外，搜索的时候，我们是往上下左右四个方向搜索，只要其中一个方向能成功匹配就算找到了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="literal">NULL</span> || rows &lt; <span class="number">1</span> || cols &lt; <span class="number">1</span> || str == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows * cols];</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, rows * cols);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pathLength = <span class="number">0</span>; <span class="comment">// 初始路径长度为0</span></span><br><span class="line">    <span class="comment">// 使用一个二重循环来枚举以矩阵的每一个格子作为路径开头进行深搜的情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; ++row)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; ++col)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hasPathCore(matrix, rows, cols, row, col, str,</span><br><span class="line">                pathLength, visited))</span><br><span class="line">            &#123; <span class="comment">// 只要有一次找到了就算成功，直接返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span>* str, <span class="keyword">int</span>&amp; pathLength, <span class="keyword">bool</span>* visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str[pathLength] == <span class="string">'\0'</span>) <span class="comment">// 字符串匹配完成，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> hasPath = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols</span><br><span class="line">            &amp;&amp; matrix[row * cols + col] == str[pathLength]</span><br><span class="line">            &amp;&amp; !visited[row * cols + col])</span><br><span class="line">    &#123; <span class="comment">// 前四个判断条件用于防止溢出边界，后两个判断条件则是当前格子</span></span><br><span class="line">      <span class="comment">// 与当前字符是否匹配，当前格子是否未使用</span></span><br><span class="line">        ++pathLength;</span><br><span class="line">        visited[row * cols + col] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只要有一个方向匹配完整就算成功</span></span><br><span class="line">        hasPath = hasPathCore(matrix, rows, cols, row, col - <span class="number">1</span>,</span><br><span class="line">                    str, pathLength, visited)</span><br><span class="line">                || hasPathCore(matrix, rows, cols, row - <span class="number">1</span>, col,</span><br><span class="line">                    str, pathLength, visited)</span><br><span class="line">                || hasPathCore(matrix, rows, cols, row, col + <span class="number">1</span>,</span><br><span class="line">                    str, pathLength, visited)</span><br><span class="line">                || hasPathCore(matrix, rows, cols, row + <span class="number">1</span>, col,</span><br><span class="line">                    str, pathLength, visited);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!hasPath)</span><br><span class="line">        &#123; <span class="comment">// 匹配失败时要把格子移出路径，以便进行下一次搜索</span></span><br><span class="line">            --pathLength;</span><br><span class="line">            visited[row * cols + col] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hasPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题67机器人的运动范围">面试题67：机器人的运动范围</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>地上有一个m行n列的方格。一个机器人从坐标(0,0)的格子开始移动，它每一次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格(35,37)，因为 <code>3+5+3+7=18</code>。但它不能进入方格(35,38)，因为 <code>3+5+3+8=19</code>。请问该机器人能够到达多少个格子？</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>这题比上一题稍微简单一些，不需要枚举矩阵的所有格子，只需要从(0,0)开始，进行一次深搜就可以了。要注意好不能重复计算同一个格子，所以同样使用一个和输入矩阵同规模的visited矩阵来标记。过程主要用递归来实现就可以了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算一个数字的各数位之和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDigitSum</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(number &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += number % <span class="number">10</span>;</span><br><span class="line">        number /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断机器人能否进入坐标为(row,col)的方格</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">bool</span>* visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row &gt;=<span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols      <span class="comment">// 满足四个边界条件</span></span><br><span class="line">        &amp;&amp; getDigitSum(row) + getDigitSum(col) &lt;= threshold <span class="comment">// 行列坐标数位之和小于阈值</span></span><br><span class="line">        &amp;&amp; !visited[row* cols + col])                       <span class="comment">// 并且未计算过</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">movingCountCore</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">bool</span>* visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(check(threshold, rows, cols, row, col, visited))</span><br><span class="line">    &#123; <span class="comment">// 当前格子满足条件，标记并继续往四个方向进行移动</span></span><br><span class="line">        visited[row * cols + col] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        count = <span class="number">1</span> + movingCountCore(threshold, rows, cols,</span><br><span class="line">                    row - <span class="number">1</span>, col, visited)</span><br><span class="line">                + movingCountCore(threshold, rows, cols,</span><br><span class="line">                    row, col - <span class="number">1</span>, visited)</span><br><span class="line">                + movingCountCore(threshold, rows, cols,</span><br><span class="line">                    row + <span class="number">1</span>, col, visited)</span><br><span class="line">                + movingCountCore(threshold, rows, cols,</span><br><span class="line">                    row, col + <span class="number">1</span>, visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows * cols];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows * cols; ++i)</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = movingCountCore(threshold, rows, cols,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/06/工作求职/剑指offer/5_优化时间和空间效率/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/06/工作求职/剑指offer/5_优化时间和空间效率/" itemprop="url">剑指offer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-06T11:11:41+08:00">
                2020-07-06
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-07-06T11:35:01+08:00" content="2020-07-06">
                2020-07-06
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="优化时间和空间效率">优化时间和空间效率</h1>
<h2 id="面试题29数组中出现次数超过一半的数字">面试题29：数组中出现次数超过一半的数字</h2>
<blockquote>
<p>题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组 <code>{1，2，3，2，2，2，5，4，2}</code>。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>其实对于一个排序数组来说，要找出这个数字是很简单的，只用遍历一次数组来计数就可以了。但是要排序的话时间复杂度至少也是O(n*logn)，有没有O(n)的方法呢？</p>
<p>有的，首先介绍一种基于partition函数的方法。partition函数用于在快排中把一个数字放到合适的位置上，使得这个数字的左边都比它小，右边都比它大。题目要求找出出现次数超过一半的数字，那么这个数字在排序数组中有什么特点呢？答案是<strong>出现次数超过数组长度的一半的数字必然会是中位数</strong>。</p>
<p>于是，我们就可以通过多次调用partition函数来找这个数。partition函数随机选取范围内的一个数放到合适的位置，如果位置比中位数前，那就缩小范围到这个数和数组末尾之间；如果比中位数后，那就缩小范围到数组开头到这个数之间；如果这个位置恰是中位数的位置，那就成功找到了。</p>
<p>注意，上面只是一种<strong>快速找到中位数</strong>的方法，出现次数有没有超过数组长度的一半，还得遍历一次数组对这个数的出现次数进行计数。</p>
<p>基于partition函数的方法算法复杂度分析有一定困难，但总的来说还是可以认为是O(n)的算法。有一个缺点是<strong>需要改变数组</strong>，这在实际任务中不一定被允许。</p>
<p>下面再介绍另一种更直观的O(n)解法。</p>
<p>所谓“出现的次数超过数组长度的一半”，其实可以理解为<strong>这个数字出现的次数比其他全部数字出现次数的总和还要多</strong>。基于这个思路，我们可以想出下面的解法：</p>
<ol>
<li>初始化变量result为数组的第一个元素，初始化变量times为1</li>
<li>遍历数组
<ul>
<li>如果times为0，把result换为当前数字</li>
<li>如果result不等于当前数字，则times-1</li>
<li>如果result等于当前数字，则times+1</li>
</ul>
</li>
<li>检查result出现次数是否超过数组长度的一半</li>
</ol>
<p>如果数组中真的存在一个数出现的次数超过数组长度的一半，那么它必定会是最后的result。但是，注意了，是不是最后的result一定就是题目要求的数字呢？并不是的！有可能数组根本就没有这样的数字，所以类似上一种解法，我们最后要进行一次遍历检查。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> g_bInputInvalid = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckInvalidArray</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_bInputInvalid = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">NULL</span> &amp;&amp; length &lt;= <span class="number">0</span>)</span><br><span class="line">        g_bInputInvalid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> g_bInputInvalid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckMoreThanHalf</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> length, <span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] == number)</span><br><span class="line">            times++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isMoreThanHalf = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(times * <span class="number">2</span> &lt;= length)</span><br><span class="line">    &#123;</span><br><span class="line">        g_bInputInvalid = <span class="literal">true</span>;</span><br><span class="line">        isMoreThanHalf = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isMoreThanHalf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题30最小的k个数">面试题30：最小的k个数</h2>
<blockquote>
<p>题目：输入n个整数，找出其中最小的k个数。例如输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>和上一题那样，我们可以使用O(n)的基于partition函数的解法，因为题目只要求找出最小的k个数，没有说这k个数还得排序好返回。所以只要partition函数返回的下标是k-1就结束了，如果不是就根据情况缩小范围即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法1====================</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetLeastNumbers_Solution1</span><span class="params">(<span class="keyword">int</span>* input, <span class="keyword">int</span> n, <span class="keyword">int</span>* output, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(input == <span class="literal">NULL</span> || output == <span class="literal">NULL</span> || k &gt; n || n &lt;= <span class="number">0</span> || k &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = Partition(input, n, start, end);</span><br><span class="line">    <span class="keyword">while</span>(index != k - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; k - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            end = index - <span class="number">1</span>;</span><br><span class="line">            index = Partition(input, n, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            start = index + <span class="number">1</span>;</span><br><span class="line">            index = Partition(input, n, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">        output[i] = input[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于partition函数求解一个不好的地方就是会改变数组。有没有一种不改变数组但又时间复杂度相对小的解法呢？有的，就是<strong>基于最大堆</strong>的算法，复杂度为O(n logk)，k设定为堆的大小。</p>
<p>具体来说，我们依次读入数组的n个整数。如果最大堆中已有的数字少于k个，则直接把这次读入的整数放入容器中；如果最大堆中已经满了，则把堆顶（最大元素）和这次读入的整数作比较，如果堆顶较小则不需修改，堆顶较大则删除堆顶，并且插入这次读入的整数。</p>
<p>这里不讨论怎样实现最大堆，直接使用C++中的multiset来实现（multiset与set都是<strong>基于红黑树实现</strong>的，区别在于<strong>multiset允许有重复元素</strong>），可以把它看成一个序列，插入/删除都能在O(logk)的时间内完成，而且<strong>能时刻保证序列中的数是有序的</strong>。</p>
<p>基于最大堆的解法比基于partition的解法要慢一些，但是！这种解法不仅不需要改变原数组（所有操作都在堆里进行），而且<strong>适合处理海量数据</strong>。因为数据太多时无法一次载入内存，只能从辅助存储空间（比如硬盘）分批读入，而基于最大堆的解法就允许我们每次读入一个数字，直到遍历完毕也就处理完了（当然，k还是不能超出内存的限制的）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法2====================</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt; &gt;            intSet;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt; &gt;::iterator  setIterator;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetLeastNumbers_Solution2</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, intSet&amp; leastNumbers, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    leastNumbers.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k &lt; <span class="number">1</span> || data.size() &lt; k)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator iter = data.begin();</span><br><span class="line">    <span class="keyword">for</span>(; iter != data.end(); ++ iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((leastNumbers.size()) &lt; k)</span><br><span class="line">            leastNumbers.insert(*iter);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            setIterator iterGreatest = leastNumbers.begin();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(*iter &lt; *(leastNumbers.begin()))</span><br><span class="line">            &#123;</span><br><span class="line">                leastNumbers.erase(iterGreatest);</span><br><span class="line">                leastNumbers.insert(*iter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题31连续子数组的最大和">面试题31：连续子数组的最大和</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>输入一个整型数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>这题初看之下，似乎有些难度。但实际上思路是很简单的，使用两个变量存储当前子数组的和（初始化为0）以及最大的和（初始化为0x80000000，即int类型的最小负数），求解的过程可以分为以下几种情况：</p>
<ol>
<li>
<p>当前和为负，此时如果把新的数字并入连续子数组，所得的和还没有这个数字本身大。所以后续再并入其它数字组成数组的和要比单独这个数字并入后续数字组成数组的和小。于是把当前连续子数组舍弃掉，然后往空数组并入新的数字即可（也即把当前子数组的和设为新数字的值）；</p>
</li>
<li>
<p>当前和非负，这时直接累加新数字就可以了，即使新数字是负数，后续加入其它数字连成的数组也有可能产生更大的和；</p>
</li>
<li>
<p>如果新产生的和比最大和要大，那就更新最大和。</p>
</li>
</ol>
<p>最后，应该注意，<strong>输入不合法时应返回什么</strong>。这里设定返回0，并且为了和最大和为0的情况区分开，采用了一个全局标志来进行标识。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> g_InvalidInput = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span> *pData, <span class="keyword">int</span> nLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((pData == <span class="literal">NULL</span>) || (nLength &lt;= <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        g_InvalidInput = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_InvalidInput = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nCurSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nGreatestSum = <span class="number">0x80000000</span>; <span class="comment">// 初始化为最小负数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nCurSum &lt;= <span class="number">0</span>)</span><br><span class="line">            nCurSum = pData[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nCurSum += pData[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nCurSum &gt; nGreatestSum)</span><br><span class="line">            nGreatestSum = nCurSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nGreatestSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题32从1到n整数中1出现的次数">面试题32：从1到n整数中1出现的次数</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。例如输入12，从1到12这些整数中包含1的数字有1，10，11和12，1一共出现了5次。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>不考虑时间复杂度，最简单的方法就是逐个数字判断，每次判断完各位是否1之后把数字除以10，当数字变为0时结束。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法一====================</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        number += NumberOf1(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n) <span class="comment">// 当n不为0时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">10</span> == <span class="number">1</span>)</span><br><span class="line">            number ++;</span><br><span class="line"></span><br><span class="line">        n = n / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里介绍一种考虑数字规律的O(log n)方法，也即复杂度视输入数字n的位数（等于log10(n)+1下取整）而定。</p>
<p>将求从1到n这n个整数的十进制表示中1出现的次数这个任务分为三个子任务来完成：</p>
<ol>
<li>统计 n去掉最高位+1 ~ n 这段范围内最高位出现的1</li>
<li>统计 n去掉最高位+1 ~ n 这段范围内除最高位之外出现的1</li>
<li>统计 1 ~ n去掉最高位 这段范围内出现的1</li>
</ol>
<p>那么具体来说怎么完成呢？</p>
<p>首先，对于 n去掉最高位+1 ~ n 这段范围内最高位出现的1，有两种情况：</p>
<ol>
<li>最高位大于1，此时所有最高位为1的情况都包含了，最高位为1的次数等于 <code>10^(位数-1)</code>
<ul>
<li>比如22，十位为1的10~19全部都被包含了，十位为1的次数是 <code>10^(2-1)=10（次）</code></li>
</ul>
</li>
<li>最高位等于1，此时最高位为1的次数等于 <code>n去掉最高位+1</code>
<ul>
<li>比如12，去掉十位是2，十位为1的次数是 <code>2+1=3（次）</code></li>
</ul>
</li>
</ol>
<p>然后，对于 n去掉最高位+1 ~ n 这段范围内除最高位之外出现的1，我们使用公式 <code>最高位*（位数-1）*10^(位数-2)</code> 次方。</p>
<p>首先，假设最高位数字为k，则 n去掉最高位+1 ~ n 这段范围可以被等分为k份。例如n=3721，则k=3，此时 722~3721 可以等分为3份，也即 722~1721，1722~2721 以及 2722~3721。又因为对于这3段范围来说，除最高位外出现1的次数都是相同的（最高位已经在第一个子任务中算好了，这里不用管），所以我们只需要算出其中一段就可以了，这是公式第一项的意义。</p>
<p>然后，假设n是一个d位数，则在去掉最高位后剩下的就是d-1位数字，我们在d-1位数字中选择一位固定为1，有d-1种选择，这是公式第二项的意义。</p>
<p>最后，在固定了其中一位数字为1之后，剩余的d-2位数字按照排列组合，每位数字都可以选择0~9中的一个，所以一共有 <code>10^(d-2)</code> 中组合，这是公式第三项的意义。</p>
<p>看到这里可能还有小小的迷糊，按照上面排列组合的方法计算，那么3111这个数在子任务2中不就被计算了3次吗？事实上，这并没有错，因为题目求得是1出现的次数，而不是出现1的数字有多少个？所以，除最高位外3111出现了3个1，在子任务2中计数为3是正确的。</p>
<p>最后的最后，我们还要求子任务3，统计 1 ~ n去掉最高位 这段范围内出现的1，这个使用递归求解就可以了，也即把n去掉最高位作为下一次递归传入的n。注意设置好终止条件，最好到达个位数时就停止了。若个位为0，则返回0；若各位大于0，则返回1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法二====================</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* strN)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PowerBase10</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> strN[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(strN, <span class="string">"%d"</span>, n); <span class="comment">//int转字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NumberOf1(strN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* strN)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!strN || *strN &lt; <span class="string">'0'</span> || *strN &gt; <span class="string">'9'</span> || *strN == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> first = *strN - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> length = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(<span class="built_in">strlen</span>(strN));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">1</span> &amp;&amp; first == <span class="number">0</span>) <span class="comment">// 个位为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">1</span> &amp;&amp; first &gt; <span class="number">0</span>) <span class="comment">// 个位为1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设strN是"21345"</span></span><br><span class="line">    <span class="comment">// numFirstDigit是数字10000-19999的第一个位中1的数目</span></span><br><span class="line">    <span class="keyword">int</span> numFirstDigit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(first &gt; <span class="number">1</span>)</span><br><span class="line">        numFirstDigit = PowerBase10(length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(first == <span class="number">1</span>)</span><br><span class="line">        numFirstDigit = atoi(strN + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// numOtherDigits是01346-21345除了第一位之外的数位中1的数目</span></span><br><span class="line">    <span class="keyword">int</span> numOtherDigits = first * (length - <span class="number">1</span>) * PowerBase10(length - <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// numRecursive是1-1345中1的数目</span></span><br><span class="line">    <span class="keyword">int</span> numRecursive = NumberOf1(strN + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numFirstDigit + numOtherDigits + numRecursive;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PowerBase10</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        result *= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题33把数组排成最小的数">面试题33：把数组排成最小的数</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接处的所有数字中最小的一个。例如输入数组 <code>{3,32,321}</code>，则打印出这3个数字能排成的最小数字321323.</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>这题如果我们采用全排列的方式，n个数字就有n!个排列，时间复杂度相当大。</p>
<p>那么这条题目实际我们做什么呢？其实是希望我们<strong>实现一个比较函数</strong>。</p>
<p>在这里我们并不是简单地比较两个数字的大小，而是要比较它们拼接的时候谁排在前面能产生更小的数。要实现这样的功能，我们可以先将两个数字转换为字符串，然后使用strcat来进行拼接，使用strcmp来进行比较。</p>
<p>实现了比较函数之后，我们可以使用qsort快速排序在O(n logn)的时间内完成排序，此时按顺序输出数组的数字得到的就是最小的数。</p>
<p>在这里简单再减少以下几个函数：</p>
<ol>
<li><code>sprintf(a, &quot;%d&quot;, b)</code> 将int<em>类型的b转换为char</em>类型的a，也即整数数组转字符串；</li>
<li><code>strcpy(a,b)</code> 将b复制到a；</li>
<li><code>strcat(a,b)</code> 将b拼接到a后面；</li>
<li><code>strcmp(a,b)</code> 对a和b两个字符串从左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇’\0’为止。若a&gt;b则返回正数，a&lt;b则返回负数，相同则返回0。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int型整数用十进制表示最多只有10位</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_MaxNumberLength = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* g_StrCombine1 = <span class="keyword">new</span> <span class="keyword">char</span>[g_MaxNumberLength * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span>* g_StrCombine2 = <span class="keyword">new</span> <span class="keyword">char</span>[g_MaxNumberLength * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>** strNumbers = (<span class="keyword">char</span>**)(<span class="keyword">new</span> <span class="keyword">int</span>[length]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        strNumbers[i] = <span class="keyword">new</span> <span class="keyword">char</span>[g_MaxNumberLength + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(strNumbers[i], <span class="string">"%d"</span>, numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qsort(strNumbers, length, <span class="keyword">sizeof</span>(<span class="keyword">char</span>*), compare);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, strNumbers[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">        <span class="keyword">delete</span>[] strNumbers[i];</span><br><span class="line">    <span class="keyword">delete</span>[] strNumbers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果[strNumber1][strNumber2] &gt; [strNumber2][strNumber1], 返回值大于0</span></span><br><span class="line"><span class="comment">// 如果[strNumber1][strNumber2] = [strNumber2][strNumber1], 返回值等于0</span></span><br><span class="line"><span class="comment">// 如果[strNumber1][strNumber2] &lt; [strNumber2][strNumber1], 返回值小于0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* strNumber1, <span class="keyword">const</span> <span class="keyword">void</span>* strNumber2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// [strNumber1][strNumber2]</span></span><br><span class="line">    <span class="built_in">strcpy</span>(g_StrCombine1, *(<span class="keyword">const</span> <span class="keyword">char</span>**)strNumber1);</span><br><span class="line">    <span class="built_in">strcat</span>(g_StrCombine1, *(<span class="keyword">const</span> <span class="keyword">char</span>**)strNumber2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [strNumber2][strNumber1]</span></span><br><span class="line">    <span class="built_in">strcpy</span>(g_StrCombine2, *(<span class="keyword">const</span> <span class="keyword">char</span>**)strNumber2);</span><br><span class="line">    <span class="built_in">strcat</span>(g_StrCombine2, *(<span class="keyword">const</span> <span class="keyword">char</span>**)strNumber1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(g_StrCombine1, g_StrCombine2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题34丑数">面试题34：丑数</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>我们把只包含因子2、3和5的数称作丑数（Ugly Number）。求按小到大的顺序的第1500个丑数。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当做第一个丑数。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>最简单的解法，写一个函数用于判断是否丑数（需要求模和做除法），然后从1开始依次判断是否丑数，直到得到1500个丑数时停止。这种方法的时间开销很大，因为即使一个数不是丑数，我们仍然要对它进行判断，做求模和除法这些开销较大的操作。</p>
<p>在允许使用额外空间时，我们不妨<strong>用空间换时间</strong>。按照丑数的定义，<strong>丑数应该是另一个丑数乘以2、3或者5的结果（1除外）</strong>。所以我们可以创建一个数组，里面的数字是排好序的丑数，每个丑数都是前面的丑数乘以2、3或者5得到的。</p>
<p>现在关键在于<strong>怎么确保数组里的丑数是排好序的</strong>？</p>
<p>假设我们有一个排好序的丑数数组，最大的一个丑数为M，则我们在生成下一个丑数时，我们会把已有丑数都乘2，乘3和乘5，这会产生一些小于等于M的数字，但由于我们是按序生成的，所以我们并不care这些数字。要继续有序生成，我们需要找到第一个比M大的数字。对于乘2操作来说，把第一个比M大的数字的数字记为M2；对于乘3操作来说，把第一个比M大的数字的数字记为M3；对于乘5操作来说，把第一个比M大的数字的数字记为M5。那么数组的下一个丑数必然是M2，M3，M5这三个数中的最小者。</p>
<p>在实现的时候，我们可以用三个指针来分别记录M2/2，M3/3和M5/5的坐标，在下一次产生丑数时，我们就不需要再从1开始逐个数乘2，乘3和乘5了，因为下一个丑数必然是这三个指针以后的数乘2，乘3或乘5产生的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution2</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *pUglyNumbers = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">    pUglyNumbers[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nextUglyIndex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *pMultiply2 = pUglyNumbers;</span><br><span class="line">    <span class="keyword">int</span> *pMultiply3 = pUglyNumbers;</span><br><span class="line">    <span class="keyword">int</span> *pMultiply5 = pUglyNumbers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(nextUglyIndex &lt; index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min = Min(*pMultiply2 * <span class="number">2</span>, *pMultiply3 * <span class="number">3</span>, *pMultiply5 * <span class="number">5</span>);</span><br><span class="line">        pUglyNumbers[nextUglyIndex] = min;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(*pMultiply2 * <span class="number">2</span> &lt;= pUglyNumbers[nextUglyIndex])</span><br><span class="line">            ++pMultiply2;</span><br><span class="line">        <span class="keyword">while</span>(*pMultiply3 * <span class="number">3</span> &lt;= pUglyNumbers[nextUglyIndex])</span><br><span class="line">            ++pMultiply3;</span><br><span class="line">        <span class="keyword">while</span>(*pMultiply5 * <span class="number">5</span> &lt;= pUglyNumbers[nextUglyIndex])</span><br><span class="line">            ++pMultiply5;</span><br><span class="line"></span><br><span class="line">        ++nextUglyIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ugly = pUglyNumbers[nextUglyIndex - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] pUglyNumbers;</span><br><span class="line">    <span class="keyword">return</span> ugly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> number1, <span class="keyword">int</span> number2, <span class="keyword">int</span> number3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = (number1 &lt; number2) ? number1 : number2;</span><br><span class="line">    min = (min &lt; number3) ? min : number3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题35第一个只出现一次的字符">面试题35：第一个只出现一次的字符</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>在字符串中找出第一个只出现一次的字符。如输入 <code>&quot;abaccdeff&quot;</code>，则输出 <code>'b'</code>。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>对于统计次数的题目，我们很容易想到使用哈希表来实现。c++的标准模版库中并没有哈希表的实现，当我们可以利用一个int型数组来实现，因为char类型中每个字符是8bits的，也即有256种可能，我们可以用一个长度为256的数组来模拟。</p>
<p>有了哈希表，我们只需要扫描2次字符串就可以实现题目要求了，也即时间复杂度为O(n)。具体来说，第一次扫描，我们统计每个字符的次数；第二次扫描则搜索哈希表中的次数，第一次出现次数为1时就代表找到了。</p>
<p>特别注意一下，哈希表要进行初始化，另外，如果没有只出现1次的字符，要明确该返回什么。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="keyword">char</span>* pString)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pString == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> tableSize = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hashTable[tableSize];</span><br><span class="line">    <span class="comment">// 初始化哈希表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i&lt;tableSize; ++ i)</span><br><span class="line">        hashTable[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次扫描字符串</span></span><br><span class="line">    <span class="comment">// 统计各字符的出现数目</span></span><br><span class="line">    <span class="keyword">char</span>* pHashKey = pString;</span><br><span class="line">    <span class="keyword">while</span>(*(pHashKey) != <span class="string">'\0'</span>)</span><br><span class="line">        hashTable[*(pHashKey++)] ++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二次扫描字符串</span></span><br><span class="line">    <span class="comment">// 依次把字符作为key检索哈希表</span></span><br><span class="line">    pHashKey = pString;</span><br><span class="line">    <span class="keyword">while</span>(*pHashKey != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hashTable[*pHashKey] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> *pHashKey;</span><br><span class="line"></span><br><span class="line">        pHashKey++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题36数组中的逆序对">面试题36：数组中的逆序对</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>最简单的解法是逐个扫描数组的数字，对每个数字都检查其后的所有数字来统计逆序对，复杂度是O(n^2)。</p>
<p>但是，这种解法显然太过耗费时间。有没有更快的方法呢？有的，采用<strong>归并排序</strong>的思想，我们可以借助一个和原数组等长的辅助数组来实现O(n logn)时间复杂度的解法。</p>
<p>具体来说，过程如下：</p>
<ol>
<li>
<p>把原数组对半分为两个子数组，对子数组继续对半分，直到子数组只包含单个数字，然后开始对相邻的子数组进行合并。</p>
</li>
<li>
<p>在合并时，我们从两个子数组的最后一位开始往前扫描（两个子数组都是递增数组），每次选择较大的一位放入辅助数组（从辅助数组的最后开始赋值，保证生成的也是递增数组）。</p>
<ul>
<li>如果靠前的子数组数字较大，那就代表这合并后它会和靠后子数组剩余的数字（都比它小）构成逆序对，此时总逆序对数目应加上靠后子数组剩余数字的数目。</li>
<li>如果靠后的子数组数字较大，就代表不构成逆序对，直接合并到辅助数组就可以了。</li>
</ul>
</li>
<li>
<p>如此经过多轮的分拆和合并，最后就能得到一个递增排序的辅助数组，同时统计好了逆序对的数目。</p>
</li>
</ol>
<p>再举个简单例子来捋顺思路吧，假设我们要统计数组 <code>7,5,6,4</code> 的逆序对数目，步骤如下：</p>
<ol>
<li>对半分数组 <code>7,5,6,4</code>，得到子数组 <code>7,5</code> 和 <code>6,4</code>；</li>
<li>对半分数组 <code>7,5</code>，得到子数组 <code>7</code> 和 <code>5</code>；</li>
<li>合并子数组 <code>7</code> 和 <code>5</code>，7比5大，逆序对加一，7放入辅助数组，子数组1空了，把子数组2的数字也放入辅助数组，得到辅助数组 <code>5,7</code>；</li>
<li>对半分数组 <code>6,4</code>，得到子数组 <code>6</code> 和 <code>4</code>；</li>
<li>合并子数组 <code>6</code> 和 <code>4</code>，6比4大，逆序对加一，6放入辅助数组，子数组1空了，把子数组2的数字也放入辅助数组，得到辅助数组 <code>4,6</code>；</li>
<li>子数组 <code>5,7</code> 和 <code>4,6</code>，7比6大，<strong>逆序对加二</strong>，7放入辅助数组。5比6小，6放入辅助数组。5比4大，逆序对加一，5放入辅助 数组，子数组1空了，把子数组2的数字也放入辅助数组，得到辅助数组 <code>4,5,6,7</code>；</li>
<li>合并完成，得到递增数组 <code>4,5,6,7</code>，逆序对数目为 <code>1+1+2+1=5（个）</code>。</li>
</ol>
<p>当然最好还是自己拿着纸举例分析来体验一下。假设我们把每一次归并中，用于合并的两个子数组称为数据数组，合并好的数组称为辅助数组。那么在转化为代码的过程中，<strong>合并出这一轮辅助数组用的是在获取这一轮两个数据数组时用的辅助数组</strong>。比方说上面例子中，步骤6用的两个数据数组其实就是步骤3和步骤5中得到的辅助数组 <code>5,7</code> 和辅助数组 <code>4,6</code>。</p>
<p><strong>那我们是否需要使用多个长度不一的辅助数组呢</strong>？不是的，我们用一个和输入数组等长的辅助数组就够了，只是用的方式有一点巧妙。在传递参数时，把子数组在原数组中start和end的索引也作为参数传递就可以了，这样相当于截取了原数组的一段。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">NULL</span> || length &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* copy = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++ i)</span><br><span class="line">        copy[i] = data[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = InversePairsCore(data, copy, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">delete</span>[] copy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InversePairsCore</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span>* copy, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 当分割到子数组只剩1个数字时，直接合并入辅助数组，逆序对数目为0</span></span><br><span class="line">    <span class="keyword">if</span>(start == end)</span><br><span class="line">    &#123;</span><br><span class="line">        copy[start] = data[start];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把当前数组分割成两部分</span></span><br><span class="line">    <span class="comment">// 注意data和copy作为参数的位置是换过来的</span></span><br><span class="line">    <span class="comment">// 因为这一轮用于归并的数据数组是两个子数组归并好的的结果（它们那一轮的辅助数组）</span></span><br><span class="line">    <span class="keyword">int</span> length = (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> left = InversePairsCore(copy, data, start, start + length);</span><br><span class="line">    <span class="keyword">int</span> right = InversePairsCore(copy, data, start + length + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i初始化为前半段最后一个数字的下标</span></span><br><span class="line">    <span class="keyword">int</span> i = start + length;</span><br><span class="line">    <span class="comment">// j初始化为后半段最后一个数字的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助数组的指针初始化在最后</span></span><br><span class="line">    <span class="keyword">int</span> indexCopy = end;</span><br><span class="line">    <span class="comment">// 逆序对数目初始化为0</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 合并两个子数组到辅助数组，从末尾开始比较，到达其中一方的头部时停止</span></span><br><span class="line">    <span class="keyword">while</span>(i &gt;= start &amp;&amp; j &gt;= start + length + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[i] &gt; data[j])</span><br><span class="line">        &#123;</span><br><span class="line">            copy[indexCopy--] = data[i--];</span><br><span class="line">            count += j - start - length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            copy[indexCopy--] = data[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把另一方余下的数字也合并到辅助数组中</span></span><br><span class="line">    <span class="keyword">for</span>(; i &gt;= start; --i)</span><br><span class="line">        copy[indexCopy--] = data[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(; j &gt;= start + length + <span class="number">1</span>; --j)</span><br><span class="line">        copy[indexCopy--] = data[j];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逆序对总数由三部分组成，两个子数组各自的逆序对数目加上合并它们产生的逆序对数目</span></span><br><span class="line">    <span class="keyword">return</span> left + right + count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题37两个链表的第一个公共结点">面试题37：两个链表的第一个公共结点</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>输入两个链表，找出它们的第一个公共结点。链表结点定义如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>       m_nValue;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解析">解析</h3>
<p>最呆萌的做法就是依次遍历其中一个链表的结点，每访问一个结点就遍历一次另一个链表，知道找到两个链表的公共结点。如果两个链表长度分别为m和n，这种方法的时间复杂度就是O(mn)。</p>
<p>当然不用这么笨的方法… 我们先观察一下两个有公共结点的链表有什么特点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span></span><br><span class="line">           \</span><br><span class="line">            <span class="number">6</span> -&gt; <span class="number">7</span></span><br><span class="line">           /</span><br><span class="line">     <span class="number">4</span> -&gt; <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>不难发现，<strong>两个有公共结点的链表从第一个公共结点到链表尾都是一样的</strong>。而且，如果两个链表相差k步，我们在长链表上先走k步，然后再同时遍历两个链表，就能很容易地找到第一个公共结点（如果没有则会一起走到链表尾的NULL）。</p>
<p>基于这个思路，实现代码并不难：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode *pHead1, ListNode *pHead2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 得到两个链表的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nLength1 = GetListLength(pHead1);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nLength2 = GetListLength(pHead2);</span><br><span class="line">    <span class="keyword">int</span> nLengthDif = nLength1 - nLength2;</span><br><span class="line"></span><br><span class="line">    ListNode* pListHeadLong = pHead1;</span><br><span class="line">    ListNode* pListHeadShort = pHead2;</span><br><span class="line">    <span class="keyword">if</span>(nLength2 &gt; nLength1)</span><br><span class="line">    &#123;</span><br><span class="line">        pListHeadLong = pHead2;</span><br><span class="line">        pListHeadShort = pHead1;</span><br><span class="line">        nLengthDif = nLength2 - nLength1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先在长链表上走几步，再同时在两个链表上遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLengthDif; ++ i)</span><br><span class="line">        pListHeadLong = pListHeadLong-&gt;m_pNext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((pListHeadLong != <span class="literal">NULL</span>) &amp;&amp;</span><br><span class="line">        (pListHeadShort != <span class="literal">NULL</span>) &amp;&amp;</span><br><span class="line">        (pListHeadLong != pListHeadShort))</span><br><span class="line">    &#123;</span><br><span class="line">        pListHeadLong = pListHeadLong-&gt;m_pNext;</span><br><span class="line">        pListHeadShort = pListHeadShort-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到第一个公共结点</span></span><br><span class="line">    ListNode* pFisrtCommonNode = pListHeadLong;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pFisrtCommonNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">GetListLength</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nLength = <span class="number">0</span>;</span><br><span class="line">    ListNode* pNode = pHead;</span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ++ nLength;</span><br><span class="line">        pNode = pNode-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/06/工作求职/剑指offer/2_面试需要的基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/06/工作求职/剑指offer/2_面试需要的基础知识/" itemprop="url">剑指offer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-06T11:11:41+08:00">
                2020-07-06
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-07-06T11:34:38+08:00" content="2020-07-06">
                2020-07-06
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面试需要的基础知识">面试需要的基础知识</h1>
<h2 id="面试题1赋值运算符函数">面试题1：赋值运算符函数</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>如下为类型CMyString的声明，请为该类型添加赋值运算符函数。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CMyString(<span class="keyword">char</span>* pData = <span class="literal">NULL</span>);</span><br><span class="line">    CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">    ~CMyString(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">    CMyString&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解析">解析</h3>
<p>乍一看，好像这个题目还挺简单的。但要注意的地方也不少。最基本的有以下几个需要考虑的点：</p>
<ol>
<li>
<p>返回值设置为<strong>该类型的引用</strong>，只有返回引用，才能够进行<strong>连续赋值</strong>。</p>
</li>
<li>
<p>传入参数设置为<strong>常量引用</strong>。如果直接传入实例（按值传递）的话，从形参到实参就需要调用一次复制构造函数，造成一些不必要的开销。又因为赋值运算中传入参数不需要被修改，所以声明为常量。</p>
</li>
<li>
<p>释放当前实例本身（等号左方）的内存。如果没有释放，又分配了新的空间，就会发生<strong>内存泄漏</strong>（未释放的部分一直占据着内存单元，直到程序结束）。</p>
</li>
<li>
<p>判断<strong>传入参数和当前实例是否同一个实例</strong>，如果是的话，直接返回当前实例。如果不做这个判断，那么释放当前实例内存时，就会把传入参数的内存也释放掉了，要赋值的内容就丢失了。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span> = (<span class="keyword">const</span> CMyString&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> []m_pData;</span><br><span class="line">    m_pData = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>]; <span class="comment">//注意+1，用于字符串的结尾字符'\0'</span></span><br><span class="line">    <span class="built_in">strcpy</span>(m_pData, str.m_pData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更进一步的话，针对<strong>内存不足</strong>的情况，可以在释放实例本身内存之前，检查一下，余下的内存空间是否足以分配所需的新空间。</p>
<p>具体来说，书中用了临时实例来实现，创建成功就交换当前实例和临时实例的值，在赋值完成后，临时实例被销毁，也即调用了析构函数把原本当前实例的内存释放了。</p>
<h2 id="面试题2实现singleton模式">面试题2：实现Singleton模式</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>设计一个类，我们只能生成该类的一个实例。</p>
</blockquote>
<p>题目要求实现单例这种设计模式，这个需求还是挺常见的。由于书中采用c#语言去实现，而且这题和语言本身的特性关系比较大，所以我不在这里进行详细解析了。网上也有用c++实现单例的代码，感兴趣的话可以查找一下相关资料。</p>
<h2 id="面试题3二维数组中的查找">面试题3：二维数组中的查找</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>按照这个二维数组的规律，要找出数组中是否包含目标数字，我们需要进行若干次比较操作。</p>
<p>如果是一个完全无序的数组，就需要逐个元素进行比较。</p>
<p>但对于这样有规律的数组，我们可以只跟对角线上的元素比较。比方说从左对角线（二维数组的左上角到右下角）的第一个元素（左上角）开始比较。当比较到上一个对角线元素比目标数字小，而下一个对角线元素比目标数字大时，只需要检查上一对角线元素的所在行的右边所有元素和所在列的下边所有元素就可以了。</p>
<p>能不能再减少一些比较次数呢？能！</p>
<p>如果从右对角线的第一个元素开始比较，只要该数比目标数字小，我们就可以删除掉它所在的行；只要该数比目标数字大，我们就可以删除掉它所在的列；如果相等，就查找结束。相比起上一种方法，这种方法需要查找的次数更少！（另外，从右对角线的最后一个元素开始也是可行的）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> columns, <span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(matrix != <span class="literal">NULL</span> &amp;&amp; rows &gt; <span class="number">0</span> &amp;&amp; columns &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> column = columns - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row &lt; rows &amp;&amp; column &gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row * columns + column] == number)</span><br><span class="line">            &#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row * columns + column] &gt; number)</span><br><span class="line">                -- column;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++ row;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题4替换空格">面试题4：替换空格</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>请实现一个函数，把字符串中的每个空格替换成&quot;%20&quot;，例如输入 “We are happy.”，则输出 “We%20are%20ha</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>如果我们每替换一次都往后挪后面的所有字符，那么时间复杂度就是O(n^2)的，这样做了很多无用功，因为每个字符重复移动了多次。</p>
<p>更好的做法是先计算后新字符串的长度，然后从字符串的后部开始检查并赋值，这样每个需要移动的字符只需要移动一次就完成了，总得时间复杂度是O(n)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReplaceBlank</span><span class="params">(<span class="keyword">char</span> <span class="built_in">string</span>[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">string</span> == <span class="literal">NULL</span> &amp;&amp; length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*originalLength 为字符串string的实际长度*/</span></span><br><span class="line">    <span class="keyword">int</span> originalLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> numberOfBlank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">string</span>[i] != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ++ originalLength;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">string</span>[i] == <span class="string">' '</span>)</span><br><span class="line">            ++ numberOfBlank;</span><br><span class="line"></span><br><span class="line">        ++ i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*newLength 为把空格替换成'%20'之后的长度*/</span></span><br><span class="line">    <span class="keyword">int</span> newLength = originalLength + numberOfBlank * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(newLength &gt; length)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> indexOfOriginal = originalLength;</span><br><span class="line">    <span class="keyword">int</span> indexOfNew = newLength;</span><br><span class="line">    <span class="keyword">while</span>(indexOfOriginal &gt;= <span class="number">0</span> &amp;&amp; indexOfNew &gt; indexOfOriginal)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">string</span>[indexOfOriginal] == <span class="string">' '</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>[indexOfNew --] = <span class="string">'0'</span>;</span><br><span class="line">            <span class="built_in">string</span>[indexOfNew --] = <span class="string">'2'</span>;</span><br><span class="line">            <span class="built_in">string</span>[indexOfNew --] = <span class="string">'%'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>[indexOfNew --] = <span class="built_in">string</span>[indexOfOriginal];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        -- indexOfOriginal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题5从尾到头打印链表">面试题5：从尾到头打印链表</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>输入一个链表的头结点，从尾到头反过来打印出每个结点的值。链表结点定义如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>       m_nValue;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解析">解析</h3>
<p>两种想法：</p>
<ol>
<li>
<p>要反过来输出的话，可以首先顺着遍历链表并且将每个结点的值放入栈中，<strong>利用栈后进先出的特性</strong>来逐个pop出再输出；</p>
</li>
<li>
<p>利用递归，递归本质上就是一个栈结构。但是当链表很长的时候，使用递归有可能导致函数调用的层级很深，从而发生函数调用栈溢出的问题。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintListReversingly_Iteratively</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;ListNode*&gt; nodes;</span><br><span class="line"></span><br><span class="line">    ListNode* pNode = pHead;</span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nodes.push(pNode);</span><br><span class="line">        pNode = pNode-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        pNode = nodes.top();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, pNode-&gt;m_nValue);</span><br><span class="line">        nodes.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintListReversingly_Recursively</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead-&gt;m_pNext != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            PrintListReversingly_Recursively(pHead-&gt;m_pNext);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, pHead-&gt;m_nValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题6重建二叉树">面试题6：重建二叉树</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列 <code>{1,2,4,7,3,5,6,8}</code> 和中序遍历序列 <code>{4,7,2,1,5,3,8,6}</code>，则重建出如下所示的二叉树:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> /   / \</span><br><span class="line">4   5   6</span><br><span class="line"> \     /</span><br><span class="line">  7   8</span><br></pre></td></tr></table></figure>
<blockquote>
<p>二叉树结点的定义如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                    m_nValue;</span><br><span class="line">    BinaryTreeNode*        m_pLeft;</span><br><span class="line">    BinaryTreeNode*        m_pRight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解析">解析</h3>
<p>由中序遍历和前序遍历序列重建树，我们可以每次取出前序遍历序列的第一个点，它对应当前树的根节点。</p>
<p>而在中序遍历序列中，这个点将序列分为左右两部分，左边就是根节点的左子树，右边的右子树。</p>
<p>并且，假设左边有m个点，右边有n个点。那么在前序遍历序列中，第一个点接下来的m个点必然就是左子树，再往后的n个点必然就是右子树。</p>
<p>因此，我们可以利用递归来完成重建，每次都按前序遍历序列的第一个点来划分中序遍历序列，进而划分前序遍历序列，然后分别重建根节点的左右子树即可。</p>
<p>特别要注意<strong>结束条件的设置</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">Construct</span><span class="params">(<span class="keyword">int</span>* preorder, <span class="keyword">int</span>* inorder, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preorder == <span class="literal">NULL</span> || inorder == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ConstructCore(preorder, preorder + length - <span class="number">1</span>,</span><br><span class="line">        inorder, inorder + length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinaryTreeNode* ConstructCore</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">int</span>* startPreorder, <span class="keyword">int</span>* endPreorder,</span><br><span class="line">    <span class="keyword">int</span>* startInorder, <span class="keyword">int</span>* endInorder</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 前序遍历序列的第一个数字是根结点的值</span></span><br><span class="line">    <span class="keyword">int</span> rootValue = startPreorder[<span class="number">0</span>];</span><br><span class="line">    BinaryTreeNode* root = <span class="keyword">new</span> BinaryTreeNode();</span><br><span class="line">    root-&gt;m_nValue = rootValue;</span><br><span class="line">    root-&gt;m_pLeft = root-&gt;m_pRight = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归到前序遍历的最后一个点</span></span><br><span class="line">    <span class="keyword">if</span>(startPreorder == endPreorder)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 递归到中序遍历的最后一个点，并且这个点和前序遍历的最后一个点相同</span></span><br><span class="line">        <span class="keyword">if</span>(startInorder == endInorder &amp;&amp; *startPreorder == *startInorder)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> exception();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在中序遍历中找到根结点的值</span></span><br><span class="line">    <span class="keyword">int</span>* rootInorder = startInorder;</span><br><span class="line">    <span class="keyword">while</span>(rootInorder &lt;= endInorder &amp;&amp; *rootInorder != rootValue)</span><br><span class="line">        ++ rootInorder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历到最后还是找不到根节点就说明两个遍历序列是不相容的，属于异常输入</span></span><br><span class="line">    <span class="keyword">if</span>(rootInorder == endInorder &amp;&amp; *rootInorder != rootValue)</span><br><span class="line">        <span class="keyword">throw</span> exception();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftLength = rootInorder - startInorder;</span><br><span class="line">    <span class="keyword">int</span>* leftPreorderEnd = startPreorder + leftLength;</span><br><span class="line">    <span class="keyword">if</span>(leftLength &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构建左子树</span></span><br><span class="line">        root-&gt;m_pLeft = ConstructCore(startPreorder + <span class="number">1</span>, leftPreorderEnd,</span><br><span class="line">            startInorder, rootInorder - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(leftLength &lt; endPreorder - startPreorder)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构建右子树</span></span><br><span class="line">        root-&gt;m_pRight = ConstructCore(leftPreorderEnd + <span class="number">1</span>, endPreorder,</span><br><span class="line">            rootInorder + <span class="number">1</span>, endInorder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题7用两个栈实现队列">面试题7：用两个栈实现队列</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead，分别完成在队列尾部插入结点和在队列头部删除结点的功能。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">CQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CQueue(<span class="keyword">void</span>);</span><br><span class="line">    ~CQueue(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在队列末尾添加一个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">const</span> T&amp; node)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除队列的头结点</span></span><br><span class="line">    <span class="function">T <span class="title">deleteHead</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;T&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;T&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解析">解析</h3>
<p>思路其实很简单，使用两个栈来模拟。每次要往队尾插入一个数，就放到栈1里面。当需要出队，也即删除队首时，只需要把栈1的数依次出栈（顺序是队尾到队首）再放入栈2，这时从栈2pop出的数就是队首了。</p>
<p>注意，并不是每次出队都需要这样操作，我们首先做个判断，如果栈2空了再做。如果栈2没空，那么现在的队首就应该是栈2的栈顶元素了~</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> CQueue&lt;T&gt;::appendTail(<span class="keyword">const</span> T&amp; element)</span><br><span class="line">&#123;</span><br><span class="line">    stack1.push(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T CQueue&lt;T&gt;::deleteHead()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(stack2.size()&lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(stack1.size()&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            T&amp; data = stack1.top();</span><br><span class="line">            stack1.pop();</span><br><span class="line">            stack2.push(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(stack2.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> exception();</span><br><span class="line"></span><br><span class="line">    T head = stack2.top();</span><br><span class="line">    stack2.pop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题8旋转数组的最小数字">面试题8：旋转数组的最小数字</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组 <code>{3,4,5,1,2}</code> 为 <code>{1,2,3,4,5}</code> 的一个旋转，该数组的最小值为1。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>这道题其实有点类似于有序数组查找一个数的情况，还是可以<strong>用二分查找的思路</strong>。</p>
<p>旋转数组其实可以分两成两个递增子数组A1和A2，而最小元素就是数组A2的第一个元素。</p>
<p>具体来说，我们使用两个指针p1和p2，分别指向A1的第一个元素和A2的最后一个元素。p1右移，p2左移，不断缩小需要比较的范围。当p1和p2相差1时，p2所指的就是数组的最小元素，这就是终止条件。</p>
<p>怎样使用二分查找的思路缩小范围呢？很简单。假设当前序列的中间序列为m，我们比较一下m和p1所指的元素谁比较大。如果m更大或者与p1相等，就说明m位于A1中，那么p1和m之间的元素我们都不再需要比较了，它们都比p1大，肯定不是最小元素，此时我们可以令p1指向m，得到新的序列，并继续下一次查找。</p>
<p>反过来，如果m比p1所指的元素小，那就说明m位于A2中，此时最小元素在p1和m之间，我们可以令p2指向m来缩小查找范围。</p>
<p>注意了！既然是比大小，那就很有可能出现相等的情况。当p1，p2和m都相等时，我们无法判断m到底属于A1还是A2，也就无法缩小范围。比方说数组 <code>{1,0,1,1,1}</code>，如果我们按照先比较p1和m的方式，下一步就变成搜索数组 <code>{1,1,1}</code> 了，显然是不对的。</p>
<p>怎样处理这种情况呢？很可惜，没有取巧的方法，遇到这样的情况，我们只能顺序查找当前数组了。</p>
<p>注意，在初始化中间元素时，不应直接初始化为0，而应初始化为p1所指的元素。因为旋转数组有可能是将0个数字旋转到尾部，也即整个数组依然是一个递增数组。如果我们将p1大于等于p2作为循环查找的条件，那就要特别注意这个点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> exception();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index2 = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> indexMid = index1; <span class="comment">// 如果旋转了0个元素，那么最小元素就是index1所指的，所以这样初始化</span></span><br><span class="line">    <span class="keyword">while</span>(numbers[index1] &gt;= numbers[index2])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果index1和index2指向相邻的两个数，</span></span><br><span class="line">        <span class="comment">// 则index1指向第一个递增子数组的最后一个数字，</span></span><br><span class="line">        <span class="comment">// index2指向第二个子数组的第一个数字，也就是数组中的最小数字</span></span><br><span class="line">        <span class="keyword">if</span>(index2 - index1 == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            indexMid = index2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果下标为index1、index2和indexMid指向的三个数字相等，</span></span><br><span class="line">        <span class="comment">// 则只能顺序查找</span></span><br><span class="line">        indexMid = (index1 + index2) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers[index1] == numbers[index2] &amp;&amp; numbers[indexMid] == numbers[index1])</span><br><span class="line">            <span class="keyword">return</span> MinInOrder(numbers, index1, index2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缩小查找范围</span></span><br><span class="line">        <span class="keyword">if</span>(numbers[indexMid] &gt;= numbers[index1])</span><br><span class="line">            index1 = indexMid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[indexMid] &lt;= numbers[index2])</span><br><span class="line">            index2 = indexMid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numbers[indexMid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinInOrder</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = numbers[index1];</span><br><span class="line">    <span class="comment">// 按顺序查找</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = index1 + <span class="number">1</span>; i &lt;= index2; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(result &gt; numbers[i])</span><br><span class="line">            result = numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题9斐波拉契数列">面试题9：斐波拉契数列</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>写一个函数，输入n，求斐波拉契（Fibonacci）数列的第n项。斐波拉契数列的定义如下：</p>
</blockquote>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f00c4321176b6522fe148a11a80a8e5fca9e88da" alt="fib1">，初始值：<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6890c552b2226e339520693a236386ed2346a63a" alt="fib1"></p>
<h3 id="解析">解析</h3>
<p>求斐波拉契数列最简单的一种思路是使用递归，但是递归其实是一种效率非常低的解法，举个例子，求数列的第10项，过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">             f(10)</span><br><span class="line">            /    \</span><br><span class="line">        f(9)      f(8)</span><br><span class="line">       /    \    /    \</span><br><span class="line">    f(8)  f(7) f(7)  f(6)</span><br><span class="line">...  ...  ...  ...  ...  ...</span><br></pre></td></tr></table></figure>
<p>每一项都被分解为左右两棵子树来求，可以看到左右两棵子树会有很多重复的结点，这些都是冗余的。当n相当大时，会有大量的冗余结点，造成求解的效率非常低。</p>
<p>更好的思路是采用O(n)的解法，从f(2)开始逐步往上算，这样每一项只求一次就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Fibonacci_Solution2</span><span class="params">(<span class="keyword">unsigned</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> result[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span>  fibNMinusOne = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span>  fibNMinusTwo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span>  fibN = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        fibN = fibNMinusOne + fibNMinusTwo; <span class="comment">// f(n) = f(n-1) + f(n-2)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新f(n-1) 和 f(n-2)</span></span><br><span class="line">        fibNMinusTwo = fibNMinusOne;</span><br><span class="line">        fibNMinusOne = fibN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> fibN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外还有基于矩阵乘法的O(log n)解法，这里暂不深入探索，感兴趣的话可以在代码文件中查看。</p>
<h2 id="面试题10二进制中1的个数">面试题10：二进制中1的个数</h2>
<h3 id="题目">题目</h3>
<blockquote>
<p>请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。</p>
</blockquote>
<h3 id="解析">解析</h3>
<p>最简单的一个思路，每次将这个整数的二进制表示右移一位，统计个位是1的次数，数字变为0时结束。</p>
<p>二进制右移一位这个操作其实相当于将整数除以2，但这里我们不使用除法，因为除法效率很低，<strong>在实际任务中，应尽量使用位运算</strong>。另外，判断各位是不是1，只要和1相与就可以了，整数1的二进制表示是31个0并上一个1，因此只有各位是1时，两数相与才会得到1。</p>
<p>但是！上面的思路有一个很严重的问题，题目说的是整数，而不是正整数。c++中整数的表示范围是 <code>[-2147483648,2147483647]</code>，用32个bit表示，并且最高位是符号位（正数为0，负数为1）。在右移的时候，因为要保证移位前后符号相同，所以负数高位补的是1。这样数字永远都不会是0，程序会陷入死循环中。</p>
<p>这里补充一点，负数的二进制表示是将对应的正数所有位取反，然后加一。举个例子：</p>
<p>32位的int类型中，</p>
<ul>
<li>
<p>正数5的二进制表示为 <code>00000000000000000000000000000101</code>；</p>
</li>
<li>
<p>而负数-5的二进制表示就是 <code>11111111111111111111111111111011</code>。</p>
</li>
<li>
<p>最大整数2147483647的二进制表示是    <code>01111111111111111111111111111111</code>；</p>
</li>
<li>
<p>对应负数-2147483647的二进制表示则是 <code>10000000000000000000000000000001</code>。</p>
</li>
</ul>
<p>特别地，最小负数-2147483648的二进制表示是 <code>10000000000000000000000000000000</code>。</p>
<p>注意了，这些表示是要看数值类型所用的位数来定的。</p>
<p>在了解了这些情况之后，可以想到一个新的思路。设定unsigned int类型的变量flag为1，我们可以把对输入的整数进行右移改为对flag进行左移，每一次相与之后就把flag左移一位，对于flag来说，左移32位后就变为0了，我们可以利用这点作为循环结束的条件。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1_Solution1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; flag)</span><br><span class="line">            count ++;</span><br><span class="line"></span><br><span class="line">        flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难发现，上面的解法是根据数值类型来决定循环次数的，一个int类型的数就需要循环32次。有没有办法再减少次数呢？有的！</p>
<p>我们先做个分析，一个数减去1之后，它的二进制表示有两种可能的变化：</p>
<ul>
<li>最右边一位是1，则最右边一位变0，其他位不变；</li>
<li>最右边一位没有1，则最靠右的1（只要一个数不为0，则至少存在一位是1）变0，该位的右边都变为1。</li>
</ul>
<p>如果我们把减去1之后的数和原来的数相与，会发生什么呢？可以发现，这样操作实质是<strong>把原来数字最靠右的1变为0，其余位不变</strong>！于是，一个整数的二进制表示<strong>有多少个1就可以进行多少次这样的操作</strong>，大大减少了循环的次数！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1_Solution2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        ++ count;</span><br><span class="line">        n = (n - <span class="number">1</span>) &amp; n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/06/工作求职/计算机网络/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/06/工作求职/计算机网络/" itemprop="url">计算机网络</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-06T09:29:04+08:00">
                2020-07-06
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-08-30T13:22:36+08:00" content="2020-08-30">
                2020-08-30
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/06/基础知识/OS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/06/基础知识/OS/" itemprop="url">OS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-06T09:28:41+08:00">
                2020-07-06
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-08-30T13:23:03+08:00" content="2020-08-30">
                2020-08-30
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/05/Blog/blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/05/Blog/blog/" itemprop="url">blog 产生记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-05T22:52:19+08:00">
                2020-07-05
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-08-30T13:29:20+08:00" content="2020-08-30">
                2020-08-30
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="部署">部署</h3>
<p>hexo<br>
next</p>
<h3 id="plugin">plugin</h3>
<ul>
<li>hexo-generator-search</li>
<li>hexo-renderer-markdown-it</li>
</ul>
<h3 id="path">path</h3>
<p>hexo 配置文件 : “D:\Document\Github_Blog\hexo\config.yml”</p>
<h3 id="问题">问题</h3>
<p><a href="https://convivae.top/posts/hexo-bo-ke-cai-keng/" target="_blank" rel="noopener">hexo toc 锚点失效</a><br>
<a href="https://hexo.io/docs/configuration#Directory" target="_blank" rel="noopener">使用 skip_render 排除某些psot的渲染</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/05/基础知识/Clousim/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/05/基础知识/Clousim/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-05T16:40:45+08:00">
                2020-07-05
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-08-30T13:25:00+08:00" content="2020-08-30">
                2020-08-30
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.trojx.me/2019/12/30/cloudsim-plus-faq/" target="_blank" rel="noopener">云计算仿真工具CloudSim Plus常见问题总结</a><br>
<a href="https://veviz.github.io/2016/05/17/CloudSim/" target="_blank" rel="noopener">CloudSim Introduction</a><br>
<a href="https://blog.csdn.net/wjh1313677/article/details/45625999" target="_blank" rel="noopener">CloudSim源码分析-DatacenterBroker创建</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">chengr</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">87</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">48</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chengr</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
