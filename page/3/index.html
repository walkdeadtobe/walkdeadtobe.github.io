<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":250,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="知行合一">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="知行合一">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="知行合一">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>知行合一</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">知行合一</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/10/工作求职/面试常见题全面分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/10/工作求职/面试常见题全面分析/" class="post-title-link" itemprop="url">面试常见题全面分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-10 14:13:31" itemprop="dateCreated datePublished" datetime="2020-09-10T14:13:31+08:00">2020-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-15 10:57:57" itemprop="dateModified" datetime="2021-01-15T10:57:57+08:00">2021-01-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="java">JAVA</h2>
<h3 id="泛型">泛型</h3>
<p><a href="http://www.itxm.cn/post/4185.html" target="_blank" rel="noopener">java为什么要用类型擦除实现泛型？详解</a><br>
泛型是将类型作为参数,实现代码复用可以保证</p>
<ul>
<li>定义一次类,可以被各种类使用</li>
<li>具体使用时,只保存自己定义类型,而不是object引用</li>
</ul>
<h4 id="c-实现">C++ 实现</h4>
<p>利用宏定义实现代码替换,来实现模板类,在编译期对不同类型基于模板类生成不同的代码,代码冗余</p>
<h4 id="java">JAVA</h4>
<p>java 泛型在底层利用Object引用实现泛型,编译时做类型检查，在运行时擦除<br>
java 泛型在对象进和出的时候强制对象类型转换为Object和目标对象,仅仅是引用的转换</p>
<h3 id="重写的实现">重写的实现</h3>
<p><a href="https://www.cnblogs.com/kexinxin/p/10147209.html" target="_blank" rel="noopener">参考1</a><br>
<a href="http://zhongmingmao.me/2018/12/17/jvm-basic-invoke/" target="_blank" rel="noopener">参考2</a><br>
字节码中包含4中对方法的调用</p>
<ul>
<li>invokevirtual为最常见的情况，包含virtual dispatch机制；</li>
<li>invokerspecial是作为对private和构造方法的调用，绕过了virtual dispatch;</li>
<li>invokeinterface的实现跟invokevirtual类似；</li>
<li>invokestatic是对静态方法的调用</li>
</ul>
<p>其中invokevirtual 实现了虚分配  完成重写方法的调用<br>
虚分配机制</p>
<blockquote>
<p>该机制会首先从调用对象中寻找该方法的实现,如果没有,就到父类接口寻找,直至找到或者抛出异常,并不依赖于引用的定义类型<br>
在虚分派机制下如何调用父类被覆盖的方法?<br>
使用virtualspecial指令,字节码在定义时会执行父类对象及其方法</p>
</blockquote>
<p>在JVM 中使用方法表实现虚分派机制</p>
<blockquote>
<p>方法表值不记录静态函数,私有函数,final,构造函数;方法表与类class相关<br>
JVM中的一种实现是</p>
<ul>
<li>表中每项对应一个实例方法(方法的实际代码)的索引</li>
<li>父类比子类先得到解析,即父类的方法放在方法表前列(根据方法名参数类型顺序构成的唯一标识,子类发现重复即覆盖索引)</li>
<li>如果子类重写父类的方法,那么父类方法的索引将更改指向为该类的相应实例方法</li>
<li>JVM 遇到一个方法时首先根据它在方法表中的偏移量类访问</li>
</ul>
</blockquote>
<p>invokeinterface与invokevirtual的比较</p>
<blockquote>
<p>当使用invokeinterface来调用方法时，由于不同的类可以实现同一interface,我们无法确定在某个类中的interface中的方法处在哪个位置。于是，也就无法解释CONSTANT_interfaceMethodref-info为直接索引，而必须每次都执行一次在methodtable中的搜索了。所以，在这种实现中，通过invokeinterface访问方法比通过invokevirtual访问明显慢很多。</p>
</blockquote>
<h3 id="解析和分派">解析和分派</h3>
<p>编译期符号引用会在加载时被解析成实际引用<br>
虚方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的虚方法表也一同初始化完毕</p>
<h3 id="基本数据类型和类">基本数据类型和类</h3>
<p>int  Integer  atomicInteger<br>
int 是基本数据类型,有默认值,但是编译器可能提醒需要初始化才能使用<br>
Integer 是final class  继承Number 和compartor,包含final修饰的int变量 value,MIN,MAX; 里面包含 object 的基本方法(hashcode equals toString);Integer.valueOf()等等<br>
integer ++ 相当于新生成了变量</p>
<p>atomicInteger 并发场景下,利用volatile修饰int,保持变量的可见性</p>
<h3 id="automic-分析">automic 分析</h3>
<h2 id="jvm">JVM</h2>
<ol>
<li>垃圾回收 和 G1<br>
垃圾回收的原因 对象利用<br>
判断垃圾的方法：可达分析 和 引用计数(循环引用的问题难以解决)<br>
垃圾回收算法：标记清除 标记整理 复制  分代收集(标记清除+复制)<br>
垃圾回收器的分类 ：针对年轻代 和针对老年代的<br>
分配担保以及老年代不足引起的fullgc<br>
3色标记 黑灰白<br>
四种引用 强软弱虚<br>
CMS VS G1<br>
垃圾回收的阶段初始标记 并发标记 重新标记(对象消失 浮动垃圾 写屏障) 并发清除<br>
GC root的概念卡表 以及如何加快,和如何应对出现的伪共享问题<br>
oopmap<br>
参考：<br>
<a href="https://cloud.tencent.com/developer/article/1599225" target="_blank" rel="noopener"></a></li>
</ol>
<h3 id="gc-优化">GC 优化</h3>
<p>首先监控GC状态：jstat -gc<br>
然后根据结果GC(MIRROgc/FULLGC) 时间和频率 如果频率相对高而且时间长那么需要优化<br>
优化方法:</p>
<ul>
<li>代码分析</li>
<li>增加内存</li>
<li>更改老年代年轻代比例</li>
</ul>
<h2 id="mysql">MYSQL</h2>
<h3 id="数据同步">数据同步</h3>
<p>mysql 多副本保持数据一致性,需要同步;有两种选择多写以及复制</p>
<ul>
<li>多写：主收到写命令后,需要向从数据库发送写命令 根据返回结果确认是否完成该次写操作(涉及分布式事务的提交,引出二段式提交以及三段式提交) 异步 半同步  全同步</li>
<li>复制 ：首先进行 全量复制(线下人工可靠;线上:利用工具 队列 流式数据写入) 之后进行增量复复制：读写分离
<ul>
<li>首先要保证master端的bnglog 和slave端的relay日志功能开启</li>
<li>master端在执行完命令后悔记录在binlog中</li>
<li>slave端发出IO请求到master端 要求同步指定位置之后的数据</li>
<li>master端接收到IO请求,会返回数据以及本地同步的终点位置,可以用于下一次同步</li>
<li>slave端接收到数据会写进自己的relay日志中,slave端检测到relay日志发生变化就会读取更新然后写进数据库</li>
</ul>
</li>
</ul>
<h3 id="索引">索引</h3>
<p>mysql 索引</p>
<ul>
<li>主键索引 聚簇索引 范围查询 局部性好</li>
<li>唯一索引的使用需要谨慎 :因为插入和更新时需要加载所有数据到缓冲池(缓冲池的概念和用处 缓冲池的淘汰策略)去,不能有效的利用写缓冲</li>
<li>主键 建议使用 自增ID 这样在添加记录的时候不会造成页的分裂</li>
<li>为什么不适用红黑树 b+树多路查找树可以有效降低树的高度,提高查询效率,而且非叶子交接点没有数据相同的空间可以更有效的利用索引</li>
</ul>
<p>mysql 双写的原因和解决方法;索引的插入导致页的分裂和合并</p>
<blockquote></blockquote>
<h3 id="mysql-事务">mysql 事务</h3>
<p>mysql的四个事务隔离级别<br>
利用MVCC 可以满足读已提交和可重复读(偏向update)的要求,配合间隙锁避免幻读<br>
间隙所</p>
<h3 id="举例">举例</h3>
<h4 id="读写事务并发">读写事务并发</h4>
<p>读写事务的顺序可以有4种</p>
<ul>
<li>读后写</li>
<li>写后读</li>
<li>读中间发生写</li>
<li>写中间发生读</li>
</ul>
<p>对于前两种,不需要进行控制,后两种需要利用利用,MVCC 加以控制<br>
innodb在行记录添加了隐藏字段 包括修改记录的事务ID字段 比如update/insert/delete 和 指向当前记录上一版本的回滚指针(利用undolog实现,可以实现未提交事务的原子性)<br>
在可重复读的事务隔离级别下,读操作共享一个readview,readview是一个数据结构,包含创建其的事务ID,创建时活跃的事务ID列表,以及该列表的最小ID和创建时未分配的最小ID<br>
在读时使用算法去读取行记录或者undolog中的历史链记录来实现update层次的可重复读<br>
从当前行记录可以获得,该记录的修改写事务ID</p>
<ul>
<li>如果其小于readview的最小值,意味着 该写事务必然在读事务之前发生且已经结束,那么尽管读</li>
<li>如果事务ID 等于 readview的所属事务ID ,那么是自己改的,可以读</li>
<li>如果在readview范围内,那么要寻找该事物是否在readview的活跃列表里,如果在,那么意味着该写事务仍在进行,所以不能读未提交,需要沿着历史链继续寻找可以读的记录;如果不在,意味着该写事物在读操作发生之前已经结束,所以可以读已提交</li>
<li>如果其大于readview的最大值,意味着 该行记录是在读事务发生后更改的,那么不能读,要沿着undolog的历史版本链去找可以读的</li>
</ul>
<h4 id="写写事务并发">写写事务并发</h4>
<h4 id="幻读">幻读</h4>
<h4 id="insert-从代码层次到数据库执行的流程">insert 从代码层次到数据库执行的流程</h4>
<ul>
<li>spring 事务管理:事务传播机制</li>
<li>mybatic 动态sql</li>
<li>mysql server
<ul>
<li>命令优化</li>
<li>存储引擎 innodb
<ul>
<li>遵循二段锁提交协议,首先对表添加写意向锁,在没有对表添加读锁的情况可以实现</li>
<li>如果是自增主键,那么需要自增锁生成ID,随后对主键索引添加间隙锁,insert之后对于记录添加写锁</li>
<li>由于是对主键索引/唯一索引操作所以无法使用写缓冲,将页读入缓存,写入,然后双写刷回</li>
<li>如果没有其他事务,就会逐一释放锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="checkpoint"><a href="https://blog.51cto.com/10170308/1678302" target="_blank" rel="noopener">checkpoint</a></h4>
<h4 id="串行化">串行化</h4>
<ol start="3">
<li>redis<br>
redis 数据结构及其原理<br>
redis 主从部署 哨兵模式 选举机制 读写分离<br>
缓存穿透/雪崩/击穿/降级/熔断<br>
缓存击穿的解决方法</li>
</ol>
<ul>
<li>在业务端利用reids SETNX 互斥的获得锁,去更新键值</li>
<li>检查高频字段是否超时,快超时时加长过期时间</li>
<li>使用消息队列，让流量在消息队列中囤积下，逐个消费，缓解后端压力。<br>
redis 缓存和数据库双写一致性<br>
redis IO多路复用<br>
redis 分布式
<ul>
<li>redis 集群</li>
<li>redis 分布式锁</li>
</ul>
</li>
</ul>
<p>redis 锁</p>
<ul>
<li>setnx(key,1) + expire(key,30) =set(key，1，30，NX) del(key);避免多线程操作导致删除了别人的锁,可以把threadId作为key值<br>
分布式锁的单点故障问题:在redis集群模式下可以尝试获取大多数master 的锁,超过一般才算,避免死锁可以按照一定顺序去获得锁<br>
zookeeper分布式锁</li>
</ul>
<p>发布订阅功能</p>
<ol start="4">
<li>并发 编程</li>
</ol>
<ul>
<li>伪共享 影响并发效率</li>
</ul>
<p>http 请求到完成的过程</p>
<blockquote>
<p>DNS系统迭代查询域名对应的ip;<br>
TCP 3次握手建立连接;发送报文请求<br>
发送端从顶层到底层的报文封装;从底层(信道集线器)到ip层(路由器)的数据传输;接收端从底层到顶层的解封</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/04/工作求职/Nginx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/04/工作求职/Nginx/" class="post-title-link" itemprop="url">Nginx</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-04 17:04:30" itemprop="dateCreated datePublished" datetime="2020-09-04T17:04:30+08:00">2020-09-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-15 10:57:23" itemprop="dateModified" datetime="2021-01-15T10:57:23+08:00">2021-01-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Nginx是一个web服务器和反向代理服务器，用于HTTP、HTTPS、SMTP、POP3和IMAP协议</p>
<h2 id="nginx-描述">Nginx 描述</h2>
<p>nginx 是一个高性能的web服务器和方向代理服务器;</p>
<ol>
<li>Nginx 特性</li>
</ol>
<blockquote>
<p>反向代理/L7负载均衡器<br>
动态二进制升级<br>
嵌入式Perl解释器<br>
可用于重新编写URL，具有非常好的PCRE支持</p>
</blockquote>
<ol start="2">
<li>Nginx VS Apache</li>
</ol>
<blockquote>
<p>轻量级，同样起web 服务，比apache 占用更少的内存及资源<br>
抗并发，nginx 处理请求是异步非阻塞的，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能<br>
高度模块化的设计，编写模块相对简单<br>
最核心的区别在于apache是同步多进程模型，一个连接对应一个进程；nginx是异步的，多个连接（万级别）可以对应一个进程</p>
</blockquote>
<ol start="3">
<li>nginx是如何实现高并发的</li>
</ol>
<blockquote>
<p>一个主进程，多个工作进程，每个工作进程可以处理多个请求，每进来一个request，会有一个worker进程去处理。<br>
Worker处理到可能发生阻塞的地方，比如向上游（后端）服务器转发request，并等待请求返回。那么，这个处理的worker继续处理其他请求，而一旦上游服务器返回了，就会触发这个事件，worker才会来接手，这个request才会接着往下走。<br>
由于web server的工作性质决定了每个request的大部份生命都是在网络传输中，实际上花费在server机器上的时间片不多<br>
从而实现高并发</p>
</blockquote>
<ol start="4">
<li>解释Nginx如何处理HTTP请求</li>
</ol>
<blockquote>
<p>Nginx使用反应器模式。主事件循环等待操作系统发出准备事件的信号，这样数据就可以从套接字读取，在该实例中读取到缓冲区并进行处理。单个线程可以提供数万个并发连接。</p>
</blockquote>
<ol start="5">
<li>反应器模式</li>
</ol>
<blockquote>
<p>当一个主体发生改变时，所有依属体都得到通知。不过，观察者模式与单个事件源关联，而反应器模式则与多个事件源关联</p>
</blockquote>
<p>同步和异步区别：有无通知（是否轮询）<br>
堵塞和非堵塞区别：操作结果是否等待（是否马上有返回值），只是设计方式的不同</p>
<ol start="6">
<li>在Nginx中，如何使用未定义的服务器名称来阻止处理请求?</li>
</ol>
<blockquote>
<p>server_name设置为一个空字符串，它将在没有“主机”头字段的情况下匹配请求，而一个特殊的Nginx的非标准代码444被返回，从而终止连接</p>
</blockquote>
<ol start="7">
<li>使用&quot;反向代理服务器&quot;的优点是什么</li>
</ol>
<blockquote>
<p>安全：反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和web服务器之间的中间层。这对于安全方面来说是很好的，特别是当您使用web托管服务时</p>
</blockquote>
<ol start="8">
<li>请列举Nginx服务器的最佳用途</li>
</ol>
<blockquote>
<p>正向:做缓存,加快速度;j静态网站展示;转发请求<br>
反向代理:安全;负载均衡</p>
</blockquote>
<ol start="9">
<li>请解释Nginx服务器上的Master和Worker进程分别是什么</li>
</ol>
<blockquote>
<p>Master进程：读取及评估配置和维持<br>
Worker进程：处理请求</p>
</blockquote>
<ol start="10">
<li>请解释是否有可能将Nginx的错误替换为502错误、503?</li>
</ol>
<blockquote>
<p>502 =错误网关 503 =服务器超载 有可能，但是您可以确保fastcgi_intercept_errors被设置为ON，并使用错误页面指令。</p>
</blockquote>
<ol start="11">
<li>在Nginx中，解释如何在URL中保留双斜线?</li>
</ol>
<blockquote>
<p>要在URL中保留双斜线，就必须使用merge_slashes_off;默认on</p>
</blockquote>
<ol start="12">
<li>ngx_http_upstream_module的作用是什么</li>
</ol>
<blockquote>
<p>ngx_http_upstream_module用于定义可通过fastcgi传递、proxy传递、uwsgi传递、memcached传递和scgi传递指令来引用的服务器组。</p>
</blockquote>
<ol start="13">
<li>请解释什么是C10K问题?</li>
</ol>
<blockquote>
<p>C10K问题是指无法同时处理大量客户端(10,000)的网络套接字</p>
</blockquote>
<ol start="14">
<li>在Nginx中，请说明Rewrite模块里break和last的区别。</li>
</ol>
<blockquote>
<p>last：停止执行当前这一轮的ngx_http_rewrite_module指令集，包括后续的rewrite 和 return,然后查找匹配改变后URI的新location<br>
break：停止执行当前这一轮的ngx_http_rewrite_module指令集；包括 后续的rewrite和return,继续执行剩余的命令比如echo<br>
temporary 302  return 302 更新url<br>
permant  301 return 301    更新url</p>
</blockquote>
<ol start="15">
<li>为什么不使用多线程？</li>
</ol>
<blockquote>
<p>Apache: 创建多个进程或线程，而每个进程或线程都会为其分配cpu和内存（线程要比进程小的多，所以worker支持比perfork高的并发），并发过大会榨干服务器资源。<br>
Nginx: 采用单线程来异步非阻塞处理请求（管理员可以配置Nginx主进程的工作进程的数量）(epoll)，不会为每个请求分配cpu和内存资源，节省了大量资源，同时也减少了大量的CPU的上下文切换。所以才使得Nginx支持更高的并发。一般进程数设置为cpu核数</p>
</blockquote>
<ol start="16">
<li>Nginx是如何处理一个请求的呢？</li>
</ol>
<blockquote>
<p>首先，nginx在启动时，会解析配置文件，得到需要监听的端口与ip地址，然后在nginx的master进程里面<br>
先初始化好这个监控的socket，再进行listen<br>
然后再fork出多个子进程出来, 子进程会竞争accept新的连接。<br>
此时，客户端就可以向nginx发起连接了。当客户端与nginx进行三次握手，与nginx建立好一个连接后<br>
此时，某一个子进程会accept成功，然后创建nginx对连接的封装，即ngx_connection_t结构体<br>
接着，根据事件调用相应的事件处理模块，如http模块与客户端进行数据的交换。<br>
最后，nginx或客户端来主动关掉连接，到此，一个连接就寿终正寝了</p>
</blockquote>
<ol start="17">
<li>为什么要做动静分离？</li>
</ol>
<blockquote>
<p>在日常开发中，前端请求静态文件比如图片资源是不需要经过后端服务器的，但是调用API这些类型的就需要后端进行处理请求，所以为了提高对资源文件的响应速度，我们应该使用动静分离的策略去做架构。我们可以将静态文件放到Nginx中，将动态资源的请求转发到后端服务器去进行进一步的处理</p>
</blockquote>
<ol start="18">
<li>Session不同步如何处理？</li>
</ol>
<blockquote>
<p>载均衡方式使用ip_hash方式，如果用户已经访问过某个后端器，则再次访问时会将这个请求的ip地址进行哈希算法转换，自动定位到该服务器。当然也可以通过redis缓存用户session，一样可以处理session不同步的问题。</p>
</blockquote>
<ol start="19">
<li>负载均衡算法</li>
</ol>
<blockquote>
<p>轮询,ip hash ,url hash ,fair(返回时间),weight(加权轮询,即按比例平滑排列 abcadca)</p>
</blockquote>
<ol>
<li>LVS（4层与7层）原理</li>
</ol>
<blockquote>
<p>LVS:Linux Virtual Server<br>
使用LVS架设的服务器集群系统有三个部分组成：最前端的负载均衡层（Loader Balancer），中间的服务器群组层，用Server Array表示，最底层的数据共享存储层，用Shared Storage表示</p>
</blockquote>
<ol start="2">
<li>Nginx 双机备份</li>
</ol>
<ul>
<li>主从模式</li>
</ul>
<blockquote>
<p>nginx进程基于Master+Slave(worker)多进程模型，自身具有非常稳定的子进程管理功能。在Master进程分配模式下，Master进程永远不进行业务处理，只是进行任务分发，从而达到Master进程的存活高可靠性，Slave(worker)进程所有的业务信号都 由主进程发出，Slave(worker)进程所有的超时任务都会被Master中止，属于非阻塞式任务模型。<br>
Keepalived是Linux下面实现VRRP备份路由的高可靠性运行件。基于Keepalived设计的服务模式能够真正做到主服务器和备份服务器故障时IP瞬间无缝交接。二者结合，可以构架出比较稳定的软件LB方案<br>
VRRP:Virtual Router Redundancy Protocol虚拟路由冗余协议;将N台提供相同功能的路由器组成一个路由器组(Router Group)，这个组里面有一个master和多个backup，但在外界看来就像一台一样，构成虚拟路由器，拥有一个虚拟IP（vip，也就是路由器所在局域网内其他机器的默认路由），占有这个IP的master实际负责ARP相应和转发IP数据包，组中的其它路由器作为备份的角色处于待命状态。master会发组播消息，当backup在超时时间内收不到vrrp包时就认为master宕掉了，这时就需要根据VRRP的优先级来选举一个backup当master，保证路由器的高可用。</p>
</blockquote>
<ul>
<li>主主模式</li>
</ul>
<blockquote>
<p>即前端使用两台负载均衡服务器，互为主备，且都处于活动状态，同时各自绑定一个公网虚拟IP，提供负载均衡服务；当其中一台发生故障时，另一台接管发生故障服务器的公网虚拟IP（这时由非故障机器一台负担所有的请求）。这种方案，经济实惠，非常适合于当前架构环境。</p>
</blockquote>
<ol start="3">
<li>虚拟主机</li>
</ol>
<blockquote>
<p>虚拟主机是一种特殊的软硬件技术，它可以将网络上的每一台计算机分成多个虚拟主机，每个虚拟主机可以独立对外提供 www 服务，这样就可以实现一台主机对外提供多个 web 服务，每个虚拟主机之间是独立的，互不影响的<br>
虚拟主机可以对应配置文件中的server<br>
虚拟主机具体可以分为基于IP,port,域名(host文件)的配置</p>
</blockquote>
<ol start="4">
<li>命令</li>
</ol>
<ul>
<li>server :</li>
<li>listen</li>
<li>location : 匹配 url</li>
<li>root 虚拟主机目录</li>
<li>index 首页</li>
<li>server_name</li>
<li>upstream ：负载均衡</li>
<li>keepalive_timeout</li>
<li>work_process</li>
<li>work_connection</li>
<li>sendfile on</li>
<li>proxy 命令</li>
</ul>
<ol start="5">
<li>Nginx 优化</li>
</ol>
<blockquote>
<p>利用 location expire 缓存静态文件<br>
keepalive_imeout<br>
调整worker_processes指定Nginx需要创建的worker进程数量，刚才有提到worker进程数一般设置为和CPU核心数一致。<br>
调整worker_connections设置Nginx最多可以同时服务的客户端数。结合worker_processes配置可以获得每秒可以服务的最大客户端数。<br>
启动gzip压缩，可以对文件大小进行压缩，减少了客户端http的传输带宽，可以大幅度提高页面的加载速度。<br>
启用缓存，如果请求静态资源，启用缓存是可以大幅度提升性能的。</p>
</blockquote>
<ol start="6">
<li></li>
<li>Linux 命令</li>
</ol>
<blockquote>
<p>crontab</p>
</blockquote>
<p>LVS VS NGINX<br>
<a href="https://www.cnblogs.com/zhoading/p/11037708.html" target="_blank" rel="noopener">浅谈 Nginx和LVS的各种优缺点</a></p>
<p>Nginx 实现热部署</p>
<blockquote>
<p>当通知 ngnix 重读配置文件的时候，master 进程会进行语法错误的判断。如果存在语法错误的话，返回错误，不进行装载；如果配置文件没有语法错误，那么 ngnix 也不会将新的配置调整到所有 worker 中。而是，先不改变已经建立连接的 worker，等待 worker 将所有请求结束之后，将原先在旧的配置下启动的 worker 杀死，然后使用新的配置创建新的 worker<br>
修改配置文件nginx.conf后，重新生成新的worker进程，当然会以新的配置进行处理请求，而且新的请求必须都交给新的worker进程，至于老的worker进程，等把那些以前的请求处理完毕后，kill掉即可</p>
</blockquote>
<p>301 VS 302</p>
<blockquote>
<p>重定向指将网络请求重新确定方向到新的位置<br>
场景</p>
</blockquote>
<ul>
<li>网站调整(页面调整)或者页面变化,避免旧用户返回404;临时则用302,永久则用301(在开发里发现浏览器会记住301重定向)</li>
</ul>
<blockquote>
<p>301 永久重定向 302 临时重定向(可以返回原来的地址)</p>
</blockquote>
<h3 id="pid-file">pid file</h3>
<p>每个后台程序都会在/var/run目录下产生一个<name>.pid file 里面存储了程序pid的file<br>
nginx.pid 中存储了master进程的file</name></p>
<h3 id="文件锁">文件锁</h3>
<p>nginx进程之间的通信机制包括 信号 信号量 文件锁<br>
信号：SIGHUP<br>
信号量：用来保证两个或多个代码段不被并发访问，是一种保证共享资源有序访问的工具<br>
文件锁：<br>
互斥锁</p>
<h2 id="源码解析">源码解析</h2>
<h3 id="配置文件解析">配置文件解析</h3>
<p>配置块(’}‘结尾)和配置项(’;'结尾)</p>
<p>分词之后,使用key-value对的方式解析存储配置项,而非语法分析的方式构建语法树<br>
http配置文件为有3个组成部分;不同级别对应的配置项范围向下延伸</p>
<ul>
<li>void **main_conf:可包含多个server字段</li>
<li>void **server_conf:包含多个loc字段</li>
<li>void **loc_conf:loc字段可嵌套,最终合并为一层</li>
</ul>
<p>在解析到http模块时,会调用create_main_conf create_srv_conf  create_loc_conf 方法创建3组结构体,已在各模块存储其感兴趣的main级别配置项;同样解析server模块会调用create_srv_conf  create_loc_conf 相应结构体,存储server级别配置项</p>
<h4 id="其他">其他</h4>
<p>include 指令</p>
<blockquote>
<p>可以降低多个server字段的耦合程度,涉及递归调用parse函数</p>
</blockquote>
<p>location 嵌套</p>
<blockquote>
<p>server模块下可能有多个location块,而location块下可以嵌套存储location<br>
loc结构体下有队列成员变量存储其他嵌套队列</p>
</blockquote>
<p>上下文继承</p>
<h3 id="event模块">event模块</h3>
<h3 id="mail-模块">mail 模块</h3>
<h3 id="http-模块">http 模块</h3>
<h4 id="数据存储结构">数据存储结构</h4>
<p>在nginx运行过程中，有一个全局配置结构体ngx_cycle_t，其有一个属性conf_ctx，这个属性是存储nginx所有模块配置的一个数组，这个数组的长度与nginx模块的个数相同。不过需要注意的是，conf_ctx数组的第一维只会存储核心模块的配置，而其他模块对应的位置处的数组元素其实是为NULL。在conf_ctx中，各个核心模块配置结构体的存储位置与该模块在所有模块（包括非核心模块）中的相对位置是一致的，如下图所示为nginx存储核心模块的一个结构示意图<br>
全局配置结构体ngx_cycle_t 下有 conf_ctx记录配置文件的信息<br>
ngx_cycle_t-&gt;conf_ctx</p>
<ul>
<li>void **main_conf;   // http</li>
<li>void **srv_conf;   // server</li>
<li>void **loc_conf;   //location</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/04/工作求职/MyBatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/04/工作求职/MyBatis/" class="post-title-link" itemprop="url">MyBatis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-04 00:03:39" itemprop="dateCreated datePublished" datetime="2020-09-04T00:03:39+08:00">2020-09-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-15 10:57:27" itemprop="dateModified" datetime="2021-01-15T10:57:27+08:00">2021-01-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>MyBatis 是 一个常用的 Java 持久层框架</p>
<h2 id="什么是-mybatis">什么是 MyBatis</h2>
<p><a href="https://mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">MyBatis 官网</a><br>
MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<p>相对于 Spring Data JPA 差不多可以不用写 SQL 的框架而言，MyBatis 在于开发者可以灵活的编写 SQL<br>
MyBatis 可以通过使用注解来减少相关的配置文件</p>
<h4 id="注解方式的-mapper-接口">注解方式的 Mapper 接口</h4>
<p>@Insert，@Select，@Update, @Delete 分别注解 SQL 的 insert，select，update，delete 语句。<br>
@Options<br>
@Results：实现结果的映射<br>
PageHelper.startPage(page, size); 调用此方法后，随后的查询讲自动使用分页模式。<br>
PageInfo.of(sysUserMapper.selectAllOnXml())； 讲查询返回某一页的信息使用 PageInfo 打包</p>
<ol>
<li>什么是Mybatis？</li>
</ol>
<blockquote>
<p>Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高。<br>
MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。<br>
通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和 statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。（从执行sql到返回result的过程）。</p>
</blockquote>
<ul>
<li>是什么?基于JDBC,实现对于数据库的增删改查操作架构</li>
<li>自动管理数据库连接的创建和释放,操作者只需要写sql</li>
<li>利用配置文件或者mapper 定义 对象 映射 数据库的记录和返回结果;</li>
<li>解耦sql与应用程序,统一管理和复用;通过动态sql降低 拼接sql的难度</li>
</ul>
<ol start="2">
<li>Mybaits的优点：</li>
</ol>
<blockquote>
<p>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。<br>
与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；<br>
很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。<br>
能够与Spring很好的集成</p>
</blockquote>
<ol start="3">
<li>MyBatis框架的缺点</li>
</ol>
<blockquote>
<p>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。- 利用自动化生成工具<br>
SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p>
</blockquote>
<ol start="4">
<li>MyBatis框架适用场合</li>
</ol>
<blockquote>
<p>MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案<br>
对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。</p>
</blockquote>
<ol start="5">
<li>#{}和${}的区别是什么？</li>
</ol>
<blockquote>
<p>#{}是预编译处理，${}是字符串替换。<br>
Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值(在处理是会对输入做转义处理)<br>
Mybatis在处理${}时，就是把${}替换成变量的值。<br>
使用#{}可以有效的防止SQL注入，提高系统安全性。</p>
</blockquote>
<ol start="6">
<li>Mybatis是如何进行分页的？分页插件的原理是什么？</li>
</ol>
<blockquote>
<p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。<br>
分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p>
</blockquote>
<ol start="7">
<li>Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</li>
</ol>
<blockquote>
<p>resultMap</p>
</blockquote>
<ol start="8">
<li>如何获取自动生成的(主)键值?</li>
</ol>
<blockquote>
<p>insert 方法总是返回一个int值 ，这个值代表的是插入的行数。</p>
</blockquote>
<ol start="9">
<li>Mybatis动态sql有什么用？执行原理？有哪些动态sql？</li>
</ol>
<blockquote>
<p>Mybatis动态sql可以在Xml映射文件内，以标签的形式编写动态sql，执行原理是根据表达式的值 完成逻辑判断并动态拼接sql的功能。<br>
Mybatis提供了9种动态sql标签：trim | where | set | foreach | if | choose | when | otherwise | bind。</p>
</blockquote>
<ol start="10">
<li>复杂查询</li>
</ol>
<blockquote>
<p>基于examople 配合条件查询</p>
</blockquote>
<ol start="11">
<li>Dao接口的工作原理是什么?</li>
</ol>
<blockquote>
<p>Mapper 接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Mapper接口生成代理对象proxy，代理对象会拦截接口方法，转而执行MapperStatement所代表的sql，然后将sql执行结果返回</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/03/工作求职/源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/03/工作求职/源码解析/" class="post-title-link" itemprop="url">源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-03 13:06:17" itemprop="dateCreated datePublished" datetime="2020-09-03T13:06:17+08:00">2020-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-15 10:57:45" itemprop="dateModified" datetime="2021-01-15T10:57:45+08:00">2021-01-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="override-的-jvm-实现">Override 的 JVM 实现</h4>
<blockquote>
<p>背景：在代码中子类Son继承父类Father,并使用Override注解 对于父类方法Test的重写<br>
<img src="/images/Override-test-java.png" alt="test1.java test2.java"><br>
JVM 加载子类Son.class,递归的向上加载父类的class 文件即Father.class :class文件保存为表示类型信息的结构体中,只包含本类特有的，或者是重写的方法信息，没有父类的方法信息。<br>
<img src="/images/Override-testclass.png" alt="class文件在方法区的结构"><br>
JVM会根据class 文件信息生成 方法表(是实现多态的关键),方法表中保存该类的所有的包括继承的方法(不包含私有方法),以及指向实例方法的指针<br>
<img src="/images/Override-method-table.png" alt="方法表"><br>
其中子类Son的Test方法指针指向Son.class在中的实例方法(这里需要注意的一点是，当Child类的方法表产生指向Parent类中的方法的引用时，会有一个指向eat方法的引用，最后产生指向本类的方法的引用时，也有一个指向eat的引用，这时候，新的数据会覆盖原有的数据，也就是说原来指向Parent.eat的那个引用会被替换成指向Child.eat的引用(占据原来表中的位置)<br>
堆中存储类的方法表索引以及字段变量<br>
当执行test方法时,虽然类型是Father,实际执行的是Son的方法表中指向的Son重写的方法</p>
</blockquote>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/wonderful_life_mrchi/article/details/78048698" target="_blank" rel="noopener">jvm视角看java继承和多态</a></li>
<li><a href="https://blog.csdn.net/u011069294/article/details/107415210" target="_blank" rel="noopener">JVM方法区的内部结构</a></li>
<li><a href="https://www.iteye.com/blog/hxraid-676235" target="_blank" rel="noopener">Java 虚拟机体系结构</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/24317613" target="_blank" rel="noopener">Java动态绑定机制的内幕</a></li>
<li><a href="https://blog.csdn.net/fan2012huan/article/details/51007517" target="_blank" rel="noopener">java方法调用之动态调用多态（重写override）的实现原理——方法表（三）</a></li>
</ul>
<h4 id="synchronize-vs-lock">synchronize VS lock</h4>
<p><a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html" target="_blank" rel="noopener">Chapter 17. Threads and Locks</a><br>
<a href="https://www.cnblogs.com/tiancai/p/9371655.html" target="_blank" rel="noopener">java的锁池和等待池</a><br>
<a href="https://segmentfault.com/a/1190000017134827" target="_blank" rel="noopener">synchronize - 线程同步机制</a><br>
synchronize支持同步的机制是monitor(monitorEnter monitorExit),支持两种同步机制 互斥和协作<br>
每个对象维持两个队列 waitSet 和 EntrySet<br>
waitSet :</p>
<ul>
<li>操作方法:wait(释放锁,进入队列) 和 notify LockSupport.pack/unpack</li>
<li>需要注意的是notify方法,notify锁唤醒的线程会竞争锁,当该线程竞争成功之后才会将值从wait队列中除去(避免不必要的队列操作,如果要移动到entrySet,那么notifyAll会涉及大量的操作,浪费时间)<br>
EntrySet：所有想获取锁但未获得的线程</li>
<li>当线程synchronize获取锁失败后进入entrySet 而 当获得锁的进程放弃锁之后,从该队列中唤醒一个线程</li>
</ul>
<h4 id="cyclicbarrier-vs-countdownlatch-vs-semaphore">CyclicBarrier  VS CountDownLatch VS Semaphore</h4>
<p>CountDownLatch利用state记录次数,用于同步多个runnable任务执行完之后执行主线程其余操作</p>
<ul>
<li>await: 重写tryAcquireShared 方法:如果state为0则获取成功可以运行,否则调用doAcquireSharedInterruptibly阻塞该线程;(可用于主线程阻塞自己,等待其他线程完成操作)</li>
<li>countDown: 重写 releaseShared(1) 降低state值,将为0时执行doReleaseShared唤醒所有休眠线程,否则仅降低state值</li>
</ul>
<p>Semaphore 限制state数量的线程可以进入Semaphore.acquire() 和 realease() 修饰的代码</p>
<ul>
<li>auquire():重写tryAcquireShared 方法,当state数量小于等于0时,调用doAcquireShared阻塞线程,否则成功返回</li>
<li>release():重写tryReleaseShared 方法,for循环 中CAS操作增加state 成功则跳出循环</li>
</ul>
<p>CyclicBarrier:可循环栅栏(可以用于多次同步动作,比如聚餐的两个同步点,所有到达餐厅开始吃饭,所有人吃完开始离开)<br>
CyclicBarrier内部维持了ReenterLock对象 在基于此生成condition对象,此外包含内部类Generation,每次循环使用新的generation,Runnable变量barrierCommand即线程的队形,count同步计数变量</p>
<ul>
<li>await:利用lock.lock/unlock 维持降低count值,当降低到0 调用nextGenation/BrokenBarrier 方法唤醒休眠线程,重初始化,继续执行,否则阻塞之</li>
<li>reset:重置barrier为初始状态,那些仍等待barrier的线程会返回一个BrokenBarrierException</li>
</ul>
<h4 id="synchronize-和-aqs">synchronize 和 AQS</h4>
<ul>
<li>后者需要显示的获得和释放锁</li>
<li>前者有系统支持,后者是软件层级的锁,前者的锁进入的队列是entry队列,后者是wait队列</li>
<li>前者是悲观锁,后者基于CAS乐观锁</li>
<li>前者的锁等待,不能感知中断/不支持显示处理, 后者 可以通过设置允许中断的标志位 来允许其他线程中断自己 并加以处理</li>
</ul>
<p>AQS的实现类 sync 可以调用lockInterruptly() 会在获得锁失败后,调用LockSupport.park(),从阻塞中被唤醒(被调用LockSupport.unpark())之后,会判断是否是被中断而唤醒的,如果是那么抛出interruptExcetion ,线程可以针对的处理 避免死锁,<br>
当其他线程调用Thread.intrerrupt() 时,会设置终终中断的标志位,线程<br>
object.wait() 方法会检测到 检测中断</p>
<p>stop()方法停止线程非常的暴力，人家线程运行的好好的，突然就把人家杀死了，线程占用的锁被强制释放，极易导致数据的不一致.</p>
<h4 id="abstractqueuedsynchronizer">AbstractQueuedSynchronizer</h4>
<p>private transient volatile Node head;<br>
private transient volatile Node tail;<br>
//在独占式里,标识占据lock的线程,从0到1 的变化通过CAS操作完成,大于1时标识多次重入,直接setState完成<br>
private volatile int state;</p>
<p>lock.lock() 获得锁的运行(更新state为1),没有获得锁的进入双向队列<br>
condition.await() 获得锁的线程可以运行该函数,新建Node添加进condition等待单向队列;更新state,并唤醒lock的队列首的后续节点,并调用LockSupport.pack()阻塞自己<br>
condition.signal()  获取锁的线程,唤醒一个从condition阻塞队列的节点,将之移动到sync同步等待队列,</p>
<p>lock.unlock() 放弃锁,更新state 唤醒等待队列首,阻塞自己</p>
<h5 id="class-node">class Node</h5>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Node nextWaiter;</span><br><span class="line">volatile Thread thread;</span><br><span class="line">volatile Node next;</span><br><span class="line">volatile Node prev;</span><br><span class="line">volatile int waitStatus;</span><br><span class="line">static final Node SHARED = new Node();</span><br><span class="line">/** Marker to indicate a node is waiting in exclusive mode */</span><br><span class="line">static final Node EXCLUSIVE = null;</span><br><span class="line"></span><br><span class="line">/** waitStatus value to indicate thread has cancelled */</span><br><span class="line">static final int CANCELLED =  1;</span><br><span class="line">/** waitStatus value to indicate successor&apos;s thread needs unparking */</span><br><span class="line">static final int SIGNAL    = -1;</span><br><span class="line">/** waitStatus value to indicate thread is waiting on condition */</span><br><span class="line">static final int CONDITION = -2;</span><br><span class="line">/**</span><br><span class="line">* waitStatus value to indicate the next acquireShared should</span><br><span class="line">* unconditionally propagate</span><br><span class="line">*/</span><br><span class="line">static final int PROPAGATE = -3;</span><br></pre></td></tr></table></figure>
<h6 id="节点状态">节点状态</h6>
<ul>
<li>CANCELLED:值为1，由于超时或中断，该节点被取消。 节点进入该状态将不再变化。特别是具有取消节点的线程永远不会再次阻塞</li>
<li>INITIAL:值为0，初始状态,非四种状态</li>
<li>SIGNAL:值为-1，后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，那么就会通知后继节点，让后继节点的线程能够运行</li>
<li>CONDITION:值为-2，Condition的等待队列,不过当其他的线程对Condition调用了signal()方法后，该节点就会从等待队列转移到同步队列(sync)中，然后开始尝试对同步状态的获取</li>
<li>PROPAGATE:值为-3，只对head节点设置,表示下一次的releaseShared状态获取将会无条件的被传播下去</li>
</ul>
<h5 id="conditionsignal">condition.signal</h5>
<p>首先判断是否是持有锁者在调用释放<br>
获取锁的线程,唤醒一个从condition阻塞队列的节点,将之移动到sync同步等待队列</p>
<h5 id="doacquireshared-获取锁">doAcquireShared 获取锁</h5>
<p><a href="https://juejin.im/post/6844903997438951437" target="_blank" rel="noopener">参考0</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Acquires in shared uninterruptible mode.</span><br><span class="line">* @param arg the acquire argument</span><br><span class="line">*/</span><br><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">    //将该线程添加到阻塞队列的队尾,涉及CAS设置tail,并返回tail</span><br><span class="line">    final Node node = addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            //head 标识 当前阻塞队列中获取锁的线程,那么之后其后继者才有可能获得锁</span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                if (r &gt;= 0) &#123;</span><br><span class="line">                    //设置当前node为head而且沿着阻塞队列向后传播</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    if (interrupted)</span><br><span class="line">                        selfInterrupt();//??中断后执行finally然后在阻塞队列中删除该节点??</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //判断线程是否应该阻塞,以及调用LockSupport.park(this) 将线程阻塞并返回是否成功</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)//取消对于读锁的获取,在阻塞队列里删除该节点</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="addwaiter">addWaiter</h5>
<h4 id="reentrantlockreadwritelock">ReentrantLockReadWriteLock</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//state&gt;&gt;16 获得读锁的线程数;state&amp;(1&lt;&lt;16) 写锁的重入次数</span><br><span class="line">final volatile int state;</span><br><span class="line"></span><br><span class="line">private static final long serialVersionUID = -6992448646407690164L;</span><br><span class="line">//读锁</span><br><span class="line">private final ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">//写锁</span><br><span class="line">private final ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line">//同步机制的操作对象</span><br><span class="line">final Sync sync;</span><br><span class="line">//transient 标识序列化时不序列化该元素;firstReader标识获取读锁的第一个线程(最近把读锁计数从0变为1的线程),而firstReaderHoldCount标识该线程持有的锁的数量</span><br><span class="line">private transient Thread firstReader = null;</span><br><span class="line">private transient int firstReaderHoldCount;</span><br><span class="line"></span><br><span class="line">//标识当前线程所持有的读锁的数目(THreadLocal变量)</span><br><span class="line">private transient ThreadLocalHoldCounter readHolds;</span><br><span class="line">//标识最后获得读锁的线程持有的读锁数</span><br><span class="line">private transient HoldCounter cachedHoldCounter;</span><br></pre></td></tr></table></figure>
<p>获取锁的过程</p>
<ul>
<li>lock()</li>
<li>acquireShared(1) ;tryAcquireShared(1)失败后,说明有写锁, -&gt; fullTryAcquireShared(在没有写锁的前提下,死锁循环获取读锁)</li>
<li>fullTryAcquireShared 失败后(失败意味着在获取读锁的期间有线程获得读锁或者读锁数量超过限制,否则继续死循环) doAcquireShared(1)</li>
</ul>
<p>释放锁的过程</p>
<ul>
<li>unlock()</li>
<li>sync.releaseShared(1)</li>
<li>tryReleaseShared 成功后 doReleaseShared</li>
</ul>
<h5 id="tryacquireshared">tryAcquireShared</h5>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//获取共享锁</span><br><span class="line">protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line">    /*</span><br><span class="line">        * Walkthrough:</span><br><span class="line">        * 1. If write lock held by another thread, fail.</span><br><span class="line">        * 2. Otherwise, this thread is eligible for</span><br><span class="line">        *    lock wrt state, so ask if it should block</span><br><span class="line">        *    because of queue policy. If not, try</span><br><span class="line">        *    to grant by CASing state and updating count.</span><br><span class="line">        *    Note that step does not check for reentrant</span><br><span class="line">        *    acquires, which is postponed to full version</span><br><span class="line">        *    to avoid having to check hold count in</span><br><span class="line">        *    the more typical non-reentrant case.</span><br><span class="line">        * 3. If step 2 fails either because thread</span><br><span class="line">        *    apparently not eligible or CAS fails or count</span><br><span class="line">        *    saturated, chain to version with full retry loop.</span><br><span class="line">        */</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    //如果已经有进程占有写锁,且不是当前进程,那么不可获得读锁(获得写锁的进程也能获得读锁)</span><br><span class="line">    if (exclusiveCount(c) != 0 &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        return -1;</span><br><span class="line">    //获得读锁的线程数</span><br><span class="line">    int r = sharedCount(c);</span><br><span class="line">    //如果不应该阻塞(阻塞队列为空或者队首是自己) 且 当前获得锁的线程数量小于最大值  且 CAS 操作成功 ,那么执行</span><br><span class="line">    if (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        //如果这是第一获得读锁的进程 赋值firstReader 和 firstReaderHoldCount</span><br><span class="line">        if (r == 0) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = 1;</span><br><span class="line">        &#125; else if (firstReader == current) &#123;//或者第一个获得读锁的人是自己,那么增加计数即可</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //如果最后一个线程计数器是null或不是自己那么新建 HoldCounter,否则 不是null并且是自己此时如果count为0,则</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            if (rh == null || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            else if (rh.count == 0)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="fulltryacquireshared"><a href="https://ifeve.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-%E8%AF%BB%E9%94%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%A7%A3%E9%87%8A%E5%85%B3%E4%BA%8E%E9%94%81%E9%99%8D%E7%BA%A7%E7%9A%84%E4%BA%89/" target="_blank" rel="noopener">fullTryAcquireShared</a></h5>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">//死循环获取读锁。包含锁降级策略</span><br><span class="line">final int fullTryAcquireShared(Thread current) &#123;</span><br><span class="line">    /*</span><br><span class="line">        * This code is in part redundant with that in</span><br><span class="line">        * tryAcquireShared but is simpler overall by not</span><br><span class="line">        * complicating tryAcquireShared with interactions between</span><br><span class="line">        * retries and lazily reading hold counts.</span><br><span class="line">        */</span><br><span class="line">    HoldCounter rh = null;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = getState();</span><br><span class="line">        //获取读锁之前,确保没有写锁,首先这是读写锁的目标 同时避免获取写锁的线程  之后获取读锁 从而陷入死锁</span><br><span class="line">        if (exclusiveCount(c) != 0) &#123;</span><br><span class="line">            if (getExclusiveOwnerThread() != current)</span><br><span class="line">                return -1;</span><br><span class="line">            // else we hold the exclusive lock; blocking here</span><br><span class="line">            // would cause deadlock.</span><br><span class="line">            //readerShouldBlock 判断 阻塞队列是否有线程,或者阻塞队列首是否是自己,如果是则返回false,不应该阻塞,不要重复获取读锁,写锁的持有线程可以获得读锁</span><br><span class="line">        &#125; else if (readerShouldBlock()) &#123;</span><br><span class="line">            // Make sure we&apos;re not acquiring read lock reentrantly</span><br><span class="line">            if (firstReader == current) &#123;</span><br><span class="line">                // assert firstReaderHoldCount &gt; 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (rh == null) &#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    if (rh == null || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        if (rh.count == 0)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (rh.count == 0)</span><br><span class="line">                    return -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果读锁的数量达到限制,报错</span><br><span class="line">        if (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        if (compareAndSetState(c, c + SHARED_UNIT)) &#123;//尝试获得锁</span><br><span class="line">            //获得成功,如果是第一个获得读锁的线程,更新相关值</span><br><span class="line">            if (sharedCount(c) == 0) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = 1;</span><br><span class="line">            &#125; else if (firstReader == current) &#123;//如果是第一个读者,更新相关值</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (rh == null)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                //如果rh为空或者rh不为当前线程,那么新建 HoldCounter</span><br><span class="line">                if (rh == null || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                else if (rh.count == 0) //否则即rh为当前线程,且count为0,则更新</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh; // cache for release</span><br><span class="line">            &#125;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">    * Performs tryLock for write, enabling barging in both modes.</span><br><span class="line">    * This is identical in effect to tryAcquire except for lack</span><br><span class="line">    * of calls to writerShouldBlock.</span><br><span class="line">    */</span><br></pre></td></tr></table></figure>
<h5 id="shouldparkafterfailedacquire">shouldParkAfterFailedAcquire</h5>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//如果线程获取读锁失败,那么是否阻塞之,并且修改其在队列中的状态</span><br><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    int ws = pred.waitStatus;</span><br><span class="line">    //如果前继节点的状态是SIGNAL那么可以阻塞该线程</span><br><span class="line">    if (ws == Node.SIGNAL)</span><br><span class="line">        /*</span><br><span class="line">            * This node has already set status asking a release</span><br><span class="line">            * to signal it, so it can safely park.</span><br><span class="line">            */</span><br><span class="line">        return true;</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        //前继节点处于CANCEL的状态,所以锁的最新情况不能通过前继节点传递给他,所以需要删除这样的节点.</span><br><span class="line">        /*</span><br><span class="line">            * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">            * indicate retry.</span><br><span class="line">            */</span><br><span class="line">        do &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //前继节点处于CONDITION 或者 PROPAGATE 状态,那么 修改状态为 SINGAL</span><br><span class="line">        /*</span><br><span class="line">            * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">            * need a signal, but don&apos;t park yet.  Caller will need to</span><br><span class="line">            * retry to make sure it cannot acquire before parking.</span><br><span class="line">            */</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="shouldparkafterfailedacquire">shouldParkAfterFailedAcquire</h5>
<p>判断已获取读锁失败的线程是否应该阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    int ws = pred.waitStatus;</span><br><span class="line">    if (ws == Node.SIGNAL)</span><br><span class="line">        /*</span><br><span class="line">            * This node has already set status asking a release</span><br><span class="line">            * to signal it, so it can safely park.</span><br><span class="line">            */</span><br><span class="line">        return true;</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        /*</span><br><span class="line">            * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">            * indicate retry.</span><br><span class="line">            */</span><br><span class="line">        do &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /*</span><br><span class="line">            * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">            * need a signal, but don&apos;t park yet.  Caller will need to</span><br><span class="line">            * retry to make sure it cannot acquire before parking.</span><br><span class="line">            */</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="tryreleaseshared">tryReleaseShared</h5>
<p>释放该线程的读锁,count-1</p>
<ol>
<li>是否是firstReader
<ul>
<li>是否 count = 1</li>
</ul>
</li>
<li>是否是最后一个Reader</li>
<li>死循环CAS更新所有读锁的count,成功后退出</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryReleaseShared(int unused) &#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    if (firstReader == current) &#123;</span><br><span class="line">        // assert firstReaderHoldCount &gt; 0;</span><br><span class="line">        if (firstReaderHoldCount == 1)</span><br><span class="line">            firstReader = null;</span><br><span class="line">        else</span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        if (rh == null || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        int count = rh.count;</span><br><span class="line">        if (count &lt;= 1) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            if (count &lt;= 0)</span><br><span class="line">                throw unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = getState();</span><br><span class="line">        int nextc = c - SHARED_UNIT;</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            // Releasing the read lock has no effect on readers,</span><br><span class="line">            // but it may allow waiting writers to proceed if</span><br><span class="line">            // both read and write locks are now free.</span><br><span class="line">            return nextc == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="doreleaseshared">doReleaseShared</h5>
<p>该节点释放锁之后,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    /*</span><br><span class="line">        * Ensure that a release propagates, even if there are other</span><br><span class="line">        * in-progress acquires/releases.  This proceeds in the usual</span><br><span class="line">        * way of trying to unparkSuccessor of head if it needs</span><br><span class="line">        * signal. But if it does not, status is set to PROPAGATE to</span><br><span class="line">        * ensure that upon release, propagation continues.</span><br><span class="line">        * Additionally, we must loop in case a new node is added</span><br><span class="line">        * while we are doing this. Also, unlike other uses of</span><br><span class="line">        * unparkSuccessor, we need to know if CAS to reset status</span><br><span class="line">        * fails, if so rechecking.</span><br><span class="line">        */</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">            int ws = h.waitStatus;</span><br><span class="line">            if (ws == Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            // loop to recheck cases</span><br><span class="line">                //如果更新成功,解锁后继节点</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws == 0 &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                // loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        if (h == head)                   // loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="threadlocal">ThreadLocal</h4>
<p>通过继承ThreadLocal 重写 initialValue,获得默认值<br>
Thread 类中包含ThreadLocalMap  和 InheritThreadLocalMap<br>
ThreadLocalMap 是一个 Entry数组,一个 Entry 定义时包含对于ThreadLocal的弱引用,利用Object(value)存储保存的值</p>
<h5 id="get">get</h5>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//多线程共享进程的变量threadLocal,以该变量为key值去获取线程私有变量中的相关值,不涉及对于全局变量的修改,不会线程不安全,利用这种方法可以实现多变量的线程间共享,而且不必要放入参数中传进去</span><br><span class="line">public T get() &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        if (map != null) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">            if (e != null) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="sleep">sleep</h4>
<p><a href="https://www.jianshu.com/p/0964124ae822" target="_blank" rel="noopener">Java线程源码解析之yield和sleep</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/02/工作求职/多线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/02/工作求职/多线程/" class="post-title-link" itemprop="url">多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-02 00:09:39" itemprop="dateCreated datePublished" datetime="2020-09-02T00:09:39+08:00">2020-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-15 11:00:25" itemprop="dateModified" datetime="2021-01-15T11:00:25+08:00">2021-01-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://redspider.gitbook.io/concurrent/" target="_blank" rel="noopener">《深入浅出多线程》 阅读笔记</a><br>
创建线程</p>
<ul>
<li>继承 Thread 类,重写run方法</li>
<li>继承 Runnable接口,实现run方法</li>
</ul>
<blockquote>
<p>上面的两种方法run方法没有返回值</p>
</blockquote>
<ul>
<li>重写callable 和future 接口,继承 futureTask类(继承了runable 和 future 接口)
<ul>
<li>使用futureTask 需事先 call 接口</li>
</ul>
</li>
<li>使用Excutor创建线程池</li>
</ul>
<p>线程的状态</p>
<blockquote>
<p>创建 就绪 运行 阻塞 终止</p>
</blockquote>
<p>守护线程</p>
<blockquote>
<p>当没有任何用户线程,只有守护线程时,JVM虚拟机才可以正常退出;<br>
守护线程被强制终止,不会产生永久性的严重后果<br>
守护线程做一些系统级的事情,比如垃圾回收等,需要注意的是可以设置用户线程为守护线程,但是注意 该线程不要涉及 io磁盘网络操作,否则被终止可能达不到效果</p>
</blockquote>
<h2 id="基础篇">基础篇</h2>
<h3 id="java线程间的通信">Java线程间的通信</h3>
<h4 id="锁与同步">锁与同步</h4>
<blockquote>
<p>java中锁的概念都是基于对象,又称之为对象锁,为了实现同步(使线程按照一定的顺序执行)</p>
</blockquote>
<h4 id="等待通知机制">等待/通知机制</h4>
<blockquote>
<p>不断的尝试 获得锁,会消耗计算资源 ,等待/通知机制 是另一种机制,是对于同一个对象锁的wait和notify,其是基于Object类的wait()方法和notify(),notifyAll()方法实现(notify()会随机叫醒一个等待的线程,而notifyAll()会叫醒所有等待的线程)</p>
</blockquote>
<h4 id="信号量">信号量</h4>
<blockquote>
<p>JDK提供了一个类似于“信号量”功能的类Semaphore,可以控制进入 关键区的线程数目<br>
volatile 关键字能够保证内存的可见性，如果用volitile关键字声明了一个变量，在一个线程里面改变了这个变量的值，那其它线程是立马可见更改后的值的</p>
</blockquote>
<h4 id="管道">管道</h4>
<blockquote>
<p>管道是基于&quot;管道流&quot;的通信方式.JDK提供了PipedReader,PipedWriter,PipedInputStream,PipedOutputStream;前者的两个是基于字符的,后面的两者 基于字节流.<br>
应用场景:使用管道多半与I/O流相关。当我们一个线程需要先另一个线程发送一个信息（比如字符串）或者文件等时，就需要使用管道通信了</p>
</blockquote>
<h4 id="其他通信相关">其他通信相关</h4>
<h5 id="join方法">join方法</h5>
<blockquote>
<p>thread.join()方法是Thread类的一个实例方法,他的作用是使调用thread.join()的方法改程陷入&quot;等待状态&quot;(调用wait(0)实现),等join 所属的这个线程执行完,会notify_all();<a href="https://juejin.im/post/6844903997472505864" target="_blank" rel="noopener">join 详细流程</a></p>
</blockquote>
<h5 id="sleep方法">sleep方法</h5>
<blockquote>
<p>sleep 方法是Thread类的一个静态方法,其作用是使当前线程睡眠一段时间<br>
sleep VS wait</p>
<ul>
<li>wait释放cpu资源，同时释放锁；sleep释放cpu资源，但是不释放锁，所以易死锁。</li>
<li>wait可以不指定时间,sleep 必须指定时间</li>
<li>wait必须放在同步块或同步方法中 将同步块涉及的对象锁释放(否则可能导致Lost wake-up problem即正常的顺序应该是a等b完成,不加synchronize可能出现 线程a经过判,即将wait,此时线程b执行了notify,但是a没有沉睡,所以无效,之后睡眠无人唤醒)，而sleep可以再任意位置</li>
</ul>
</blockquote>
<h5 id="threadlocal类">ThreadLocal类</h5>
<blockquote>
<p>ThreadLocal是一个本地线程副本变量工具类,配合线程的ThreadLocalMap类使用<br>
ThreadLocal类并不属于多线程间的通信,而是让每个线程有自己”独立“的变量，线程之间互不影响。它为每个线程都创建一个副本，每个线程可以访问自己内部的副本变量<a href="https://www.zhihu.com/question/341005993/answer/791673856" target="_blank" rel="noopener">ThreadLocal详解</a><br>
最常见的ThreadLocal使用场景为用来解决数据库连接、Session管理等<br>
todo</p>
</blockquote>
<h5 id="inheritablethreadlocal">InheritableThreadLocal</h5>
<blockquote>
<p>它不仅仅是当前线程可以存取副本值,而且它的子线程也可以存取这个副本值<br>
todo</p>
</blockquote>
<h2 id="原理篇">原理篇</h2>
<h4 id="java内存模型基础知识">Java内存模型基础知识</h4>
<h5 id="并发编程模型的两个关键问题">并发编程模型的两个关键问题</h5>
<ul>
<li>线程如何通信(以何种机制交换信息)：</li>
<li>如何同步(如何控制不同线程之间的相对执行顺序)：</li>
</ul>
<p>有两个并发模型可以解决这两个问题</p>
<ul>
<li>消息传递并发模型
<ul>
<li>线程之间没有公共状态,线程之间的通信必须通过发送消息来显示的通信</li>
<li>消息传递天然同步,必然是会先发送消息,然后接收消息,是隐式同步</li>
</ul>
</li>
<li>共享内存并发模型
<ul>
<li>线程之间有公共内存,可以通过读写公共内存中状态来实现隐式通信</li>
<li>必须 显示的指定某段代码需要线程之间互斥执行来显示同步</li>
</ul>
</li>
</ul>
<p>Java中使用的是共享内存并发模型</p>
<h4 id="java内存模型的抽象结构">Java内存模型的抽象结构</h4>
<h5 id="运行时内存的划分">运行时内存的划分</h5>
<p>栈(虚拟机栈,本地方法栈) 堆 方法区 PC<br>
其中栈是私有的,堆是共享的</p>
<h5 id="既然堆是共享的为什么在堆中会有内存不可见问题">既然堆是共享的，为什么在堆中会有内存不可见问题?</h5>
<blockquote>
<p>线程之间的共享变量存在主内存中，每个线程都有一个私有的本地内存，存储了该线程以读、写共享变量的副本。本地内存是Java内存模型的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器等。<br>
JMM通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性保证。</p>
</blockquote>
<h5 id="jmm与java内存区域划分的区别与联系">JMM与Java内存区域划分的区别与联系</h5>
<p>JMM和Java运行时内存区域的划分，这两者既有差别又有联系</p>
<ul>
<li>区别:两者是不同的概念层次。JMM是抽象的，他是用来描述一组规则，通过这个规则来控制各个变量的访问方式，围绕原子性、有序性、可见性等展开的。而Java运行时内存的划分是具体的，是JVM运行Java程序时，必要的内存划分。</li>
<li>联系:都存在私有数据区域和共享数据区域。一般来说，JMM中的主内存属于共享数据区域，他是包含了堆和方法区；同样，JMM中的本地内存属于私有数据区域，包含了程序计数器、本地方法栈、虚拟机栈。</li>
</ul>
<h4 id="重排序与happens-before">重排序与happens-before</h4>
<h5 id="什么是重排序">什么是重排序？</h5>
<p>计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排</p>
<blockquote>
<p>流水线技术使得指令可以并发执行,但这种技术下中断的后果严重,执行重排可以减少中断发生</p>
</blockquote>
<h5 id="顺序一致性模型与jmm的保证">顺序一致性模型与JMM的保证</h5>
<h5 id="happens-before">happens-before</h5>
<p>happens-before规则定义一些禁止编译优化的场景，保证并发编程的正确性</p>
<h4 id="volatitle">volatitle</h4>
<p>涉及概念</p>
<blockquote>
<p>内存可见性:指的是线程之间的可见性，当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值<br>
重排序:为优化程序性能，对原有的指令执行顺序进行优化重新排序。重排序可能发生在多个阶段，比如编译重排序、CPU重排序等<br>
happens-before规则:只要程序员在写代码的时候遵循happens-before规则，JVM就能保证指令在多线程之间的顺序性符合程序员的预期</p>
</blockquote>
<h5 id="volatile的内存语义">volatile的内存语义</h5>
<p>volatile主要有以下两个功能</p>
<ul>
<li>保证变量的内存可见性</li>
<li>禁止volatile变量与普通变量重排序</li>
</ul>
<h5 id="volatile的用途">volatile的用途</h5>
<h3 id="synchronized与锁">synchronized与锁</h3>
<blockquote>
<p>Java多线程的锁都是基于对象的，Java中的每一个对象都可以作为一个锁。<br>
类锁其实也是对象锁,Java类只有一个Class对象（可以有多个实例对象，多个实例共享这个Class对象），而Class对象也是特殊的Java对象。所以我们常说的类锁，其实就是Class对象的锁</p>
</blockquote>
<h4 id="synchronized关键字">Synchronized关键字</h4>
<h4 id="几种锁">几种锁</h4>
<blockquote>
<p>Java 6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁“。在Java 6 以前，所有的锁都是”重量级“锁。所以在Java 6 及其以后，一个对象其实有四种锁状态，它们级别由低到高依次是</p>
</blockquote>
<ul>
<li>无锁状态(锁标志位 01) 记录对象的hashcode</li>
<li>偏向锁状态(01):偏向于第⼀个访问锁的线程(竞争出现才释放锁)：记录持有锁的线程ID和epoach</li>
<li>轻量级锁状态(00):多个线程在不同时段获取同⼀把锁，即不存在锁竞争的情况，也就没有线程阻塞,轻量级锁来避免线程的阻塞与唤醒 =&gt; 自旋锁: 指向栈中锁记录的指针</li>
<li>重量级锁状态(10):指向</li>
</ul>
<blockquote>
<p>几种锁会随着竞争情况逐渐升级，锁的升级很容易发生，但是锁降级发生的条件会比较苛刻，锁降级发生在Stop The World期间，当JVM进入安全点的时候，会检查是否有闲置的锁，然后进行降级</p>
</blockquote>
<h5 id="java对象头">Java对象头</h5>
<ul>
<li>Mark Word:记录了对象和锁有关的信息，当这个对象被synchronized关键字当成同步锁时，围绕这个锁的一系列操作都和Mark Word有关</li>
<li>指向类的指针</li>
<li>数组长度（只有数组对象才有）</li>
</ul>
<h3 id="cas与原子操作-乐观锁和悲观锁">CAS与原子操作 / 乐观锁和悲观锁</h3>
<h4 id="乐观锁与悲观锁的概念">乐观锁与悲观锁的概念</h4>
<blockquote>
<p>悲观锁:悲观锁就是我们常说的锁。对于悲观锁来说，它总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。<br>
乐观锁:乐观锁又称为“无锁”，顾名思义，它是乐观派。乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。而一旦多个线程发生冲突，乐观锁通常是使用一种称为CAS的技术来保证线程执行的安全性</p>
</blockquote>
<blockquote>
<p>乐观锁多用于“读多写少“的环境，避免频繁加锁影响性能；而悲观锁多用于”写多读少“的环境，避免频繁失败和重试影响性能。</p>
</blockquote>
<h4 id="cas的概念">CAS的概念</h4>
<p>比较并交换（Compare And Swap）,CAS 中有三个值</p>
<ul>
<li>V：要更新的变量(var)</li>
<li>E：预期值(expected)</li>
<li>N：新值(new)</li>
</ul>
<p>比较并交换的过程如下：</p>
<blockquote>
<p>判断V是否等于E，如果等于，将V的值设置为N；如果不等，说明已经有其它线程更新了V，则当前线程放弃更新，什么都不做。<br>
因为CAS是一种原子操作，它是一种系统原语，是一条CPU的原子指令，从CPU层面保证它的原子性<br>
当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作</p>
</blockquote>
<h4 id="java实现cas的原理-unsafe类">Java实现CAS的原理 - Unsafe类</h4>
<h4 id="原子操作-atomicinteger类源码简析">原子操作-AtomicInteger类源码简析</h4>
<h3 id="aqs">AQS</h3>
<h4 id="aqs简介">AQS简介</h4>
<p>AQS是AbstractQueuedSynchronizer的简称，即抽象队列同步器<br>
AQS:让线程使用CAS操作 volatile修饰的state变量,获取成功的可以获得锁,失败的进入 CLH实现的等待队列,等待唤醒<br>
锁的类型有共享的(tryRelease,信号量),有独占的(ReentrantLock)<br>
tryAcquire<br>
tryRelease</p>
<h2 id="jdk工具篇">JDK工具篇</h2>
<h3 id="线程池原理">线程池原理</h3>
<h4 id="为什么要使用线程池">为什么要使用线程池</h4>
<p>使用线程池主要有以下三个原因</p>
<ul>
<li>创建/销毁线程需要消耗系统资源，线程池可以复用已创建的线程</li>
<li>控制并发的数量。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因）</li>
<li>可以对线程做统一管理，定时执行、定期执行等</li>
</ul>
<h4 id="线程池的原理">线程池的原理</h4>
<blockquote>
<p>Java中的线程池顶层接口是Executor接口，ThreadPoolExecutor是这个接口的实现类</p>
</blockquote>
<h5 id="threadpoolexecutor提供的构造方法">ThreadPoolExecutor提供的构造方法</h5>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 五个参数的构造函数</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue)</span><br><span class="line">// 六个参数的构造函数-1</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory)</span><br><span class="line">// 六个参数的构造函数-2</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          RejectedExecutionHandler handler)</span><br><span class="line">// 七个参数的构造函数</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>四种构造方法都涉及五个参数</p>
<ul>
<li>int corePoolSize:核心线程的最大数量(核心线程会默认存在于线程池,而非核心线程闲置超时会被销毁)<a href="https://blog.csdn.net/MingHuang2017/article/details/79571529" target="_blank" rel="noopener">核心线程的复用</a></li>
<li>int maximumPoolSize:线程总数的上限</li>
<li>long keepAliveTime: 非核心线程闲置时长(如果设置allowCoreThreadTimeOut(true)，则会也作用于核心线程)</li>
<li>TimeUnit unit：keepAliveTime的单位</li>
<li>BlockingQueue workQueue:阻塞队列,维护着等待执行的Runnable任务对象
<ul>
<li>LinkedBlockingQueue:链式阻塞队列,底层是链表,默认大小是Integer.MAX_VALUE,也可指定</li>
<li>ArrayBlockingQueue:数组阻塞队列,基于数组实现,需指定队列大小</li>
<li>SynchronousQueue:同步队列,内部容量为0,每个put操作必须等待一个take操作</li>
<li>DelayQueue：延迟队列,队列中的元素必须等待其指定的延迟时间,才能取到其元素</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>两个非必须参数</p>
<ul>
<li>ThreadFactory threadFactory:创建线程的工厂 ，用于批量创建线程，统一在创建线程时设置一些参数，如是否守护线程、线程的优先级等。如果不指定，会新建一个默认的线程工厂。</li>
<li>RejectedExecutionHandler handler:拒绝处理策略，线程数量大于最大线程数就会采用拒绝处理策略，四种拒绝处理的策略为
<ul>
<li>ThreadPoolExecutor.AbortPolicy:默认拒绝处理策略，丢弃任务并抛出RejectedExecutionException异常</li>
<li>ThreadPoolExecutor.DiscardPolicy:丢弃新来的任务，但是不抛出异常</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy:丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）</li>
<li>ThreadPoolExecutor.CallerRunsPolicy:由调用线程处理该任务 阻塞主线程</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="threadpoolexecutor的策略">ThreadPoolExecutor的策略</h5>
<blockquote>
<p>线程池本身有一个调度线程,这个线程就是用于管理布控整个线程池里的各种任务和事务，例如创建线程、销毁线程、任务队列管理、线程队列管理等等<br>
ThreadPoolExecutor类中定义了一个volatile int变量runState来表示线程池的状态 ，分别为RUNNING、SHURDOWN、STOP、TIDYING 、TERMINATED</p>
</blockquote>
<ul>
<li>线程池创建之后处于Runnig状态</li>
<li>调用shutdown之后处于SHUTDOWN状态,线程池不能接受新的任务,同时销毁空闲的work线程,等待阻塞队列的任务完成</li>
<li>调用shutDownNow 之后处于 Stop 状态,不接受新任务,中断所有线程(线程执行完任务,根据状态是否中断),阻塞队列中所有没有执行的任务丢弃,此时poolsize=0,阻塞队列大小为0</li>
<li>当所有任务终止时,ctl记录的&quot;当前线程&quot;为0,线程池变为TIDYING状态,接着执行terminated 函数</li>
<li>线程池处在TIDYING状态时，执行完terminated()方法之后，就会由 TIDYING -&gt; TERMINATED， 线程池被设置为TERMINATED状态</li>
</ul>
<h5 id="线程池主要的任务处理流程">线程池主要的任务处理流程</h5>
<ul>
<li>线程总数量小于corePoolSize,无论线程是否空闲,都会新建一个核心线程执行任务(让核心线程数量快速达到corePoolSize，在核心线程数量 &lt; corePoolSize时) 注意，在addWork核心部门 需要获得全局锁</li>
<li>线程总数量 &gt;= corePoolSize时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了线程复用）</li>
<li>线程总数量 &gt;= corePoolSize时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了线程复用）</li>
<li>线程总数量 &gt;= corePoolSize时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了线程复用）</li>
</ul>
<h5 id="threadpoolexecutor如何做到线程复用的">ThreadPoolExecutor如何做到线程复用的</h5>
<blockquote>
<p>ThreadPoolExecutor在创建线程时，会将线程封装成工作线程worker,并放入工作线程组中，然后这个worker反复从阻塞队列中拿任务去执行</p>
</blockquote>
<h5 id="其他">其他</h5>
<blockquote>
<p>ctl类型为AtomicInteger，那用一个基础如何表示以上五种状态以及线程池工作线程数量呢？int型变量占用4字节，共32位，因此采用位表示，可以解决上述问题。5种状态使用5种数值进行表示，需要占用3位，余下的29位就可以用来表示线程数。因此，高三位表示进程状态，低29位为线程数量</p>
</blockquote>
<h4 id="四种常见的线程池">四种常见的线程池</h4>
<blockquote>
<p>Executors类中提供的几个静态方法来创建线程池,实际上通过ThreadPoolExecutor 构造</p>
<ul>
<li>newCachedThreadPool：ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue<runnable>());运行流程如下:
<ul>
<li>提交任务进线程池</li>
<li>由于corePoolSize为0,不创建核心线程</li>
<li>将任务添加进SynchronousQueue 队列;如果队列中已有任务,该操作会阻塞,否则添加成功,创建非核心线程,从队列中拉取任务并执行<br>
当执行很多短时间的任务时,newCacheThreadPool的复用效率比较高,可以显著提高性能;60s保证了空闲线程不会占据资源太长时间</li>
</ul>
</runnable></li>
<li>newFixedThreadPool：new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue<runnable>());
<ul>
<li>核心线程数量和总线程数量相等，都是传入的参数nThreads，所以只能创建核心线程，不能创建非核心线程.</li>
<li>如果核心线程空闲,则交给核心线程处理;否则进入队列(长队默认INT_MAX_VVALUE)等待 核心线程空闲</li>
<li>对比
<ul>
<li>newFixedThreadPool 只创建核心线程 且 核心线程创建后不会被回收 即使没有任务也会占用很多资源</li>
<li>都几乎不会触发拒绝策略，但是原理不同：newCacheThreadPool 由于 非线程 数量 几乎没有限制,所以基本不会 拒绝;而newFixedThreadPool 由于阻塞队列长度很大 也几乎不会触发拒绝策略</li>
</ul>
</li>
</ul>
</runnable></li>
<li>newSingleThreadPool:ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue<runnable>())
<ul>
<li>有且仅有一个核心线程按照先入先出的顺序执行任务;其阻塞队列 LinkedBlockingQueue 容量很大</li>
</ul>
</runnable></li>
<li>newScheduledThreadPool:(corePoolSize, Integer.MAX_VALUE,DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,new DelayedWorkQueue())<br>
- 创建一个定长线程池(DEFAULT_KEEPALIVE_MILLIS为0)，配合DelayedWorkQueue 支持定时及周期性任务执行</li>
</ul>
</blockquote>
<h3 id="阻塞队列">阻塞队列</h3>
<h4 id="阻塞队列的由来">阻塞队列的由来</h4>
<blockquote>
<p>对生产者-消费者模式的实现能够简化开发流程,解耦生产消费数据的过程,同时简化数据的冲突问题<br>
BlockingQueue是Java util.concurrent包下重要的数据结构，区别于普通的队列，BlockingQueue提供了线程安全的队列访问方式，并发包下很多高级同步类的实现都是基于BlockingQueue实现的。BlockingQueue就是存放元素的容器。</p>
</blockquote>
<p>阻塞队列提供了四组不同的方法用于插入、移除、检查元素</p>
<table>
<thead>
<tr>
<th>方法\处理方式</th>
<th style="text-align:center">抛出异常</th>
<th style="text-align:center">返回特殊值</th>
<th style="text-align:center">一直阻塞</th>
<th style="text-align:right">超时退出</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入方法</td>
<td style="text-align:center">add(e)</td>
<td style="text-align:center">offer(2)</td>
<td style="text-align:center">put(e)</td>
<td style="text-align:right">offer(e,time,unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td style="text-align:center">remove()</td>
<td style="text-align:center">poll()</td>
<td style="text-align:center">take(e)</td>
<td style="text-align:right">poll(time,unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td style="text-align:center">element()</td>
<td style="text-align:center">peek</td>
<td style="text-align:center">-</td>
<td style="text-align:right">-</td>
</tr>
</tbody>
</table>
<h4 id="blockingqueue的实现类">BlockingQueue的实现类</h4>
<h5 id="arrayblockingqueue">ArrayBlockingQueue</h5>
<p>由数组结构组成的有界阻塞队列。内部结构是数组，故具有数组的特性<br>
可以初始化队列大小， 且一旦初始化不能改变。构造方法中的fair表示控制对象的内部锁是否采用公平锁，默认是非公平锁</p>
<h5 id="linkedblockingqueue">LinkedBlockingQueue</h5>
<p>由链表结构组成的有界阻塞队列。内部结构是链表，具有链表的特性。默认队列的大小是Integer.MAX_VALUE，也可以指定大小。此队列按照先进先出的原则对元素进行排序。</p>
<h5 id="delayqueue">DelayQueue</h5>
<p>该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。注入其中的元素必须实现 java.util.concurrent.Delayed 接口。<br>
DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p>
<h5 id="priorityblockingqueue">PriorityBlockingQueue</h5>
<p>基于优先级的无界阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），内部控制线程同步的锁采用的是公平锁。</p>
<h5 id="synchronousqueue">SynchronousQueue</h5>
<p>这个队列比较特殊，没有任何内部容量(利用基于数组的最小二叉堆实现，初始容量为11会自动扩容)，甚至连一个队列的容量都没有。并且每个 put 必须等待一个 take，反之亦然。</p>
<h4 id="阻塞队列的原理">阻塞队列的原理</h4>
<blockquote>
<p>阻塞队列利用 锁的多条件Condition 阻塞控制实现(类似Object的wait notify)<br>
对于同一个 ReentrantLock 锁 初始化两个监视器 NotFull NotEmpty<br>
这两个监视器的作用目前可以简单理解为标记分组，当该线程是put操作时，给他加上监视器notFull,标记这个线程是一个生产者；当线程是take操作时，给他加上监视器notEmpty，标记这个线程是消费者。 利用 Condition的wait notify 实现 消费者和生产者之间的互动<br>
需要注意的是ArrayBlockingQueue 只有一个锁,而LinkedBlockingQueue 有take,put 两个锁,各自初始化 notEmpty notFull</p>
</blockquote>
<h3 id="锁接口和类">锁接口和类</h3>
<blockquote>
<p>Java原生的锁——基于对象的锁，它一般是配合synchronized关键字来使用的;不足之处</p>
<ul>
<li>如果临界区是只读操作，其实可以多线程一起执行，但使用synchronized的话，同一时间只能有一个线程执行。</li>
<li>synchronized无法知道线程有没有成功获取到锁</li>
<li>使用synchronized，如果临界区因为IO或者sleep方法等原因阻塞了，而当前线程又没有释放锁，就会导致所有线程等待</li>
</ul>
</blockquote>
<h4 id="锁的几种分类">锁的几种分类</h4>
<h5 id="可重入锁和非可重入锁">可重入锁和非可重入锁</h5>
<p>重入锁:顾名思义。就是支持重新进入的锁，也就是说这个锁支持一个线程对同一个资源重复加锁<br>
实现：每一个锁关联一个线程持有者和计数器，当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为 1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为 0，则释放该锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 演示可重入锁是什么意思，可重入，就是可以重复获取相同的锁，synchronized和ReentrantLock都是可重入的</span><br><span class="line">// 可重入降低了编程复杂性</span><br><span class="line">public class WhatReentrant &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				synchronized (this) &#123;</span><br><span class="line">					System.out.println(&quot;第1次获取锁，这个锁是：&quot; + this);</span><br><span class="line">					int index = 1;</span><br><span class="line">					this.reenter();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">    public static void reenter()&#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                System.out.println(&quot;第&quot; + (++index) + &quot;次获取锁，这个锁是：&quot; + this);</span><br><span class="line">            &#125;</span><br><span class="line">            if (index == 10) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="公平锁与非公平锁">公平锁与非公平锁</h4>
<p>公平锁:就是&quot;先来后到&quot;，也就是FIFO。如果对一个锁来说，先对锁获取请求的线程一定会先被满足，后对锁获取请求的线程后被满足，那这个锁就是公平的。反之，那就是不公平的<br>
一般情况下，非公平锁能提升一定的效率。但是非公平锁可能会发生线程饥饿（有一些线程长时间得不到锁）的情况。所以要根据实际的需求来选择非公平锁和公平锁。<br>
ReentrantLock支持非公平锁和公平锁两种<br>
非公平锁性能高于公平锁性能。首先，在恢复一个被挂起的线程与该线程真正运行之间存在着严重的延迟。而且，非公平锁能更充分的利用cpu的时间片，尽量的减少cpu空闲的状态时间</p>
<h4 id="读写锁和排它锁">读写锁和排它锁</h4>
<p>synchronized用的锁和ReentrantLock，其实都是“排它锁”。也就是说，这些锁在同一时刻只允许一个线程进行访问。<br>
读写锁可以再同一时刻允许多个读线程访问。Java提供了ReentrantReadWriteLock类作为读写锁的默认实现，内部维护了两个锁：一个读锁，一个写锁。通过分离读锁和写锁，使得在“读多写少”的环境下，大大地提高了性能。</p>
<h3 id="jdk中有关锁的一些接口和类">JDK中有关锁的一些接口和类</h3>
<h4 id="抽象类aqsaqlsaos">抽象类AQS/AQLS/AOS</h4>
<h4 id="接口conditionlockreadwritelock">接口Condition/Lock/ReadWriteLock</h4>
<p>每个对象都可以用继承自Object的wait/notify方法来实现等待/通知机制。而Condition接口也提供了类似Object监视器的方法，通过与Lock配合来实现等待/通知模式</p>
<h4 id="reentrantlock">ReentrantLock</h4>
<h4 id="reentrantreadwritelock">ReentrantReadWriteLock</h4>
<p>ReadWriteLock接口的JDK默认实现。它与ReentrantLock的功能类似，同样是可重入的，支持非公平锁和公平锁。不同的是，它还支持”读写锁“。</p>
<h3 id="并发集合容器简介">并发集合容器简介</h3>
<h4 id="同步容器与并发容器">同步容器与并发容器</h4>
<p>java.util包下提供了一些容器类，而Vector和HashTable是线程安全的容器类，但是这些容器实现同步的方式是通过对方法加锁(sychronized)方式实现的，这样读写均需要锁操作，导致性能低下。<br>
并发容器是Java 5 提供的在多线程编程下用于代替同步容器，针对不同的应用场景进行设计，提高容器的并发访问性，同时定义了线程安全的复合操作。</p>
<h4 id="并发容器类介绍">并发容器类介绍</h4>
<p>BlockingQueue CopyOnWrite</p>
<h5 id="并发map">并发Map</h5>
<h6 id="concurrentmap接口">ConcurrentMap接口</h6>
<p>ConcurrentHashMap类</p>
<blockquote>
<p>ConcurrentHashMap同HashMap一样也是基于散列表的map，但是它提供了一种与HashTable完全不同的加锁策略提供更高效的并发性和伸缩性。<br>
ConcurrentHashMap提供了一种粒度更细的加锁机制来实现在多线程下更高的性能，这种机制叫分段锁(Lock Striping)。<br>
提供的优点是：在并发环境下将实现更高的吞吐量，而在单线程环境下只损失非常小的性能。<br>
可以这样理解分段锁，就是将数据分段，对每一段数据分配一把锁。当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问<br>
有些方法需要跨段，比如size()、isEmpty()、containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁<br>
ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，HashEntry则用于存储键值对数据。</p>
</blockquote>
<p><a href="https://my.oschina.net/pingpangkuangmo/blog/817973" target="_blank" rel="noopener">1.8版</a><br>
<a href="https://zhuanlan.zhihu.com/p/151419617" target="_blank" rel="noopener">参考2</a><br>
更改为 数组+单链表/红黑树的结构(由于segment的存在反而加大了锁的冲突,1.8的锁基于首节点)<br>
读操作无需加锁:val next元素 使用volatile修饰,保证能够读到最新的的数据,对数组引用的修饰保证数组扩容的可见性(比hashmap更高效)<br>
put操作时 当节点首尾null时首先尝试利用CAS操作更新,否则加锁更新</p>
<p>ConcurrentNavigableMap接口与ConcurrentSkipListMap类</p>
<h5 id="并发queue">并发Queue</h5>
<p>JDK并没有提供线程安全的List类，因为对List来说，很难去开发一个通用并且没有并发瓶颈的线程安全的List。因为即使简单的读操作，拿contains() 这样一个操作来说，很难搜索的时候如何避免锁住整个list。<br>
DK提供了对队列和双端队列的线程安全的类：ConcurrentLinkedDeque和ConcurrentLinkedQueue;这两个类是使用CAS来实现线程安全的</p>
<h5 id="并发set">并发Set</h5>
<p>ConcurrentSkipListSet，是线程安全的有序的集合。底层是使用ConcurrentSkipListMap实现</p>
<h1 id="问题">问题</h1>
<h3 id="多线程基础">多线程基础</h3>
<p>什么是线程和进程? 线程与进程的关系,区别及优缺点？</p>
<blockquote>
<p>区别：</p>
<ul>
<li>进程是一个独立的运行环境，而线程是在进程中执行的一个任务。他们两个本质的区别是是否单独占有内存地址空间及其它系统资源（比如I/O）</li>
<li>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位，即CPU分配时间的单位<br>
进程让操作系统的并发性成为了可能，而线程让进程的内部并发成为了可能<br>
上下文是指某一时间点 CPU 寄存器和程序计数器的内容。<br>
上下文切换通常是计算密集型的，意味着此操作会消耗大量的 CPU 时间，故线程也不是越多越好</li>
</ul>
</blockquote>
<p>区别,优缺点：</p>
<blockquote>
<p>多线程 VS 多进程 ：多线程 能够充分利用 多核CPU的资源,降低了进程上下文切换的消耗 但是多线程的资源共享也可能出现竞争冲突,死锁等</p>
</blockquote>
<p>说说并发与并行的区别?</p>
<blockquote>
<p>并发指一段时间内多个任务的同时存在,逻辑上同时,对于于线性执行,对于AB任务的执行,在完成部分A切换到完成B(时间片轮转调度)<br>
并行指多个任务的同时存在,时间上同时,并行是并发的一个子集,人脑就是并行的,左半脑控制运动的同时,右半脑可以思考</p>
</blockquote>
<p>为什么要使用多线程呢?</p>
<blockquote>
<p>多进程方式确实可以实现并发，但使用多线程，有以下几个好处</p>
<ul>
<li>进程间的通信比较复杂，而线程间的通信比较简单，通常情况下，我们需要使用共享资源，这些资源在线程间的通信比较容易。
<ul>
<li>进程：管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams</li>
<li>线程：锁,等待通知机制(wait notify),信号量,管道 其他(join sleep threadLocal)</li>
</ul>
</li>
<li>进程是重量级的，而线程是轻量级的，故多线程方式的系统开销更小</li>
</ul>
</blockquote>
<p>使用多线程可能带来什么问题?（内存泄漏、死锁、线程不安全等等）</p>
<blockquote>
<p>通知等待机制 导致的死锁;共享变量导致的线程不安全;大量线程导致的OOM;内存泄漏(就是该被释放的对象没有释放，一直被某个或某些实例所持有却不再被使用导致 GC 不能回收例如ThreadLocal中的value);</p>
</blockquote>
<p>创建线程有哪几种方式？（a.继承 Thread 类;b.实现 Runnable 接口;c. 使用 Executor 框架;d.使用 FutureTask）</p>
<blockquote>
<p>实现Runable接口;继承Thread类;实现callable 接口或使用futureTask ;使用Executor 创建多线程</p>
</blockquote>
<p>说说线程的生命周期和状态?</p>
<blockquote>
<p>新建-就绪-运行-阻塞-waitting-timeWaitting-死亡</p>
</blockquote>
<p>什么是上下文切换?</p>
<blockquote>
<p>上下文指某一时间点 cpu 和程序计数器的内容;进程之间 通过 时间片轮转算法 来获取时间片运行,上下文是休眠进程恢复运行的需要数据;上下文切换指进程的上下文的保存与恢复</p>
</blockquote>
<p>什么是线程死锁?如何避免死锁?</p>
<blockquote>
<p>指两个或两个以上的线程互相持有对方需要的资源<br>
死锁产生的必要条件: 请求和保持,不可剥脱,环形等待,资源互斥<br>
避免:加锁顺序：线程按照相同的顺序加锁 ;加锁时限，线程获取锁的过程中限制一定的时间(jps 查进程;jstack + id 查线程)</p>
</blockquote>
<p>说说 sleep() 方法和 wait() 方法区别和共同点?</p>
<blockquote>
<p>共同点:都使得线程处于休眠状态<br>
区别：</p>
<ul>
<li>sleep 仅释放CPU资源,而wait释放CPU和锁资源</li>
<li>sleep是线程方法(最终调用本地方法实现),wait属于Object方法</li>
<li>wait需要被动唤醒</li>
<li>sleep方法不依赖于同步器synchronized，但是wait需要依赖synchronized关键字</li>
</ul>
</blockquote>
<p>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？如果多次调用start方法会发生什么？</p>
<blockquote>
<p>线程状态(NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED 0-5 )<br>
线程 start时,会判断线程状态是否是0/NEW,是才可以运行否则 报IllegalThreadStateException;然后会将 线程加入 main 线程组,调用<a href="https://www.linuxidc.com/Linux/2016-03/128997.htm" target="_blank" rel="noopener">start0</a>方法然后真正创建线程,然后 等待调度器调用<br>
直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作<br>
start()方法不能多次调用，否则抛出java.lang.IllegalStateException；而，run()方法可以进行多次调用，因为它只是一种正常的方法调用<br>
在java中，每次程序运行至少启动两个线程，一个是main线程，一个是垃圾回收线程</p>
</blockquote>
<p>阻塞的情况分三种</p>
<p>什么情况下使用join()？</p>
<p>yield方法，使当前线程让出cpu占用权，进入执行队列,不可能使较低较低优先权的线程获得cpu占有权，而sleep可以在没有锁的情况下，sleep()可以使低优先级的线程得到执行的机会</p>
<h3 id="多线程知识进阶">多线程知识进阶</h3>
<h4 id="线程池提交任务的方式">线程池提交任务的方式</h4>
<p><a href="https://blog.csdn.net/weixin_44053668/article/details/102155732" target="_blank" rel="noopener">两种方式</a></p>
<ul>
<li>execute :在执行完runnable任务之后没有返回值</li>
<li>submit：运行完任务之后有返回值,可以通过实现Callable接口,封装为futureTask,get获取任务结果<br>
FutureTask多用于耗时的计算，并行执行耗时任务,主线程可以在完成自己的任务后，再去获取结果；取消因需求资源而长期等待的任务;利用CocurrentHashMap 和 FutureTask 使得 同时只有一个线程在执行任务<a href="https://zhuanlan.zhihu.com/p/34004674" target="_blank" rel="noopener">如何构建一个高效且可伸缩的缓存</a></li>
</ul>
<h4 id="为什么不直接使用thread-使用runable">为什么不直接使用Thread 使用runable</h4>
<blockquote>
<p>实现接口,多继承<br>
重复使用runable接口</p>
</blockquote>
<h4 id="executorservice-submit之后发生了什么">executorService submit之后发生了什么?</h4>
<blockquote>
<p>submit 之后返回Future 的泛型,可以调用get阻塞获取执行结果而execute 无法得到结果<br>
todo 需要注意的是 submit 中产生的以上会被setException 吸取,无法显示抛出异常<br>
源码解析：todo</p>
</blockquote>
<h4 id="completablefuture-completableservice">CompletableFuture CompletableService</h4>
<h4 id="volatile-关键字">volatile 关键字</h4>
<p>Java 内存模型（JMM）</p>
<blockquote>
<p>Java内存区域:PC+堆+本地方法栈+线程栈+方法区<br>
JMM:线程 和线程私有的工作内存(栈) 通过缓存一致性协议 实现对主内存的读写<br>
<img src="/images/JMM.png" alt="JMM"></p>
</blockquote>
<p>重排序与 happens-before 原则了解吗?</p>
<blockquote></blockquote>
<p>volatile 关键字的作用</p>
<blockquote>
<p>保证可见性和有序性(禁止指令重排序:涉及volatile变量的指令顺序不可优化),但不能保证原子性,因而线程不安全</p>
</blockquote>
<p>说说 synchronized 关键字和 volatile 关键字的区别</p>
<blockquote>
<p>volatile 实质上在 告诉JVM当前值 不确定,要求 读写最新值;而synchronize锁定当前变量,不允许其他线程访问</p>
<ul>
<li>能够保证可见性,但不能保证原子性;synchronize 保证原子性和修改可见性</li>
<li>volatile 只能应用在 变量;而synchronize则可以对象方法和类(但都是对象锁)</li>
<li>volatile 不会导致线程的的阻塞;</li>
<li>volatile 修饰的变量不会被编译器优化</li>
</ul>
</blockquote>
<h4 id="threadlocal">ThreadLocal</h4>
<p><a href="https://zhuanlan.zhihu.com/p/205174552" target="_blank" rel="noopener">为了进阿里，死磕了ThreadLocal内存泄露原因</a><br>
<a href="https://zhuanlan.zhihu.com/p/192873419" target="_blank" rel="noopener">ThreadLocal面试六连问，你能Hold住吗？</a><br>
<a href="https://www.cnblogs.com/nullzx/p/7553538.html" target="_blank" rel="noopener">ThreadLocal原理及使用示例</a></p>
<p>有啥用（解决了什么问题）？怎么用？</p>
<blockquote>
<p>ThreadLocal是一个线程本地变量副本工具类，内部用一个弱引用的Map维护<br>
高并发的时候，我们在调用一些公有的对象资源的时候，会有线程安全问题或者加锁 阻塞问题;利用ThreadLocal 可以解决多线程变量共享问题(重写initialValue);在数据库连接池里使用ThreadLocal 限制 多线程使用的conection为同一个,保持处于同一个事物<br>
<a href="https://www.jianshu.com/p/3ab5f9145ca2" target="_blank" rel="noopener">案例分析</a><br>
多线程下SimpleDateFormat 不安全,由于多个线程之间共享并修改变量calendar,导致不安全(解决 1.局部变量 2.加锁共享 3.ThreadLocal )</p>
</blockquote>
<p>原理了解吗？</p>
<blockquote>
<p>Thread 维护一个 threadLocalMap，实质上是一个Entry(WeekReference&lt;ThreadLocalMap&lt;?&gt;作为Entry的key&gt;)数组;threadLocal 的实例 是 线程的共享变量,其实例的弱引用作为 Entry的key ,以threadLocal实例哈希值作为 数组的index,然后存取变量;<br>
在开始get时,默认是从当前线程(this只当前对象,this.currentThread指调用这段代码的线程) 获取map,以threadLocal做index获取Entry,然后获取value;<br>
多线程 线程复用</p>
</blockquote>
<p>内存泄露问题了解吗？</p>
<blockquote>
<p>由于ThreadLocalMap的Entry中对ThreadLocal是弱引用,如果 指向其的强引用不在指向它(改为null或者其他),那么在gc中 可能导致 清除 ThreadLocal对象,而thread-&gt;threadLocalMap-&gt;value 是强引用不会清除,但value已经无法访问<br>
解决方法: 每次在使用完之后remove ; 用 static(所有实例共享) final(无法修改执行) 修饰 ; THreadLocal本身在getEntry方法中也会主动清除Entry为null的key和value<br>
其本质原因是由于ThreadLocalMap与线程的生命周期一致,所以当ThreadLocalMap无效时,无法清除(但是多线程里通过复用线程来提高性能， 所以currentThread一般不会处于终止状态);利用弱引用相当于告诉JVM 去清除(另类的通知机制) 而如果是强引用,那么即使ThreadLocal无人在使用,只要有一个线程还在运行/休眠阻塞,那么它就无法清除</p>
</blockquote>
<p>InheritableThreadLocal?</p>
<blockquote>
<p>子线程可以访问父线程的ThreadLocal对象,通过重写 getchildValue，getMap(返回inheritlocals) createMap(赋值inheThreadlocals) 实现<br>
Thread类构造函数中:子线程在实例化过程中，会查看当前执行线程（可以理解为父线程）的inheritableThreadLocals是否为null，如果不为null，则将该变量赋值给子线程的inheritableThreadLocals</p>
</blockquote>
<p>手动释放ThreadLocal遗留存储?你怎么去设计/实现？</p>
<blockquote>
<p>包装其父类remove方法为静态方法在强引用的析构函数里清除;如果是spring项目， 可以借助于bean的声明周期， 在拦截器的afterCompletion阶段进行调用</p>
</blockquote>
<p>Thread和ThreadLocal有什么联系呢</p>
<blockquote>
<p>Thread和ThreadLocal是绑定的， ThreadLocal依赖于Thread去执行， Thread将需要隔离的数据存放到ThreadLocal(准确的讲是ThreadLocalMap)中, 来实现多线程处理</p>
</blockquote>
<p>Spring如何处理Bean多线程下的并发问题</p>
<blockquote>
<p>ThreadLocal天生为解决相同变量的访问冲突问题， 所以这个对于spring的默认单例bean的多线程访问是一个完美的解决方案。spring也确实是用了ThreadLocal来处理多线程下相同变量并发的线程安全问题。<br>
spring 如何保证数据库事务在同一个连接下执行的<br>
DataSourceTransactionManager 是spring的数据源事务管理器， 它会在你调用getConnection()的时候从数据库连接池中获取一个connection， 然后将其与ThreadLocal绑定， 事务完成后解除绑定。这样就保证了事务在同一连接下完成。</p>
</blockquote>
<h4 id="线程池">线程池</h4>
<p>为什么要用线程池？</p>
<blockquote>
<p>线程的新建和消耗系统资源,可以利用线程池复用线程;控制并发数量,避免耗尽系统资源;统一管理线程</p>
</blockquote>
<p>你会使用线程池吗？</p>
<blockquote>
<p>腾讯项目使用过线程池,利用futureTask获取结果</p>
</blockquote>
<p>如何创建线程池比较好？ （推荐使用 ThreadPoolExecutor 构造函数创建线程池）</p>
<blockquote>
<p>Java中的线程池顶层接口是Executor接口，ThreadPoolExecutor是这个接口的实现类,可以使用ThreadPoolExecutor 构建函数创建线程池</p>
</blockquote>
<p>ThreadPoolExecutor 类的重要参数了解吗？ThreadPoolExecutor 饱和策略了解吗？</p>
<blockquote>
<p>ThreadPoolExcecutor 有四个构造函数,其中都包含 核心线程数,最大线程数,非核心线程闲置时间,限制时间单位,阻塞队列,还有两个参数分别是 线程工厂 和  饱和拒绝策略<br>
饱和拒绝策略具体可以分为四种</p>
<ul>
<li>Abort 抛弃任务并抛出异常</li>
<li>Discard 仅抛弃任务</li>
<li>抛弃最先进入队列的任务</li>
<li>由调用者执行该任务</li>
</ul>
</blockquote>
<p>线程池原理了解吗？</p>
<blockquote>
<p>线城池里的线程在运行后会不断的从阻塞队列中获取任务,新建线程或者复用空闲线程,执行,直到getTask 返回null,此时确定是否准备销毁线程</p>
</blockquote>
<p>几种常见的线程池了解吗？为什么不推荐使用FixedThreadPool？</p>
<blockquote>
<p>newCacheThreadPool(0,MAX),newFixedThreadPool,newSIngleThreadPool(单核心线程),newScheduledThreadPool(size,MAX,定时线程)<br>
因为newFixedThreadPool 只要核心线程,而核心线程即使空闲也默认不会被回收,空占资源<br>
之所以建议使用ThreadPool 自己配置参与和策略是因为 提供的方法有些参数默认是Max_VALUE,对于数量过大的任务,可能出现线程数量过多或者阻塞队列太长消耗完资源的情况</p>
</blockquote>
<p>如何设置线程池的大小？</p>
<blockquote>
<p>coreSize allsize</p>
</blockquote>
<p>线程池的运行状态?</p>
<blockquote>
<p>Runnning:线程池新建之后处于该状态<br>
ShutDown:不接受任务,等现有阻塞任务完成；销毁空闲线程<br>
Stop:中断任务<br>
TIDYING:目前运行的线程为0<br>
TERMINATE：</p>
</blockquote>
<h4 id="aqs">AQS</h4>
<p>简介<br>
原理<br>
AQS 常用组件。<br>
Semaphore(信号量)-允许多个线程同时访问<br>
CountDownLatch （倒计时器）-CountDownLatch 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。<br>
CyclicBarrier(循环栅栏)-CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。<br>
ReentrantLock 和 ReentrantReadWriteLock</p>
<h4 id="锁">锁</h4>
<p>锁的常见分类</p>
<ul>
<li>可重入锁和非可重入锁</li>
<li>公平锁与非公平锁</li>
<li>读写锁和排它锁<br>
synchronized 关键字</li>
<li>说一说自己对于 synchronized 关键字的了解；</li>
<li>说说自己是怎么使用 synchronized 关键字，在项目中用到了吗;</li>
<li>讲一下 synchronized 关键字的底层原理；</li>
<li>说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗</li>
<li>谈谈 synchronized 和 ReentrantLock 的区别</li>
</ul>
<blockquote>
<p>都是</p>
</blockquote>
<h4 id="atomic-与-cas">Atomic 与 CAS</h4>
<h5 id="cas">CAS:</h5>
<p>介绍<br>
原理</p>
<h5 id="atomic-原子类">Atomic 原子类：</h5>
<p>介绍一下 Atomic 原子类；<br>
JUC 包中的原子类是哪 4 类?；</p>
<ul>
<li>基本类型：AtomicInteger, AtomicLong, AtomicBoolean</li>
<li>数组类型： AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray</li>
<li>引用类型：AtomicReference, AtomicStampedRerence, AtomicMarkableReference</li>
<li>对象的属性修改类型：AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater<br>
讲讲 AtomicInteger 的使用；i++<br>
能不能给我简单介绍一下 AtomicInteger 类的原理。<br>
ABA 问题</li>
</ul>
<blockquote>
<p>如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。<br>
AtomicStampedReference对应的数值被修改时，除了更新数据本身外，还必须要更新时间戳。当AtomicStampedReference设置对象值时，对象值以及时间戳都必须满足期望值，写入才会成功。因此，即使对象值被反复读写，写回原值，只要时间戳发生变化，就能防止不恰当的写入</p>
</blockquote>
<h3 id="并发容器">并发容器</h3>
<p>JDK 提供的这些容器大部分在 java.util.concurrent 包中。</p>
<ul>
<li>ConcurrentHashMap: 线程安全的 HashMap</li>
<li>CopyOnWriteArrayList: 线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector.</li>
<li>ConcurrentLinkedQueue: 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。</li>
<li>BlockingQueue: 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</li>
<li>ConcurrentSkipListMap: 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。</li>
</ul>
<h4 id="future-和-completablefuture">Future 和 CompletableFuture</h4>
<h3 id="自旋锁">自旋锁</h3>
<blockquote>
<p>自旋锁一般适用于短时间占用锁的场合,因为自旋锁的实现是不断的循环试图获得锁,修改数据;<br>
自旋锁一般不会涉及线程的切换,只会不断的尝试获得锁 空耗CPU时间等待另一个线程释放锁(多核线程),所以一般自旋锁应用于短时间占用锁的场合</p>
</blockquote>
<h3 id="condition">condition</h3>
<p>condition 必须和锁 关联</p>
<h3 id="synchronize的原理">synchronize的原理</h3>
<blockquote>
<p>任何java对象都有一个monitor与之关联，当一个monitor被持有后，对象就处于锁定状态。</p>
</blockquote>
<h3 id="semaphore">Semaphore</h3>
<p>可以定义进入 某段代码的线程的个数(多个锁)</p>
<h3 id="executor框架">Executor框架</h3>
<h3 id="jvm-引用">JVM 引用</h3>
<p>单纯的GC算法不足以应对复杂场景下垃圾回收</p>
<ul>
<li>强引用: 在无标注的情况下, 所创建的对象引用都是强引用;一般情况下,GC不会回收它,内存不足时会抛出OOM;</li>
<li>软引用: 内存空间不足时,会回收它指向的对象;适用于缓存</li>
<li>弱引用: 只有当垃圾回收器扫描到弱引用指向的对象时，才会回收它。生命周期比软引用更短。ThreadLocal使用了弱引用</li>
<li>虚引用: 在任何时候都可能被垃圾回收器回收，必须与引用队列关联使用</li>
</ul>
<p>配置线程的考虑因素</p>
<blockquote>
<p>从任务类型(io密集还是cpu密集)</p>
<ul>
<li>CPU密集:创建的线程数 不应该超过物理核数</li>
<li>IO密集:所使用的的资源类型(这些系统资源包括了内存（堆栈）、打开的文件句柄、打开的TCP连接),限制数据避免耗尽资源<br>
实际执行需求;压测获取分析</li>
</ul>
</blockquote>
<p><a href="https://www.zhihu.com/question/19732473" target="_blank" rel="noopener">怎样理解阻塞非阻塞与同步异步的区别</a><br>
在线程等待资源就绪以及传输资源进入内存时,线程可以做其他事情;<br>
NIO 基于channel 和 buffer操作,数据在channel和buffer 之间流动<br>
selector 与channel 相互配合,将Channel注册到Selector 上,selector会监控Channel的四种状态,Connect-&gt;Accept-&gt;Read-&gt;Write 当监控到Channel的某一状态时,才允许Channel对相应的状态</p>
<ul>
<li>Connect：怎样理解阻塞非阻塞与同步异步的区别</li>
<li>Accept：准备好进行连接</li>
<li>Read：可读</li>
<li>Write：可写</li>
</ul>
<p><a href="https://blog.csdn.net/qq_34337272/article/details/81252853" target="_blank" rel="noopener">面试必备之深入理解自旋锁</a></p>
<p>CAS:<br>
<a href="https://mp.weixin.qq.com/s?__biz=MzI3NDA4ODY4MA==&amp;mid=2653334228&amp;idx=1&amp;sn=8a106aed154ded89283146ddb6a02cf8&amp;chksm=f0cb5d53c7bcd445704592eb7c06407f1b18f1bf94bed3d33345d2443454b15f9c859b64371c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">无锁队列详细分解——Lock与Cache，到底有没有锁？</a></p>
<blockquote>
<p>其实现是多核在竞争对于内存的写的权利,ring bus的总线仲裁协议 裁决哪个赢得胜利 失败者 将自己的缓存中的值设置为失效然后获取新值</p>
</blockquote>
<p><a href="https://www.cnblogs.com/yanlong300/p/8986041.html" target="_blank" rel="noopener">MESI协议</a></p>
<blockquote>
<p>多核CPU的情况下有多个一级缓存，如何保证缓存内部数据的一致,不让系统数据混乱。这里就引出了一个一致性的协议MESI<br>
核心思想：CPU写数据时，如果发现操作的变量是共享变量，即在其他 CPU 中也存在该变量的副本，会发出信号通知其他 CPU 将该变量的缓存行置为无效状态，因此当其他 CPU 需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取</p>
</blockquote>
<ul>
<li>M 修改 (Modified):
<ul>
<li>含义：该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。</li>
<li>监听任务：缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。</li>
</ul>
</li>
<li>E 独享、互斥 (Exclusive):
<ul>
<li>含义：该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中</li>
<li>监听任务：缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。</li>
</ul>
</li>
<li>S 共享 (Shared):
<ul>
<li>含义：该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中</li>
<li>监听任务：缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。</li>
</ul>
</li>
<li>I 无效 (Invalid):效
<ul>
<li>含义：该Cache line无</li>
<li>监听任务：无</li>
</ul>
</li>
</ul>
<p>AQS：AbstractQueuedSynchronizer</p>
<blockquote>
<p><a href="https://blog.csdn.net/claram/article/details/83828768" target="_blank" rel="noopener">背景</a><br>
<a href="http://www.ideabuffer.cn/2017/03/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AbstractQueuedSynchronizer%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">深入理解AbstractQueuedSynchronizer</a><br>
AQS关键成员变量：head tail state exclusiveOwnerThread<br>
关联 类 :ConditionObject LockSupport<br>
继承类：Sync(FairSync UnFairSync) ReentrantLock</p>
</blockquote>
<p>CLH 双向链表：接本节点为Node(pre,next,Thread,state)</p>
<blockquote>
<p>lock.lock 调用sync.lock(sync.acquire(1)),试图获得锁,然后设置自己为锁的拥有线程(fair锁会在不存在等待队列前提下尝试获取锁,失败进入阻塞链表;非fair锁会尝试获取锁,失败后加入队列) ;同样利用CAS操作增加新节点<br>
lock.unlock() 调用sync.release(1), 当前进程释放<br>
condition.await() 将线程添加进链表,然后调用LockSupport.pack<br>
condition.notify notifyAll 遍历链表 轮流 调用LockSupport.unpack 释放</p>
</blockquote>
<p>CAS 设置state 队尾<br>
CountDownLatch ReentrantReadWriteLock</p>
<p>JUC下的类</p>
<p>serialization  transient<br>
序列化过程中是把对象保存为一连串字节流,只保存了对象实例的变量部分,用处</p>
<ul>
<li>对象持久化</li>
<li>复制(本地多副本)</li>
<li>传输</li>
</ul>
<blockquote>
<p>serialization提供了一个非常棒的存储对象状态的机制，说白了serialization就是把对象的状态存储到硬盘上 去，等需要的时候就可以再把它读出来使用,可以在网络中传输;<br>
而在于某些场合一些字段不希望在序列化,只保证在内存里,添加transient</p>
</blockquote>
<p>synchronized VS ReentrantLock</p>
<p>LockSupport是JDK中比较底层的类，用来创建锁和其他同步工具类的基本线程阻塞原语。java锁和同步器框架的核心AQS:AbstractQueuedSynchronizer，就是通过调用LockSupport.park()和LockSupport.unpark()实现线程的阻塞和唤醒的</p>
<p>ABA问题</p>
<p><a href="https://juejin.im/post/6844903903188746247" target="_blank" rel="noopener">AQS解析与实战</a></p>
<ul>
<li>state 状态的维护。</li>
<li>CLH队列</li>
<li>ConditionObject通知</li>
<li>模板方法设计模式</li>
<li>独占与共享模式。</li>
<li>自定义同步器。</li>
<li>AQS全家桶的一些延伸，如：ReentrantLock等</li>
</ul>
<p><a href="https://www.jianshu.com/p/fc51be7e5bc0" target="_blank" rel="noopener">thread join的使用和原理</a></p>
<p>泛型的类型擦除</p>
<p>AQS 定义了两种资源共享方式：</p>
<ol>
<li>Exclusive：独占，只有一个线程能执行，如ReentrantLock()</li>
<li>Share：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier</li>
</ol>
<p>AQS 原理</p>
<blockquote>
<p>双向队列</p>
</blockquote>
<p>节点状态<br>
SIGNAL	值为-1，后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，那么就会通知后继节点，让后继节点的线程能够运行<br>
CONDITION	值为-2，节点在等待队列中，节点线程等待在Condition上，不过当其他的线程对Condition调用了signal()方法后，该节点就会从等待队列转移到同步队列中，然后开始尝试对同步状态的获取<br>
PROPAGATE	值为-3，表示下一次的共享式同步状态获取将会无条件的被传播下去<br>
CANCELLED	值为1，由于超时或中断，该节点被取消。 节点进入该状态将不再变化。特别是具有取消节点的线程永远不会再次阻塞<br>
INITIAL	值为0，初始状态</p>
<p>condition  配合 lock 因为condition 的await 和 singal不是线程 安全的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/02/工作求职/资源收集/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/02/工作求职/资源收集/" class="post-title-link" itemprop="url">资源收集</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-02 00:09:39" itemprop="dateCreated datePublished" datetime="2020-09-02T00:09:39+08:00">2020-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-15 10:57:42" itemprop="dateModified" datetime="2021-01-15T10:57:42+08:00">2021-01-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://github.com/Snailclimb/" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p>
<p>JavaGuide<br>
多线程文章推荐</p>
<ul>
<li><a href="https://github.com/RedSpider1/concurrent" target="_blank" rel="noopener">深入浅出Java多线程</a> , <a href="https://redspider.gitbook.io/concurrent" target="_blank" rel="noopener">网页浏览</a></li>
</ul>
<p>Spring Boot</p>
<ul>
<li><a href="https://juejin.im/post/6844904024286691335#heading-80" target="_blank" rel="noopener">SpringBoot 就这一篇全搞定</a></li>
<li><a href="https://github.com/dyc87112/SpringBoot-Learning/tree/master/2.1.x" target="_blank" rel="noopener">Spring Boot基础教程（2.x版本）</a></li>
<li><a href="https://github.com/zhshuixian/learn-spring-boot-2" target="_blank" rel="noopener">Spring Boot 2.X 实战</a> <a href="https://github.com/zhshuixian/learn-spring-boot-2" target="_blank" rel="noopener">在线阅读</a></li>
</ul>
<p>Nginx</p>
<ul>
<li><a href="https://juejin.im/post/6844904021552005127" target="_blank" rel="noopener">Nginx通关攻略</a></li>
</ul>
<p>Mysql</p>
<ul>
<li><a href="https://juejin.im/post/6850037271233331208" target="_blank" rel="noopener">Mysql</a></li>
</ul>
<p>文件资料</p>
<ul>
<li><a href="D:%5CDownload%5CBaiduNetdisk%5Cbat%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB" target="_blank" rel="noopener">Local</a></li>
</ul>
<p><a href="https://github.com/yttsam/interview_internal_reference" target="_blank" rel="noopener">面试问题收集</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/31/工作求职/项目/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/31/工作求职/项目/" class="post-title-link" itemprop="url">项目</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-31 10:01:44" itemprop="dateCreated datePublished" datetime="2020-08-31T10:01:44+08:00">2020-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-15 10:57:47" itemprop="dateModified" datetime="2021-01-15T10:57:47+08:00">2021-01-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="nginx">Nginx</h2>
<p>主从模式<br>
负载均衡</p>
<h2 id="kong-网关">Kong 网关</h2>
<h3 id="限流">限流</h3>
<p>目前 Kong网关 可以通过安装插件 基于 内存操作或者 redis 实现限流,但是不能实现集群内的分布式限流<br>
<a href="http://moguhu.com/article/detail?articleId=73" target="_blank" rel="noopener">分布式限流 参考1</a></p>
<ul>
<li>限流算法: 计数器,令牌桶算法,漏桶算法</li>
</ul>
<table>
<thead>
<tr>
<th>限流算法</th>
<th style="text-align:center">算法思想</th>
<th style="text-align:right">速率限制</th>
</tr>
</thead>
<tbody>
<tr>
<td>令牌桶</td>
<td style="text-align:center">以固定速率产生令牌,按照请求的字节数消耗令牌数,如果令牌不足,缓存或者拒绝请求</td>
<td style="text-align:right">限制了平均流入速度,允许一定程度的突发请求</td>
</tr>
<tr>
<td>漏桶</td>
<td style="text-align:center">以固定的速率流出水滴,按照请求的字节数增加水滴数,如果水滴数超过桶的容量,会导致请求拒绝</td>
<td style="text-align:right">限制了流出速度,可以用于平衡突发请求</td>
</tr>
</tbody>
</table>
<ul>
<li>限流方式: 限制总并发数(数据库连接池,线程池),限制瞬时并发数(Nginx 的limit_conn),限制总接口访问量,限制调用速率</li>
<li>分布式限流 : <a href="https://github.com/all4you/sentinel-tutorial" target="_blank" rel="noopener">Sentinel</a> 集群限流工具</li>
</ul>
<h2 id="oauth2认证和jwt机制">OAuth2认证和jwt机制</h2>
<ol start="7">
<li>
<p>网关的作用：请求异步化</p>
</li>
<li>
<p>网格计算<br>
分布式计算的一种,将计算任务分发到多个有计算资源的机器上,然后将他们计算的结果统一整理</p>
</li>
<li>
<p>mysql uuid 和自增id</p>
</li>
</ol>
<blockquote>
<p>在插入式 按照b+树,自增id 的插入是顺序,告诉快捷;而uuid是乱序的,可能需要从磁盘加载到缓存 产生随机IO,可能导致频繁的页分裂(以为新的行分配空间)<br>
自增id的缺点:不安全,id有规律;高并发时涉及自增锁的争夺,影响效率;</p>
</blockquote>
<ol start="10">
<li>LVS(linux virtual server)</li>
</ol>
<blockquote>
<p>LVS集群采用三层结构，其主要组成部分为：</p>
<ul>
<li>负载均衡调度器(load balancer)，它是整个集群对外面的前端机，负责将客户的请求发送到一组服务器上执行，而客户认为服务是来自一个IP地址(我们可称之为虚拟IP地址)上的。</li>
<li>服务器池(server pool)，是一组真正执行客户请求的服务器，执行的服务有WEB、MAIL、FTP和DNS等。</li>
<li>共享存储(shared storage)，它为服务器池提供一个共享的存储区，这样很容易使得服务器池拥有相同的内容，提供相同的服务。</li>
</ul>
</blockquote>
<p>分布式事务</p>
<blockquote>
<p>应用 微服务架构</p>
</blockquote>
<ul>
<li>2PC：Two-Phase Commit</li>
<li>3PC：Three-Phase Commit</li>
<li>TCC</li>
</ul>
<h3 id="2pc">2PC</h3>
<blockquote>
<p>两段式提交协议：将事务分为两个阶段来处理：准备阶段和提交阶段;<br>
其中事务的发起者称之为协调者,事务的执行者称之为参与者<br>
准备阶段：</p>
</blockquote>
<ul>
<li>事务询问：向各参与者发送事务预处理请求,等待回应</li>
<li>事务执行：各参与者在本地执行事物,写入undo和redo日志,但不会执行,并向协调者回复是否可以提交事务</li>
<li>协调者接收到各参与者回复,如果全是yes,那么事务可以执行,如果有一个no那么就无法执行事务<br>
提交/执行阶段：</li>
<li>所有参与者返回YES
<ul>
<li>协调者向所有参与者发送commit请求</li>
<li>事务提交：参与者收到commit请求,提交本地事务,并释放资源</li>
</ul>
</li>
<li>参与者至少有一个返回No,或者等待超时
<ul>
<li>协调者向所有参与者发送滚回请求</li>
<li>事务回滚：各参与者接收到请求,回滚本地事务</li>
</ul>
</li>
</ul>
<p>不足</p>
<ul>
<li>性能问题:在第一第二阶段参与者协调者的资源都是锁住的,长时间得不到释放</li>
<li>单点故障:
<ul>
<li>协调者正常,参与者宕机:
<ul>
<li>后果：在第一阶段导致 协调者 阻塞,其他参与者无法释放资源;第二阶段 导致数据不一致</li>
<li>解决方案：针对第一个情况,在协调者端引入超时机制,超时则终止</li>
</ul>
</li>
<li>协调者宕机,参与者正常：
<ul>
<li>后果：所有参与者执行事务单位提交,陷入阻塞;</li>
<li>解决：引入协调者备份,备份需要同步协调者记录;检测到宕机之后,取代协调者,继续操作;参与者引入超时机制,回滚业务并通知协调者</li>
</ul>
</li>
<li>协调者宕机和参与者部分宕机
<ul>
<li>第一阶段:协调者备份检测超时并发出回滚指令</li>
<li>第二阶段未发送：协调者备份继续操作</li>
<li>第二阶段已发送：数据不一致</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3pc">3PC</h3>
<blockquote>
<p>三阶段提交协议主要是为了解决二阶段的问题,主要有两个改进点</p>
<ul>
<li>在协调者和参与者中都引入超时机制：使得参与者可以在超时时释放自己的资源</li>
<li>增加canCommit阶段,确保段之前的个各参与者状态一致：<br>
三阶段分为 canCommit preCommit doCommit</li>
</ul>
</blockquote>
<ul>
<li>canCommit:获取数据库脸解锁
<ul>
<li>事务问询：协调者向参与者发送canCommit请求,询问是否可以提交事务</li>
<li>相应反馈：参与者接收到canCommit请求之后,认为自己可以执行事务则返回yes,否则no</li>
</ul>
</li>
<li>preCommit:都返回yes之后进入到类似2pc的准备阶段,但参与者引入了超时机制
<ul>
<li>协调者向所有参与者发送事务预处理请求,等待回应</li>
<li>参与者接收到预处理请求,执行事务,并写入undo和redo日志,但未提交,并返回执行结果</li>
</ul>
</li>
<li>doCommit：都成功之后进入到类似于阶段3,否则发送回滚指令
<ul>
<li>协调者向所有参与者发送commit请求</li>
<li>参与者接收到请求,提交事务,并返回ACK</li>
<li>协调者如果在时限内不能接收到所有参与者的ACK或返回No,那么向所有参与者发送abort指令要求回滚,参与者收到后执行并反馈</li>
</ul>
</li>
</ul>
<p>2PC VS 3PC</p>
<ul>
<li>优点:增加canComit和超时机制,降低阻塞的可能性;在最后阶段,避免了协调者单点故障,超时等待之后,会提交事务</li>
<li>缺点:在最后阶段,可能出现参与者不能接收到协调者的回滚指令而超时提交事务,导致 数据不一致</li>
</ul>
<p><a href="https://www.cnblogs.com/xybaby/p/7153755.html" target="_blank" rel="noopener">带着问题学习分布式系统之中心化复制集</a><br>
<a href="https://www.cnblogs.com/xybaby/p/10124083.html" target="_blank" rel="noopener">一文搞懂Raft算法</a></p>
<h3 id="raft">Raft</h3>
<p>raft是基于leader的共识算法,其目的在于提高分布式系统的容错性<br>
raft协议主要有两个问题 集群选举以及日志复制问题</p>
<h4 id="集群选举">集群选举</h4>
<p>raft协议中,任意一个节点处于三种状态之一(leader,follower,candidate)<br>
所有节点在最开始时都处于follower状态;在一段时间内没有收到leader的心跳,认为leader掉线,就会转换状态为candidate,开启选举</p>
<blockquote>
<p>选举开始条件:如果follower在election timeout时间内没有接到leader的心跳(leader 真挂了,leader follower之间网络断开,选举已经开始,还未选出leader),则主动发起选举</p>
</blockquote>
<ul>
<li>增加节点本地的current term,切换到candidate状态</li>
<li>投自己一票</li>
<li>发送给其他节点requestVote Rpcs,等其他节点回复<br>
可能有3种结果</li>
<li>收到majority的票,赢得选举,成为leader</li>
<li>被告知别人已经当选,自动切换到follower</li>
<li>一段时间内没有收到majority的票,也没有收到别人当选的消息,则重新发起选举<br>
作为投票者有以下约束：</li>
<li>在任一任期,只能投一次票且FCFS</li>
<li>被投票的节点知道的信息不能比投票者少(即日志更新)</li>
</ul>
<h4 id="日志复制">日志复制</h4>
<p>客户端的一切请求都发送到leader,leader调节这些请求的顺序,把这些请求和执行顺序告知follower,leader和follower以相同的顺序执行,保证状态一致性。</p>
<h3 id="paxos">Paxos:</h3>
<h3 id="mapreduce-过程">MapReduce 过程</h3>
<ul>
<li>提交任务 JobSubmitter.java</li>
<li>Jobtracker根据输入文件的大小,根据splitsize(128M)分割为若干个split,调度相应的task,由taskTracker监控和报告给jobtracker</li>
<li>每个split对应一个map任务,map.run函数会反复读取键值对 并根据key值获得&lt;key,value,partion&gt;写入缓冲区,缓冲区满则会触发spill,将缓冲区内的数据按照partition key sort 然后combiner 之后输出到磁盘
<ul>
<li>默认对Key进行哈希运算后，再以ReduceTask数量取模(这样分配可能导致某个partition 数据较多的情况,可以随s个split间隔/随机/采样 n 个key,然后按照key排序,把可以分为n份,获得partition的分区依据<a href="http://bigdatadecode.club/MapReduce%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90--TotalOrderPartitioner.html" target="_blank" rel="noopener">TotalOrderPartitioner</a>)</li>
<li>环形缓冲区,输出起点-溢出点-下次输出点,一般溢出点占据80%</li>
<li>对应wordcount 就是每个单词对应一个key,value是1,之后快排(首先比较partition 然后比较key),然后相同key值合并,再输出到磁盘</li>
<li>当所有文件都输出到磁盘时,会触发merge,按照partition 和 key值排序 归并排序</li>
</ul>
</li>
<li>reduce端 与 AM(ApplicationMaster) 进行心跳通信获得map的数量和位置,通过fetch网络传输数据到缓存(看文件大小)或本地磁盘(缓存满之后出发spill写入磁盘);</li>
<li>所有数据到达后首先进行归并排序,然后调用combine 将相同key值的value合并,最终获得该partition 中key值的有序排列
<ul>
<li>如果内存足够直接在内存中merge然后输出到磁盘</li>
<li>在写到磁盘之前可能会插入combine的过程,即对缓存内的数据提前进行combine减少后面的计算(在map端很多地方可以插入combine以减少之后输入的文件大小以及网络传输的数据大小);</li>
</ul>
</li>
<li>如果有多个reduce任务,这几个reducer任务还需要进行一次mapReduce
<ul>
<li>由于这里的partition是hash然后求余,所以多个任务的reducer结果不一定是全局有序的;</li>
<li>所以对于分布比较均匀的key值,可以考虑类似哈希一致性算法的方法分配,在这里可以针对wordcount可以根据字符串的单位来分配partition,比如A-C属于partition0,需要把该规则告知全部map端 ;</li>
<li>对于不均匀分布的key值,这种仍然可能出现数据倾斜的问题,所以可以考虑采样的方法 最大程度获得整体数据的分布情况;</li>
</ul>
</li>
</ul>
<p>TCC：Try-Confirm-Cancel<br>
JTA<br>
RPC<br>
代理模式<br>
反射</p>
<p>微服务整体架构描述</p>
<p>Zab协议:Zookeeper Atomic Broadcast</p>
<blockquote></blockquote>
<p>Paxos 协议<br>
<a href="https://www.zhihu.com/question/19787937/answer/82340987" target="_blank" rel="noopener">参考1</a></p>
<blockquote>
<p>节点通信存在两种模型：共享内存(Shared memory)和消息传递(Messages passing)。Paxos算法就是一种基于消息传递模型的一致性算法<br>
为什么要超过一半节点?保证两次事务一定有交叠<br>
为什么第一阶段里提议者接收到已经accept的消息 会更改自己的提议值为该值,为了保持一致性<br>
每个节点有三种角色,可以同时扮演多个角色</p>
<ul>
<li>Proposor:倡议者,可以提出倡议,以供表决</li>
<li>Acceptor:接受者,可以对按照一定规则对于倡议者提出的提议表决,有过半接受者接受的投票win</li>
<li>Learner:学习者无投票权,只能从Proposor获知那个提议被选中</li>
</ul>
</blockquote>
<p>目标：</p>
<ul>
<li>多个节点可以提出提议</li>
<li>系统必须针对多个提议中的某个达成一致,且最多只有一个</li>
<li>只要超过半数的节点存活且可以相互通信,那么整个系统一定能达成一致,即选择一个确定提议</li>
</ul>
<p>分为两个阶段<br>
prepare 阶段</p>
<ul>
<li>proposor 向所有节点发送proposal,携带有当前 递增的prepareTimeStamp(PT) ,等待一半的节点回复(加上自己超过一半)
<ul>
<li>前提:节点 本身保存三个参数 lastPrepareTimestamp(LPT),lastAcceptedTimeStamp(LAT),lastAcceptValue(LAV)</li>
<li>情况1:节点没有收到任何提议,即LPT为空,则设置该PT为LPT并response,同时不会再返回任何PT小于等于该LPT的提议</li>
<li>情况2:节点存在LPT,且LPT &gt;= PT,那么节点不回复(等待超时即可)</li>
<li>情况3:节点存在LPT且LPT &lt; PT,那么节点更新LPT,返回 之前的LPT 和LAT LAV</li>
</ul>
</li>
<li>proposor没有收到过半的回复,那么结束,收到则进行下一阶段</li>
</ul>
<p>accept 阶段</p>
<ul>
<li>节点收到了过半的回复,但是其中可能多个回复同时携带 LPT LAT LAV
<ul>
<li>情况1:不存在回复携带LPT LAT LAV,那么该节点赢得胜利,可以向所有节点发送下一步(是上一次的节点)的值</li>
<li>情况2:存在回复带有 LPT LAT LAV ,那么从中找到LPT最大的那么的LAV作为自己的AV,然后广播</li>
</ul>
</li>
<li>如果接收到过半的回复,那么成功提交,告知学习者学习</li>
</ul>
<p>理解1：</p>
<blockquote>
<p>该协议的场景是多个平等节点间同时对一个值发起更改之后,需要确保值的一致性<br>
可以确保值的一致性,但不能保证同一区间内的操作满足时间顺序</p>
</blockquote>
<p>PAXOS 活锁问题</p>
<blockquote>
<p>两个proposor在prepare阶段有交集,而他们反复抢夺交集的归属权,导致尝试-失败-尝试的循环<br>
解决:在失败过后引入随机等待时间</p>
</blockquote>
<p>BASIC PAXOS<br>
推导过程 详见参考1<br>
首先起码分为两步走,第一步用于确认有一半以上的节点同意,其次才处于执行阶段</p>
<ol>
<li>单proposor 没有任何问题</li>
<li>2 proposor:可能会出现一个acceptor 接受了两个proposor的情况,所以要么阻止多个proposor发出,要么阻止acceptor接受
<ul>
<li>阻止发出:那么必须需要通知到每个节点,要求比较高,难以保证每个节点都可以接收到;而且难以保证及时性</li>
<li>阻止接受:可以限定必须接收到一半以上的acceptor回复,那么必然两个 proposor 的acceptor 必然有交集,可以进一步限制只能接受一个proposor,同时需要保证第一步不能写入数据,否则会出现数据不一致的现象(类似于二阶段提交协议)
<ul>
<li>首先限定proposor的占有规则,对于任何一个节点
<ul>
<li>FCFS: 但是如果accept本身也是提议者即3个proposor,那么将永远达不成一致
<ul>
<li>任何情况下的单纯一次性确定都会导致 2个以上proposor存在时,很大可能达不成一致 =&gt; 可修改</li>
<li>决定负责不应该包含局部的特性,不然无法比较,由全局的特性决定,使得节点能够加以区分和比较,保证全局最终结果的一致性 =&gt; 使用全局自增ID(或者 ip+本地时间)来比较</li>
</ul>
</li>
<li>最大者/最近者优先: 可能导致波动,对于ID_A &lt; ID_B 是否接受与到达顺序相关
<ul>
<li>首先接收到ID_B 可以拒接ID_A</li>
<li>但可能出现节点依次接受并返回,导致出现在两个proposor那出现该节点同时同意的情况;即使在接受更大的之后,节点转而通知之前的节点,也不能保证一定到达以及在其进行第二阶段时到达</li>
</ul>
</li>
<li>最小者/最先者优先: 网络原因导致波动
<ul>
<li>由于网络原因导致较小的慢到达,同样出现上述情况</li>
</ul>
</li>
<li>对于后两种情况,可能出现节点无法拒绝任何一个proposal的情况,所以可以协调两个proposal表现一致来达到一致性 =&gt; 最大者优先 + FCFS =&gt; <code>对于后来的预提案,只有其id大于已有ID才可以占有之,也不会接受小于该id 的提案,而且会反馈预提案拥有者 之前已接收的提案内容</code></li>
</ul>
</li>
<li>协调意味着两proposal只能选择一个proposal,更改一个proposal的值(如何更改?主动询问所有节点,耗时且增加环节带来的错误情况处理 或者 由该节点通知,即使收不到也被proposal视为不同意 无不良后果), 如何协调 ID_A &lt; ID_B 顺序访问情况下值的一直</li>
<li>定义占有规则:<code>对于节点,如果其首先接受了预提案,后续的预提案如果id小于现有的id,那么拒绝该提议,也拒绝小于该id的提案,如果大于它,那么接受该提议,同时告诉该提议者自己已经接受了的提案的信息(包括id以及value),而提议者接收到该信息会更新自己的value为反馈的proposal中 id 最大的那个的value; 这样可以保证新的提案与已经被接受的旧提案保持一致,需要证明的是为何选择最大的可以保证一致性</code>
<ul>
<li>证明：对于两个存在proposal A B到达执行阶段,那么那个交集的点必然是 小的ID先到,然后ID较大的到,所以较大的ID的提议者会修改自己value,保持最终值的一致性</li>
<li>如果超过3个proposal,假设对于反馈中的proposalA 和 proposalB 其中 IDA &lt; IDB,而两个提案都存在意味着两者在预提案阶段都接受到超过半数的同意反馈,那么两者必然有交集,对于交集中的节点S,其预提案的到来顺序必然是IDA IDB,如果到达时该节点接受提案,那么该节点会更新自己的id,拒绝后续较小的IDA的提案,如果已经接受,IDB发出的节点必然修改了自己的value为IDA的值,所以最终会保持一致性</li>
</ul>
</li>
<li>如果接受到大部分的acceptor,那么向这些acceptor发送提案,对于每个节点,如果接受的提案&gt;=本身的预提案id,那么可以接受它,同时更新该节点接受的id,并反馈</li>
<li>如果接受到了超过半数的acceptor回复,那么就说明该次提议完成并会发布消息到learner,告知学习(在论文中没有具体提及其角色,可以猜测起作用:广播禁止下一次对该key的proposal;更新其他节点的值)</li>
</ul>
</li>
<li>活锁(livelock)问题:不断有新的proposal在怕热proposal阶段 抢占节点,导致一直无法达成协议</li>
<li>多数读/写/<a href="https://blog.csdn.net/tb3039450/article/details/80249664" target="_blank" rel="noopener">Quorum机制</a>:写时节点的数+读时节点的数&gt;总节点的数,可以保证读到最新值;而设置写节点的数目为超过半数可以保证半数的节点宕机也可以保证服务的可用性</li>
</ul>
</li>
</ol>
<p><a href="http://oceanbase.org.cn/?p=111" target="_blank" rel="noopener">使用Multi-Paxos协议的日志同步与恢复</a><br>
MUTLI PAXOS</p>
<ul>
<li>通过一轮 basic paxos 获得leader ,所以不需要pre阶段的一次rpc 因为 无人竞争
<ul>
<li>由leader发布proposal 避免了活锁问题;</li>
<li>每个leader时期的proposalID是不变的,但是instanceId是变化的,由于每次只要求写入半数的节点可能导致空洞的出现</li>
</ul>
</li>
<li>由于网络等原因可以出现多leader的情况</li>
</ul>
<p><a href="http://blog.itpub.net/31509949/viewspace-2218253/" target="_blank" rel="noopener">ZAB</a></p>
<blockquote></blockquote>
<p><a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/Zab+vs.+Paxos" target="_blank" rel="noopener">ZAB VS PAXOS</a><br>
相同点：</p>
<ul>
<li>由leader发布提案 follower接受,然后等待法定人数的认可之后通知learner</li>
<li>同一个leader的提案共享一个proposalID但是instanceID不同(标识该leader提议的key值次数)</li>
</ul>
<p>不同：ZAB目的在于实现高可用的分布式数据库(主从模式),而paxos目的在于构建一个分布式一致的状态机系统</p>
<ul>
<li>multi-PAXOS有两个阶段选举和执行事务,而ZAB在两个阶段之间插入恢复阶段,目的在于使follower节点与leader节点的数据保持一致</li>
</ul>
<h2 id="tencent-data-wire">Tencent Data Wire</h2>
<p>TDW是腾讯最大的离线数据处理平台<br>
TDW 是基于Hadoop和Spark 构建,<br>
<a href="http://www.ha97.com/5665.html" target="_blank" rel="noopener">参考1</a><br>
<a href="https://cloud.tencent.com/developer/article/1029640" target="_blank" rel="noopener">参考2</a></p>
<h3 id="反射">反射</h3>
<p>反射允许动态的根据类名去获取class对象,并且实例化并调用其方法和对象(甚至更改对象的访问权限)<br>
其原理是根据class对象的读取,javac编译后 的文件包括 构造函数以及成员函数成员变量<br>
class.forName 默认由所在类的加载器去加载该class<br>
getConstructor<br>
getMethod(变量类型)<br>
method.invoke(instance,参数)</p>
<p>为什么反射会比new慢</p>
<ul>
<li>method.invoke 的参数是可变参数(编译时会将参数封装进object数组,涉及赋值操作)</li>
<li>object数组中不能存储基本变量,涉及自动装箱机制</li>
</ul>
<h3 id="rpc">RPC</h3>
<h4 id="rpc-vs-http">RPC VS HTTP</h4>
<p>优点：</p>
<ol>
<li>传输效率高(二进制传输效率)</li>
<li>调用方向调用本地方法一样调用,无需关心实现<br>
缺点：</li>
</ol>
<ul>
<li>通用性不如HTTP好(因而rpc一般用于内部服务之间的通信调用,http一般用于跨服务的调用)</li>
</ul>
<p>过程：</p>
<ol>
<li>客户端(client)以本地调用的方法发起调用</li>
<li>客户端桩(client stub) 收到调用,负责 将调用的方法参数等必要信息序列化(压缩打包)传输,将之发送给服务端</li>
<li>服务端桩(server stub) 接收到网络数据,反序列化,获取方法名和参数等必要信息</li>
<li>服务器桩根据方法名和参数进行本地调用</li>
<li>服务端执行调用返回结果给服务器桩</li>
<li>服务器桩接收到结果,序列化,传输给客户端</li>
<li>客户端桩接收到信息,反序列化,解析返回给客户端</li>
<li>客户端获得调用结果</li>
</ol>
<p>核心：</p>
<ol>
<li>消息协议(以下是RPC 二进制协议中的,http中包括XML和Json)
<ul>
<li>Protobuf</li>
<li>Avro</li>
</ul>
</li>
<li>传输机制：基于tcp协议的可靠性,使用tcp传输数据
<ul>
<li>服务端 建立socket 监听</li>
<li>客户端 建立socket 连接服务端,通过3次TCP握手建立连接,然后可以传输数据</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/31/工作求职/后端/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/31/工作求职/后端/" class="post-title-link" itemprop="url">后端</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-31 09:52:45" itemprop="dateCreated datePublished" datetime="2020-08-31T09:52:45+08:00">2020-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-15 10:58:05" itemprop="dateModified" datetime="2021-01-15T10:58:05+08:00">2021-01-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>后端优化的路径</li>
</ol>
<ul>
<li>服务器 硬件资源升级</li>
<li>缓存化</li>
<li>sql优化(分库分表),逻辑优化</li>
<li>服务化(拆分服务)</li>
<li>异步化请求</li>
</ul>
<ol start="2">
<li>HTTP</li>
</ol>
<ul>
<li>GET: 获取信息,幂等操作</li>
<li>POST：修改资源,非幂等操作</li>
<li>PUT：新建资源,幂等操作,重复操作直接替换资源</li>
<li>DELETE：删除资源</li>
</ul>
<ol start="3">
<li>LRU算法的实现</li>
</ol>
<ul>
<li>链表操作:新建以及再访问 移动到 头部</li>
<li>基于时间戳的比较</li>
</ul>
<ol start="4">
<li>CPU 私用率过高</li>
</ol>
<ul>
<li>io使用率？内存利用率？
<ul>
<li>文件操作 频繁GC? jstat -gc 进程ID 间隔时间  java -XX:+PrintGCDeatils</li>
</ul>
</li>
<li>纯后端服务还是Web服务
<ul>
<li>是否陷入计算部分</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/30/工作求职/腾讯/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/30/工作求职/腾讯/" class="post-title-link" itemprop="url">腾讯 求职</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-30 13:30:09" itemprop="dateCreated datePublished" datetime="2020-08-30T13:30:09+08:00">2020-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-15 10:57:49" itemprop="dateModified" datetime="2021-01-15T10:57:49+08:00">2021-01-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="后台面试参考流程-上">后台面试参考流程-上</h1>
<h2 id="编程语言">编程语言</h2>
<ul>
<li>
<p>C++</p>
<ol>
<li>static 关键字有哪些用法？</li>
<li>继承层次中,为什么基类析构函数是虚函数？</li>
<li>重载overload、覆盖重写override、隐藏重定义overwrite 的区别：</li>
</ol>
<blockquote>
<p>overload：同名 不同参数的函数,多态<br>
override: 重写父类的方法<br>
overwrite：实现abstract 方法或者接口</p>
</blockquote>
<ol start="4">
<li>多态和泛型的实现原理？<a href="https://developer.aliyun.com/article/138749" target="_blank" rel="noopener">参考</a></li>
</ol>
<blockquote>
<p>泛型:其本质是参数化类型,多态:模糊子类和父类的关联,是的同一个行为有不同的表现<br>
泛型的应用:<code>Map&lt;String,String&gt;等</code>,保证 类型安全,消除强制类型转换<br>
实现原理:泛型是在编译 阶段进行 将泛型,替换成实际类型,而多态是在实际运行阶段 实现类型替换</p>
</blockquote>
<ol start="5">
<li>stl的 map/vector 实现场景,迭代器 失效场景?</li>
</ol>
</li>
</ul>
<h2 id="linux-开发">Linux 开发</h2>
<ol>
<li>程序出问题时的解决思路?使用哪些调试工具? 比如gdb/valgrind/strace/tcpdump</li>
</ol>
<blockquote>
<p>整体思路：问题类型单个接口错误(查询log),普遍接口错误(全局配置/公共模块问题,权限问题),服务崩溃(服务器问题,资源不足？),延迟大(的确资源不足,死循环)<br>
日志,/proc 下 或top命令 观察进程的内存延迟CPU等资源的使用情况,或者可以使用gdb工具调试c++程序</p>
</blockquote>
<ol start="2">
<li>有哪些工具可以找到性能瓶颈?</li>
</ol>
<blockquote>
<p>Jmeter 压测机 发出请求<br>
工具1:Java Mission Control,其核心 是 Java Flight 记录器,一个内置在 JDK 中的监测和事件收集框架。收集的事件包括：磁盘 IO、GC、线程 sleep、线程 wait、Socket read/write 等,可以从不同角度更好分析当前进程运行情况<br>
工具2:Tprofiler,淘宝开源工具,在 JVM 启动时把时间采集程序注入到字节码中,整个过程无需修改应用源码，可以配置采样评率去降低影响</p>
</blockquote>
<ol start="3">
<li>了解vmstat/iostat/netstat/mpstat吗？用来作什么？</li>
</ol>
<blockquote>
<p>top:能够实时监控系统的运行状态，并且可以按照cpu、内存和执行时间进行排序,也可以显示整个系统的资源现状<br>
free:监控系统内存最常用的命令,包含 总内存大小,已用,共享内存大小,磁盘缓存大小等<br>
ps： 查询进程信息,启动者,父进程,启动命令,启动时长等信息<br>
vmstat:监控操作系统的进程状态、内存、虚拟内存、磁盘IO、上下文、CPU的信息。<br>
iostat:是对系统磁盘IO操作进行监控，它的输出主要显示磁盘的读写操作的统计信息<br>
netstat:用于显示本机网络链接、运行端口、路由表等信息<br>
mpstat可以监控到cpu的一些统计信息，在多核cpu的系统里不但能够查看所有cpu的平均状况信息，而且能够查看特定的cpu的信息</p>
</blockquote>
<h2 id="网络">网络</h2>
<ol>
<li>select/epoll的区别？</li>
</ol>
<blockquote>
<p>简单理解：当进程进行IO调用时，select poll 都把该进程挂在该设备的等待队列后，然后遍历等待队列，直至发现就绪，区别在于select使用数组来存储文件描述符，因而长度有限，而poll使用链表存储，因而没有这个限制;而epoll将状态分离开来，单独分出一个就绪队列，每次遍历这个就绪队列，然后根据队列中的信息进行下一步</p>
</blockquote>
<ol start="2">
<li>
<p>epoll 的ET 和 LT的区别？<br>
边缘触发(Edge Trigger)和水平触发也叫条件触发(Level Trigger)<br>
边缘触发 是指每当状态变化时发生一个io事件；<br>
条件触发 是只要满足条件就发生一个io事件；<br>
LT模式下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作，而在ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无 论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读光，也就是说一直读到read的返回值小于请求值，或者 遇到EAGAIN错误</p>
</li>
<li>
<p>epoll 如何区分 connect/close/read/write 事件?</p>
</li>
<li>
<p>TCP 的流量控制和阻塞控制有什么区别？描述下慢启动/拥塞避免/快速恢复/快速重传?</p>
</li>
</ol>
<blockquote>
<p>流量控制的目的在于控制发送发的速率,使得接收方可以及时接收;通过确认报文照片中的窗口字段和滑动窗口机制控制发送方的速率<br>
拥塞控制的目的在于防止过多的数据注入到网络中，这样可以使网络中的路由器或链路过载(拥塞会导致发送失败,失败方会重新发送,加剧了拥塞程度);拥塞控制有四种算法:慢开始,拥塞避免,快重传和快恢复算法<br>
接收方总是有足够大的缓存空间，因而发送窗口的大小由网络的拥塞程度决定<br>
慢开始:令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将cwnd加倍<br>
拥塞避免: 当cwnd &gt;= 慢开始门限值,执行该算法,每一次ACK,cwnd+1(当网络超时时,令ssthresh=cwnd/2,同时设置拥塞窗口cwnd=1.进入慢开始算法)<br>
快重传:要求接收方不要等待自己发送数据才进行捎带确认，而是立即发送确认;即使收到失序的报文段对已发送的报文段的重复确认。发送方一连收到3个重复确认就应当立即进行重传。在这种情况下，只是丢失个别报文段，而不是网络拥塞。从而执行快恢复<br>
快速恢复: 发送方调整门限值ssthresh =cwnd/2，同时设置拥塞窗口cwnd=ssthresh ，并开始拥塞避免算法</p>
</blockquote>
<ol start="5">
<li>TIME_WAIT,CLOSE_WAIT 产生的原因和解决方案?</li>
</ol>
<blockquote></blockquote>
<ol start="6">
<li>HTTPS 的工作原理？</li>
</ol>
<blockquote>
<p><a href="http://www.httpclient.cn/archives/59.html" target="_blank" rel="noopener">参考网站1</a><br>
HTTPS:Hyper Text Transfer Protocol over SecureSocket Laye<br>
动机：认证正在访问的网站(CA证书);保证所传输数据的私密性和完整性<br>
HTTPS 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段(非对称加密安全但是耗时)<br>
工作流程:</p>
</blockquote>
<ul>
<li>认证服务器：浏览器内置受信任的CA机构列表以及相应机构的证书,如果认证服务端合理,就可以从 服务端或者到 <code>公钥</code></li>
<li>协商会话秘钥：浏览器通过公钥 和服务端 协商(非对称加密) 获取 加密 服务端-客户端 和 客户端-服务端 的两个会话秘钥(与会话相关)</li>
<li>加密通讯:通过对称加密 加密数据,保证安全和效率</li>
</ul>
<ol start="7">
<li>
<p>网关的作用：请求异步化</p>
</li>
<li>
<p>网格计算<br>
分布式计算的一种,将计算任务分发到多个有计算资源的机器上,然后将他们计算的结果统一整理</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/29/基础知识/工具网站/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/29/基础知识/工具网站/" class="post-title-link" itemprop="url">工具网站</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-29 09:57:50" itemprop="dateCreated datePublished" datetime="2020-08-29T09:57:50+08:00">2020-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-30 13:25:24" itemprop="dateModified" datetime="2020-08-30T13:25:24+08:00">2020-08-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>latex：</p>
<ul>
<li><a href="https://www.overleaf.com/" target="_blank" rel="noopener">latex 在线编辑和导出</a></li>
<li><a href="https://www.tablesgenerator.com/latex_tables" target="_blank" rel="noopener">latex table在线编辑和转换</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="夸父"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">夸父</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">108</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">59</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/walkdeadtobe" title="GitHub → https://github.com/walkdeadtobe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">京ICP备2020045262号 </a>
      <img src="/images/gongan.png" style="display: inline-block;"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010802033764" rel="noopener" target="_blank">京公网安备 11010802033764 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chengr</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
