<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/">





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/29/基础知识/工具网站/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/29/基础知识/工具网站/" itemprop="url">工具网站</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-29T09:57:50+08:00">
                2020-08-29
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-08-30T13:25:24+08:00" content="2020-08-30">
                2020-08-30
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>latex：</p>
<ul>
<li><a href="https://www.overleaf.com/" target="_blank" rel="noopener">latex 在线编辑和导出</a></li>
<li><a href="https://www.tablesgenerator.com/latex_tables" target="_blank" rel="noopener">latex table在线编辑和转换</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/28/工作求职/数据库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/28/工作求职/数据库/" itemprop="url">数据库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-28T18:59:47+08:00">
                2020-08-28
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-11-03T14:19:16+08:00" content="2020-11-03">
                2020-11-03
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据库">数据库</h1>
<h2 id="reids">Reids</h2>
<p><a href="http://redisbook.com/preview/dict/incremental_rehashing.html" target="_blank" rel="noopener">参考1</a><br>
<a href="https://zhuanlan.zhihu.com/p/112944545" target="_blank" rel="noopener">参考2</a></p>
<h3 id="基础数据类型">基础数据类型：</h3>
<blockquote>
<p>string，hash，list，set及有序集合（每个元素都关联一个分数，通过分数排序）</p>
</blockquote>
<ul>
<li>string(len,free,char[]):用于计数</li>
<li>list：双向链表,随机定位性能较弱，首尾插入删除性能较优</li>
<li>hash:数组+单链表 hash扩容时使用渐进式的rehash(一个hash结构有两个hash表ht[0]ht[1] ht[1]用于渐进式rehashAB类似于GC里的两个survivor区):较小时使用ziplist 较多采用hashmap
<ul>
<li>在出现哈希冲突时,使用链地址法解决;处于效率考虑,新节点的加入使用头插法</li>
<li>扩容A,首先分配rehash之后的空间结构B,其每次对于</li>
</ul>
</li>
<li>set:无序集合</li>
<li>sortset:链表(value score 的Node)+跳表(log2级索引;二分查找) 对于范围查询，跳表更加高效</li>
</ul>
<p>intset</p>
<h4 id="实现原理">实现原理</h4>
<p>dict实现原理</p>
<blockquote>
<p>基于哈希表的算法，采用拉链法解决冲突，并在装载因子超过预定值时自动扩展，引发重哈希</p>
</blockquote>
<p>SDS:Simple Dynamic String</p>
<blockquote>
<p>string(len,free,char[])</p>
</blockquote>
<p><a href="https://blog.liexing.me/2019/12/28/from-ziplist-linkedlist-to-quicklist/" target="_blank" rel="noopener">ziplist linkedList quickList</a></p>
<ul>
<li>ziplist充分利用空间,将list数据相邻的存储,利用数据结构实现前后节点的遍历(因为是紧挨着所以需要很多字段能够准备读后前后街店的值 对于任何一个可变字段都需要增加标记他长度的字段),但是插入删除的时间消耗比较大,所以一般用于比较少的list数据</li>
<li>对于较长的数据使用linkedlist,删除成本低但是空间碎片多</li>
<li>quickList把ziplist封装为其Node,然后以此为节点,构建LinkedList,综合linkedList和zilist的节约内存以及删除数据高效的特点(quickList配合有压缩和解压缩的能力,删除时进行解压缩和压缩;新插入节点也会如此判断,否则重新创建Node)</li>
</ul>
<p><a href="https://www.cyningsun.com/06-18-2018/skiplist.html#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E5%B1%82%E6%95%B0%EF%BC%9F" target="_blank" rel="noopener">skipList</a></p>
<ul>
<li>定义基于单链表,在Node的结构中增加Node指针的数组,其长度可以称为层数;有越Log(N)的效率</li>
<li>层数：其范围[1-maxvalue],当每次获取的random值大于p时,层数+1,并继续,否则层数确定(这样确保了高层数的分布不会很高)</li>
<li>插入：例如插入E,按照已有跳表查询,在查询中所有经过A-B-C-D找到F节点大于E,那么判断中间经历的所有节点ABCD的value如果小于它且其层数小于等于他,那么就需要指向它,同时他的更高层也要更新指向</li>
<li>删除：例如删除E,同样先经过跳表查询,可以获得E每层的下一个Node,更新遍历过程中相应的节点</li>
<li>为什么不使用红黑树
<ol>
<li>内存不敏感,可以通过降低P来降低内存需求</li>
<li>可以用于范围查询</li>
<li>容易实现</li>
</ol>
</li>
</ul>
<p>hash 当容量和值比较小时使用ziplist,节省空间;增大时改用dict</p>
<h3 id="redis持久化">Redis持久化：</h3>
<blockquote>
<p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失<br>
两种持久化方式:RDB（Redis DataBase；默认；定期备份；把内存中数据写到磁盘以及把文件读到内存；制定的时间间隔生成数据集的快） 和AOF(Append-only file;写入保存两个步骤；WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件 ；SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。持久化记录服务器执行的所有写命令到日志文件，并在服务器重启时，重新执行这些命令来恢复数据)</p>
<blockquote>
<p>两种区别就是，一个是平时写操作的时候不触发写，只有手动提交save命令，或者是关闭命令时，才触发备份操作。一个是持续的用日志记录写操作，crash后利用日志恢复；<br>
选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。</p>
</blockquote>
</blockquote>
<blockquote>
<p>快照的设置:设置redis.conf save 900 1(900秒内 1个key被修改 快照);  dbfilename dump.rdb; dir /opt/redis;  appendonly no</p>
</blockquote>
<h3 id="过期策略定期删除惰性删除内存淘汰机制">过期策略：定期删除+惰性删除+内存淘汰机制</h3>
<blockquote>
<p>定期删除：redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除<br>
惰性删除：当访问key时，检测key是否过期，过期则不返回<br>
内存淘汰机制：当内存不足以写入新数据时，什么都不做，写入报错/移除随机key/移除最近最少使用的key/随机（或者选择最先过期 ）移除有过期时间的key/移除有过期的key中最近最少使用的/</p>
</blockquote>
<h3 id="redis的架构模式">Redis的架构模式</h3>
<blockquote>
<p>单机版（存储，处理有限，无法高可用）<br>
主从复制（读写分离；更新同步；但是master写的压力存在，高可用不行）<br>
哨兵（监控主从模式，遇到故障自动迁移；解决高可用，但master写仍存在）<br>
集群（proxy 型）：利用哈希进行数据分布，分布到多个主从集群+哨兵<br>
集群（直连型）：</p>
<blockquote>
<p>集群（直连型）:<a href="https://blog.csdn.net/z15732621582/article/details/79121213" target="_blank" rel="noopener">简介</a>  和 <a href="https://www.cnblogs.com/lpfuture/p/5796398.html" target="_blank" rel="noopener">一致性Hash算法</a><br>
Redis集群预分好16384个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中<br>
节点的fail是通过集群中超过半数的节点检测失效时才生效</p>
</blockquote>
</blockquote>
<h3 id="相关概念">相关概念</h3>
<h4 id="缓存雪崩">缓存雪崩</h4>
<blockquote>
<p>描述：大量相同过期时间的缓存，同时失效，导致大量的并发访问失败并访问磁盘；<br>
解决：使用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写</p>
</blockquote>
<h4 id="缓存穿透">缓存穿透</h4>
<blockquote>
<p>描述：用户在查询一个持久层数据库也没有的数据时，会出现缓存未命中，且访问持久层无果的情况，大量这种类型的访问会给持久层数据库带来很大压力<br>
解决：利用布隆过滤器判断对象是否一定不存在；缓存空对象</p>
</blockquote>
<h4 id="缓存击穿">缓存击穿</h4>
<blockquote>
<p>描述；指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞<br>
解决：定时更新;多级缓存;失效时使用互斥锁,限制对于数据库的访问</p>
</blockquote>
<h4 id="缓存预热">缓存预热</h4>
<blockquote>
<p>描述：相关的缓存数据直接加载到缓存系</p>
</blockquote>
<h4 id="缓存更新">缓存更新</h4>
<blockquote>
<p>除了缓存失效策略（定义失效时间）外，还有定时去清理过期的缓存策略（判断是否失效）以及访问时才判断是否失效</p>
</blockquote>
<h4 id="缓存降级">缓存降级</h4>
<blockquote>
<p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级，保证核心服务可用</p>
</blockquote>
<h4 id="热点数据和冷数据">热点数据和冷数据：</h4>
<blockquote>
<p>频繁访问修改的数据称之为热点数据；冷数据指访问间隔很长的数据（出现只访问一次，就被挤出内存的情况）</p>
</blockquote>
<h4 id="单线程的redis为什么这么快">单线程的redis为什么这么快</h4>
<blockquote>
<p>纯内存操作<br>
单线程操作，避免了频繁的上下文切换<br>
采用了非阻塞I/O多路复用机制 epoll</p>
</blockquote>
<h4 id="redis到底是多线程还是单线程">Redis到底是多线程还是单线程</h4>
<blockquote>
<p>单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程,基于IO多路复用</p>
</blockquote>
<h4 id="redis关于线程安全问题">Redis关于线程安全问题</h4>
<blockquote>
<p>Redis实际上是采用了线程封闭的观念，把任务封闭在一个线程，自然避免了线程安全问题，不过对于需要依赖多个redis操作的复合操作来说，依然需要锁，而且有可能是分布式锁。</p>
</blockquote>
<h4 id="redis-内部实现">Redis 内部实现</h4>
<blockquote>
<p>内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间 这3个条件不是相互独立的，特别是第一条，如果请求都是耗时的，采用单线程吞吐量及性能可想而知了。应该说redis为特殊的场景选择了合适的技术方案。</p>
</blockquote>
<h4 id="memcache-vs-redis">Memcache VS Redis</h4>
<blockquote>
<p>(1)存储方式 ：Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，redis可以持久化其数据<br><br>
(2)数据支持类型 memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 ，提供list，set，zset，hash等数据结构的存储<br><br>
(3)使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。<br><br>
(4)value 值大小不同：Redis 最大可以达到 512M；memcache 只有 1mb。<br><br>
(5)redis的速度比memcached快很多<br><br>
(6)Redis支持数据的备份，即master-slave模式的数据备份。<br><br>
Redis key和value的大小限制：512MB</p>
</blockquote>
<h4 id="redis数据库的数据一致性">Redis数据库的数据一致性</h4>
<blockquote>
<p>主从同步：从服务器启动，会向主服务器发起sync命令；主服务器收到后会在后台保存快照（RDB操作），并缓存保存期间的命令；结束后，会将快照和缓存命令传递给从数据库，从数据库接收到后，会载入快照并执行缓存命令；</p>
<p>哈希槽算法：与一致性哈希算法相似，一个节点根据其存储量，分为若干个槽<br>
一致性哈希算法：在0-2^32-1的哈希环,将已有的机器根据ip等因素hash到某个位置,把哈希环 分割成好几块,每个机器负责一块的数据,这样机器数量的变化(宕机或者新增只会影响一部分数据),同时可以是用虚拟主机的方法,解决数据倾向存储在某一个机器的问题.<br>
全量复制，增量复制，异步复制</p>
</blockquote>
<h4 id="哨兵模式"><a href="https://blog.csdn.net/sz85850597/article/details/86751215" target="_blank" rel="noopener">哨兵模式</a></h4>
<blockquote>
<p>主观下线-&gt;客观下线<br>
sential leader 选举：当每一个发现redis master 的sential节点都可以向其他节点发送选举信号，每个接收到该信号的节点如果没有投票，可以投它，当达到最低票数时，正式成为sential leader；否则进行下一轮；<br>
redis master 选举：由 sential leader 选择redis集群中的某个节点作为master</p>
<blockquote>
<p>a.排除故障节点</p>
</blockquote>
<blockquote>
<p>b.选择节点中slave-priority最大的从节点作为主节点</p>
</blockquote>
<blockquote>
<p>c.选择择复制偏移量（数据写入量的字节，记录写了多少数据。主服务器会把偏移量同步给从服务器，当主从的偏移量一致，则数据是完全同步）最大的从节点作为主节点</p>
</blockquote>
<blockquote>
<p>d.选择runid（redis每次启动的时候生成随机的runid作为redis的标识）最小的从节点作为主节点</p>
</blockquote>
</blockquote>
<h4 id="redis-集群选举">redis <a href="https://www.cnblogs.com/nijunyang/p/12508098.html" target="_blank" rel="noopener">集群选举</a></h4>
<blockquote>
<p>背景：利用hash桶算法进行数据的分隔布置到多个主从模式服务器去<br>
选举：slave发现master Fail之后，就尝试选举</p>
<blockquote>
<p>a.增加currentEpoch加1，并广播FAILOVER_AUTH_REQUEST信息</p>
</blockquote>
<blockquote>
<p>b.收到信息的Master节点会判断请求者的合法性，并发&gt;送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack</p>
</blockquote>
<blockquote>
<p>c.尝试failover的slave收集FAILOVER_AUTH_ACK;超过半数后变成新Master;广播Pong通知其他集群节点</p>
</blockquote>
</blockquote>
<h2 id="mysql">Mysql</h2>
<h3 id="事务的基本要素">事务的基本要素</h3>
<blockquote>
<p>原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。<br><br>
一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏。<br><br>
隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。<br><br>
持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚</p>
</blockquote>
<h3 id="事务的并发问题">事务的并发问题</h3>
<blockquote>
<p>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据<br><br>
不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。<br><br>
丢失修改：两个事务AB修改顺序颠倒,A后发先修改,A的修改被B的修改覆盖,导致修改丢失<br>
幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读.<br><br>
小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表<br></p>
</blockquote>
<h3 id="事物隔离级别">事物隔离级别</h3>
<p>| 事务隔离级别  | 脏读  | 不可重复  | 幻读 |方法<br>
| :----- | -----: | -----: | -----: |<br>
|   读未提交（read-uncommitted）    | 是      |  是     | 是      |<br>
|    读已提交（read-committed）   |   否    | 是     | 是 |<br>
|    可重复读（默认，repeatable-read）   | 否  |否 | 是 |<br>
|    串行化（serializable）    |   否    | 否 |否 |   每个事务依次提交(SELECT变成SELECT … LOCK IN SHARE MODE)</p>
<h3 id="存储引擎">存储引擎</h3>
<blockquote>
<p><a href="https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_10409517059295814828%22%7D&amp;n_type=1&amp;p_from=4" target="_blank" rel="noopener">参考</a><br>
存储引擎是数据库管理系统用来从数据库创建、读取和更新数据的软件模块<br>
mysql5.5之后默认使用事务性存储引擎 InnoDB(这是MySQL 5.5或更高版本的默认存储引擎。它提供了事务安全(ACID兼容)表，支持外键引用完整性约束。它支持提交、回滚和紧急恢复功能来保护数据。它还支持行级锁定。当在多用户环境中使用时，它的“一致非锁定读取”提高了性能。它将数据存储在集群索引中，从而减少了基于主键的查询的I/O)</p>
</blockquote>
<h4 id="innodb">InnoDB</h4>
<blockquote>
<p>在 InnoDB 存储引擎中，所有的数据都被逻辑地存放在表空间中，表空间（tablespace）是存储引擎中最高的存储逻辑单位，在表空间的下面又包括段（segment）、区（extent）、页（page）<br><br>
MySQL 使用 InnoDB 存储表时，会将表的定义和数据索引等信息分开存储，其中前者存储在 .frm文件中，后者存储在 .ibd 文件中<br></p>
</blockquote>
<h3 id="索引">索引</h3>
<blockquote>
<p>索引优化是对查询性能优化的最有效手段<br>
在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单<br>
InnoDB 存储引擎在绝大多数情况下使用 B+ 树建立索引，这是关系型数据库中查找最为常用和有效的索引</p>
</blockquote>
<blockquote>
<p>一张表一定包含一个聚集索引构成的 B+ 树以及若干辅助索引的构成的 B+ 树（辅助索引的存在并不会影响聚集索引，因为聚集索引构成的 B+ 树是数据实际存储的形式，而辅助索引只用于加速数据的查找，所以一张表上往往有多个辅助索引以此来提升数据库的性能。）</p>
</blockquote>
<h4 id="mysql-索引分类">mysql 索引分类</h4>
<p>b+树索引 hash索引</p>
<blockquote>
<p>主键索引：以唯一能够标识记录中某一行的属性或者属性组 作为唯一索引,不为空<br>
唯一索引：唯一索引的值必须唯一,但允许有空值(NULL代表未知,不违反唯一性约束);对于组合索引,组合必须唯一<br>
普通索引：普通的索引用于加快访问速度,其根节点指向主键<br>
全文索引：某些字符串类型字段的倒排索引(映射单词和所在文档的位置)<a href="https://www.cnblogs.com/wxzhe/p/9955534.html" target="_blank" rel="noopener">全文索引的原理及定义</a></p>
</blockquote>
<p>主键索引 VS 唯一索引</p>
<blockquote>
<p>主键索引必然是唯一索引,唯一索引不一定是主键索引;<br>
主键不允许空,唯一索引允许<br>
主键可以作为外键存在,而唯一索引不行<br>
对于一张表来说,主键索引只有一个,唯一索引可以有多个</p>
</blockquote>
<p>主键索引的插入和删除可能会造成页的分裂和合并,所以一般建议使用自增ID作为主键</p>
<p>唯一索引的用处:</p>
<blockquote>
<p>确保属性值唯一,比如对于网站而言,利用手机号,邮箱注册账号,必然希望其唯一<br>
唯一索引在插入时会检验是否出现重复,仍然基于B+树实现判断,但是对于NULL值特殊处理直接返回false</p>
</blockquote>
<h4 id="冗余索引">冗余索引</h4>
<blockquote>
<p>冗余索引指索引的功能相同,两者都可以被命中, 比如索引<a>与<a b> 冗余</a></a></p>
</blockquote>
<h4 id="聚集索引-和-辅助索引-聚簇索引-和非聚簇索引">聚集索引  和  辅助索引 /聚簇索引 和非聚簇索引</h4>
<blockquote>
<p>聚合索引可以理解为基于主键的索引，数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引,其叶子节点是数据节点；而附注索引是对于其他键的索引，最终叶子节点内容为指向数据块的引；<br><br>
主键(指定主键或者选择费控的合适键或者隐藏键uuid)<br>
聚簇索引即值按照表的主键构建一颗b+树,同时叶子节点中存放的是id和表的行记录在数据页中的索引;这个特性决定了索引组织表中数据也是索引的一部分，每张表只能拥有一个聚簇索引<br>
Innodb通过主键聚集数据，如果没有定义主键，innodb会选择非空的唯一索引代替。如果没有这样的索引，innodb会隐式的定义一个主键来作为聚簇索引<br>
聚簇索引的优点：</p>
</blockquote>
<ul>
<li>数据访问更快,因为聚簇索引将索引和数据保存在同一个B+树中</li>
<li>聚簇索引对于主键的排序查找和范围查找速度非常快<br>
缺点:</li>
<li>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键</li>
<li>更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。</li>
<li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据</li>
</ul>
<p>辅助索引：</p>
<blockquote>
<p>在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值</p>
</blockquote>
<h4 id="回表-索引覆盖-复合索引-索引下推">回表 索引覆盖 复合索引 索引下推</h4>
<blockquote>
<p>回表查询，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低<br>
索引覆盖:当所需要的结果都在索引上时,就可以一次查询得到结果<br>
索引下推：index condition pushdown/IPC：在使用IPC的情况下,对于某些查询只能命中索引前部分,同时涉及后部分的判断条件时,mysql server 同时会将判断条件传递给存储引擎,然后存储引擎在检索的同时判断,返回结果(比如对于SELECT * from user where  name like ‘陈%’ and age=20 能够命中索引&lt;name,age&gt;的name 部分 使用IPC可以同时传递条件)<br>
两个或更多个列上的索引被称作复合索引，最左匹配原则，键&gt;=2</p>
</blockquote>
<h3 id="数据库主从同步">数据库主从同步</h3>
<blockquote>
<p><a href="https://www.cnblogs.com/syncnavigator/p/10189597.html" target="_blank" rel="noopener">流程参考</a><br>
首先必须打开master端的binlog (mysql-bin.xxxxxx)日志功能，否则无法实现mysql的主从复制。因为mysql的整个主从复制过程实际上就是：slave端从 master端获取binlog日志，然后再在自己身上完全顺序的执行该日志中所记录的各种SQL操作</p>
<ol>
<li>master在执行sql之后,将数据改变记录二进制log文件(bin-log)</li>
<li>Slave 的IO进程连接上master,并请求同步指定的日志文件的指定位置之后的记录</li>
</ol>
<ul>
<li>master 端接受到io请求后,负责复制的io进程会返回数据给slave的io进程,也包含binlog的位置以及本次数据其中的位置,方便下次继续</li>
<li>slave接受到数据后会追加到slave的relay log末端,并记录master端binlog文件的路径和文件内位置记录到master_info中,已便下次可以清晰告知master从哪里开始</li>
</ul>
<ol start="3">
<li>slave端 的sql进程检测到relay文件的变动会解析文件执行master端已经执行的操作</li>
</ol>
<blockquote>
<p>2.slave连接master，并从master获取binlog，存于本地relay-log中，然后从上次记住的位置起执行SQL语句，一旦遇到错误则停止同步。</p>
</blockquote>
</blockquote>
<h3 id="数据一致性">数据一致性</h3>
<p><a href="https://www.jianshu.com/p/790a158d9eb3" target="_blank" rel="noopener">参考链接</a></p>
<blockquote>
<p>三种同步写模式：异步复制、半同步复制、全同步复制<br>
异步复制:Mysql 默认同步模式,主库在执行完客户端提交的事物之后会直接将结果返回给客户端,不管 从库是否接收同步并成功处理,在这种情况下,主库如果crash掉,从库提升为主库,那么可能出现从库数据不完备的现象<br>
半同步复制:在前者的基础上要求 至少一个从库同步成功,才会将保存在binlog中的操作,提交到存储引擎,返回结果给客户端<br>
全同步复制:在异步复制的基础上,要求 所有从库 都同步成功,才真正执行事物，返回给客户端<br>
相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP/IP往返的时间。所以，半同步复制最好在低延时的网络中使用。<br>
半同步复制和全同步复制 可能会出现 从库执行成功而 主库 执行失败的情况，导致 数据不一致</p>
</blockquote>
<h3 id="mvcc">MVCC</h3>
<p><a href="https://blog.csdn.net/Waves___/article/details/105295060" target="_blank" rel="noopener">参考0</a><br>
<a href="https://juejin.im/post/6847902218729816071" target="_blank" rel="noopener">参考1</a><br>
<a href="https://blog.csdn.net/whoamiyang/article/details/51901888" target="_blank" rel="noopener">参考2</a><br>
<a href="https://blog.csdn.net/Oooo_mumuxi/article/details/105766335" target="_blank" rel="noopener">参考3</a><br>
<a href="https://blog.csdn.net/weixin_41835916/article/details/81633072" target="_blank" rel="noopener">参考博客1</a><br>
基于乐观锁的思想,通过MVCC 解决了读写并发的问题的问题;<br>
Innodb在行记录的添加了隐藏字段,其中包括</p>
<ul>
<li>修改记录的事务ID(DB_TRX_ID:insert/update/delete)</li>
<li>回滚指针：指向当前记录行的undo log(DB_ROLL_PTR),多个回滚指针行程历史数据链</li>
</ul>
<blockquote>
<p>Innodb 使用ReadView对象来判断事务的可见性(隔离性),Innndb在执行select 查询时创建ReadView对象,配合undo log 的版本链 查询可见数据<br>
对于read commited ,每个快照读操作都有自己的ReadView,而对于repeated read ,ReadView与事务相关,事务中的读操作共享一个readView;<br>
readView：trx_list(生成时正在活跃的事务列表) up_limit_id(创建时活跃的最小的事务id) low_limit_id(创建时未分配的最小的事务ID,即此时最大事物id+1) 创建readView的事务ID<br>
当前事务尝试读取数据时,会执行一下判断算法判断记录的可见性</p>
<ol>
<li>把当前记录的修改事务ID赋值给变量x,用以判断是否当前记录是否可见</li>
<li>把 x 与 活跃事务区间进行比较
<ul>
<li>x&lt;最小值,意味着修改的事务 在 创建readView之前已经提交,所以 可见或者x = 当前事务ID ,就是本身修改的,返回数据</li>
<li>x&gt;最大值,说明修改的事务是在 创建readview之后发生的,所以该记录不可见,需要沿着回滚指针指向的undo log,更新x进行下一轮的比较</li>
<li>x 在区间之间,意味着修改的事务可能仍在活跃中,即在readview的活跃列表中 或者 事务已提交 这样的话就需要二分判断该事务是否在列表中,在的话,意味着当前事务未结束,所以该记录不可见,所以同理沿着回滚指针进行下一轮比较;如果不在就意味着 事务在创建readView之前已经提交,那么可见,返回数据</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="mysql-log">Mysql lOG</h3>
<blockquote>
<p>binlog:用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步(用于数据库的基于时间点的还原)<br>
undo log:为了实现事务的原子性,在innodb中与MVCC 配合实现<br>
redo log:目标在于确保事务的持久性;对于innodb的任何修改操作都会首先在buffer pool 缓存页中进行,这样的页可以被标注为dirty然后由专门的purge线程写到磁盘,这样可以避免每次都写的随机IO,直接访问缓存降低了访问的时延,但是可能出现脏页在为写入磁盘时,系统崩溃,修改丢失,所以innodb将所有修改操作写入redo log文件(可覆盖写),在数据库启动时进行恢复操作<br>
errorlog:错误日志记录着mysqld启动和停止,以及服务器在运行过程中发生的错误的相关信息。在默认情况下，系统记录错误日志的功能是关闭的，错误信息被输出到标准错误输出(在开启死锁日志的打印之后，所有的死锁日志都会打印在error log中)<br>
slow query log：通过 记录执行超过一定时间的SQL语句以及没有使用索引的查询语句<br>
general log：记录所以执行的sql,用于排查sql性能,但会增加系统负担,常短期开启分析.<br>
relay log：用于复制中接收方复制binlog<br>
undo log:Innodb引擎的undo日志是记录在表空间中单独的回滚段中。 当mysql做update和delete操作的时候，实际的后台都是先把旧记录“删”了，如果是update和insert再把新记录“插入”进去</p>
</blockquote>
<p>log buffer</p>
<ul>
<li>redo log buffer</li>
<li>undo log buffer</li>
</ul>
<p>binlog VS redolog</p>
<ul>
<li>binglog是服务层的记录sql语句,redolog是存储引擎这一层的记录的是物理操作(页的变更操作)</li>
<li>binlog可用于同步,redolog和binlog配合用于奔溃恢复</li>
<li>binlog是累加的提交事务时写入磁盘,redolog是复写的</li>
</ul>
<p>binlog的刷盘时机 sync_binlog</p>
<ul>
<li>0:不做要求,系统判断比如缓存不足</li>
<li>N：没N个事务就写入磁盘</li>
</ul>
<p><a href="https://www.cnblogs.com/hi3254014978/p/12730794.html" target="_blank" rel="noopener">快照读 vs 当前读</a></p>
<blockquote>
<p>快照读(snapshot read)/一致性读：MVCC实现,普通的 select 语句(不包括 select … lock in share mode, select … for update):确保事务只能读在其之前生效或者自己修改的记录<br>
当前读(current read) ：select … lock in share mode，select … for update，insert，update，delete 语句（这些语句获取的是数据库中的最新数据,加next-key锁</p>
</blockquote>
<h3 id="排序二叉树-gt-平衡二叉树-gt-b-树-gt-b树">排序二叉树 -&gt; 平衡二叉树 -&gt; B-树 -&gt; B+树</h3>
<blockquote>
<p>排序二叉树:左节点小于根节点,而右节点大于根节点<br>
平衡二叉树:在排序二叉树的基础上,保证左右子树的深度相差不超过1,可以降低查询的时间<br>
B-树:多路平衡二叉树,节点上可以有多个元素,也存储数据,可以有多个子树<br>
B+树:在B+树的基础上,仅在叶子节点上存储数据,非叶子节点存储用于比较的index,不存储数据</p>
</blockquote>
<h3 id="最左匹配原则">最左匹配原则</h3>
<blockquote>
<p>索引建立时 是按照 字段 从左到右 排序的顺序来比较和存储 节点指针的<br>
对于 已存在的索引 (a b c) :(a) (a b) (a b c) 可以使用该索引,同时mysql 存在对于检索条件的优化,使得 (c b a) 优化为(a b c) 来索引</p>
</blockquote>
<h3 id="myisam与innodb">MyISAM与InnoDB</h3>
<blockquote>
<p>1.对事务的的支持。MyISAM强调性能,每次查询都是具有原子性,执行速度更快,但不支持事务,Innodb 具有 事务(commit) 回滚(rollback) 和 崩溃恢复功能的事物安全型表<br>
2.对外键(表的外键是其他表的主键,跨表之间的联系)的支持<br>
3.InnoDB是聚集索引（主索引存储数据文件，辅助索引指向主键），MyISAM 是非聚集索引（主键索引和辅助索引都指向文件指针）</p>
<ul>
<li>InnoDB表必须有主键（用户没有指定的话会自己找或生产一个主键）以支持聚集索引，而Myisam可以没有(所有索引都是非聚集索引,主键索引和非主键索引都是没有区别,不使用聚集索引)<br>
4.InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁<br>
6.是否支持MVCC 应对高并发事物MVCC比锁更加高效(MVCC在读已提交和可重复读的连个隔离级别下工作)</li>
</ul>
</blockquote>
<h3 id="myisam">MyISAM</h3>
<blockquote>
<p>不支持事务和行级锁,最大的缺陷是崩溃后无法恢复<br>
在某些特殊场合(不介意崩溃恢复问题),myisam适合密集读</p>
</blockquote>
<h3 id="postgresql-vs-mysql">PostgreSQL  VS MySQL</h3>
<blockquote>
<p>待完善</p>
</blockquote>
<h2 id="mysql-锁">mysql 锁</h2>
<p><a href="https://juejin.im/post/6844903668571963406" target="_blank" rel="noopener">全面了解mysql锁机制（InnoDB）与问题排查</a><br>
<a href="https://blog.csdn.net/Jack__Frost/article/details/73347688" target="_blank" rel="noopener">锁机制超详细解析（锁分类、事务并发、引擎并发控制）</a></p>
<blockquote>
<p>背景:锁是计算机用于协调多个进程或线程访问某资源的机制;事物在操作某个数据之前需要申请对其加锁,根据锁的类型不同,事物对其有不同的控制程度,在该事物释放锁之前,阻止其他事物的操作.<br>
分类:</p>
<ul>
<li>按照封锁类型可以分为 排它锁和共享锁;
<ul>
<li>排它锁又称写锁,X锁,阻止其他事物对于数据加锁,阻止其他事物读或写该数据;</li>
<li>共享锁,又称读锁,S锁,事物对于数据添加共享锁之后,其他事物只能对其添加共享锁,不能添加排它锁,只能读,不能写</li>
</ul>
</li>
<li>按照封锁的粒度分类：
<ul>
<li>行级锁: 虽然由于粒度小,发生资源争用的概率变小,可以提高并发程度,但是因为粒度小,所以获取和释放锁的工作和消耗更多;此外容易发生死锁</li>
<li>表级锁: 虽然开销小,加锁快,不会出现死锁,但是锁定粒度大,发生冲突的概率大,并发程度低(一次性锁定事务所涉及到的表)</li>
<li>页级锁(Mysql独有): 加锁和开锁时间以及粒度介于 行级锁和表级锁之间,可能出现死锁,并发度一般</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>死锁的条件：互斥条件(排他性占有资源) 请求和保持条件(阻塞时不释放资源) 不剥夺条件(只能自己主动释放资源) 环路等待(进程-资源请求环)</p>
</blockquote>
<blockquote>
<p>举例 事物 <code>update t_goods set current_count = current_count - 1 where id = 1; update t_count set balance = balance - 2 where id = 1;</code> 和  <code>update t_goods set current_count = current_count - 1 where id = 1;update t_count set balance = balance - 2 where id = 1;</code> 分别获得了第一条记录的锁后,出现死锁</p>
</blockquote>
<blockquote>
<p>mysql 如何处理死锁：</p>
<ul>
<li>等待，直到事物超时回滚</li>
<li>发起死锁检测(死锁检测的原理是构建一个以事务为顶点、锁为边的有向图，判断有向图是否存在环，存在即有死锁。)，主动回滚一条事务(检测到死锁之后，选择插入更新或者删除的行数最少的事务回滚)，让其他事务继续执行</li>
</ul>
</blockquote>
<blockquote>
<p>死锁预防策略：</p>
<ul>
<li>逻辑上避免交叉操作(a-b和 b-a)</li>
<li>保持事物的轻量,减少涉及的表和资源,避免使用子查询,尽量使用主键,降低锁持有时间(不要在事物中加其他耗时操作)</li>
<li>建立索引(索引也可能导致死锁)</li>
</ul>
</blockquote>
<blockquote>
<p>其他：select update 操作是否设计锁表?可能和执行引擎相关？ todo</p>
</blockquote>
<h3 id="自增锁">自增锁</h3>
<blockquote>
<p>是MySQL一种特殊的锁，如果表中存在自增字段，MySQL便会自动维护一个自增锁。</p>
</blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/29150809" target="_blank" rel="noopener">参考1</a></p>
<h3 id="行锁">行锁</h3>
<h4 id="实现方式">实现方式</h4>
<ol>
<li>Innodb 通过对索引上的索引项加锁来实现(而Oracle通过对于数据行加锁来实现) =&gt; 只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁</li>
<li>不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁</li>
<li>由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然多个session是访问不同行的记录， 但是如果是使用相同的索引键,是会出现锁冲突的(后使用这些索引的session需要等待先使用索引的session释放锁后，才能获取锁)</li>
</ol>
<h3 id="间隙锁-gap-key">间隙锁 gap key</h3>
<blockquote>
<p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）<br>
但是间隙锁会导致对于符合条件范围的键值的插入陷入阻塞,等待锁释放;=&gt;尽量使用=而非范围<br>
唯一索引没有间隙锁<br>
间隙锁存在于非唯一索引中，锁定<code>开区间</code>范围内的一段间隔，它是基于临键锁实现的。(当查询的索引含有唯一属性的时候，Next-Key Lock 会进行优化，将其降级为Record Lock，即仅锁住索引本身，不是范围。)<br>
gap锁不排他 可重入<br>
目的</p>
</blockquote>
<ul>
<li>(结合MVCC)防止幻读,满足可重复读</li>
<li>满足恢复和复制的需要
<ul>
<li>mysql通过BINLOG记录事务的sql语句,按照事务提交的先后顺序来记录,实现mysql的备份和主从复制;由于按照事务提交的顺序来记录所以不允许<br>
利用 where between and触发 间隙锁,当范围内的记录都存在时,退化为行锁</li>
</ul>
</li>
</ul>
<h4 id="实现方式">实现方式</h4>
<blockquote>
<p>当</p>
</blockquote>
<h3 id="临键锁-next-key-lock">临键锁 next-key lock</h3>
<blockquote>
<p>Next-Key 可以理解为一种特殊的间隙锁，也可以理解为一种特殊的算法。通过临建锁可以解决幻读的问题。 每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。需要强调的一点是，InnoDB 中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁<br>
临键锁存在于非唯一索引中，该类型的每条记录的索引上都存在这种锁，它是一种特殊的间隙锁，锁定一段<code>左开右闭</code>的索引区间</p>
</blockquote>
<h3 id="唯一索引-是否使用-间隙锁"><a href="https://zhuanlan.zhihu.com/p/48269420" target="_blank" rel="noopener">唯一索引 是否使用 间隙锁</a></h3>
<p>在where between and中如果列元素 是非唯一索引那么是使用间隙锁的<br>
如果是唯一索引,那么</p>
<h3 id="常见加锁规则"><a href="https://www.aneasystone.com/archives/2017/12/solving-dead-locks-three.html" target="_blank" rel="noopener">常见加锁规则</a></h3>
<p>select 语句正常情况下为快照读，不加锁；<br>
SELECT … LOCK IN SHARE MODE 语句为当前读，加 S 锁；<br>
ELECT … FOR UPDATE 语句为当前读，加 X 锁<br>
常见的 DML 语句（如 INSERT、DELETE、UPDATE）为当前读，加 X 锁；<br>
常见的 DDL 语句（如 ALTER、CREATE 等）加表级锁，且这些语句为隐式提交，不能回滚；</p>
<p><a href="https://www.aneasystone.com/archives/2018/06/insert-locks-via-mysql-source-code.html" target="_blank" rel="noopener">insert into</a></p>
<blockquote>
<p>首先会获得插入意向锁,即会对插入所在记录的间隙的间隙锁,虽然它是一种间隙锁但是与gap锁冲突(不同事物对于同一间隙可重复加锁);<br>
完成插入之后,对插入的记录添加写锁,</p>
</blockquote>
<p>为什么非唯一索引会加 GAP 锁，而唯一索引不用加 GAP 锁呢？</p>
<blockquote>
<p>原因很简单，GAP 锁的作用是为了解决幻读，防止其他事务插入相同索引值的记录，而唯一索引和主键约束都已经保证了该索引值肯定只有一条记录，所以无需加 GAP 锁。</p>
</blockquote>
<h3 id="意向锁">意向锁</h3>
<p>分为意向读锁和意向写锁 属于表锁<br>
意向读锁与预想写锁之间是兼容的(直觉是类似可重入锁),但是意向锁与读写锁之间存在互斥(意向读锁与表写锁互斥,意向写锁与表读锁互斥)</p>
<h3 id="乐观锁-悲观锁">乐观锁 悲观锁</h3>
<p>MySQL的并发控制有两种方式，一个是 MVCC，一个是两阶段锁协议</p>
<blockquote>
<p>Multi-Version Concurrency Control,翻译为中文即 多版本并发控制<br>
VCC的实现，通过保存数据在某个时间点的快照来实现的。这意味着一个事务无论运行多长时间，在同一个事务里能够看到数据一致的视图。根据事务开始的时间不同，同时也意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的<br>
在每一行数据中额外保存两个隐藏的列：当前行创建时的版本号和删除时的版本号（可能为空，其实还有一列称为回滚指针，用于事务回滚，不在本文范畴）</p>
</blockquote>
<h3 id="事务的三级封锁协议">事务的三级封锁协议</h3>
<p>2PL,两阶段加锁协议:主要用于单机事务中的一致性与隔离性。<br>
一个事务里面，分为加锁(lock)阶段和解锁(unlock)阶段,也即所有的lock操作都在unlock操作之前<br>
在事务中只有提交(commit)或者回滚(rollback)时才是解锁阶段，其余时间为加锁阶段。</p>
<blockquote>
<p>按照顺序或者并发量 一次加锁和解锁<br>
引入2PL是为了保证事务的隔离性，保证并发调度的准确性，多个事务在并发的情况下依然是串行的。</p>
</blockquote>
<h3 id="三级封锁协议">三级封锁协议</h3>
<p>封锁协议：<br>
运用X锁和S锁对数据对象进行加锁时约定的规则就是封锁协议。</p>
<p>目的是在不同程序上保证数据的一致性。</p>
<p>一级封锁：修改数据加x锁直到事务结束才释放。在此协议中，仅仅是读数据是不需要加锁的，所以只能解决丢失修改问题，不能解决脏读和不可重复读。<br>
二级封锁：在一级封锁的基础上，加了一条：T事务在读取数据R之前必须先对其加上S锁，读完释放S锁。可以解决丢失修改和脏读（加了读锁就可以防止在读的期间其他事务进行修改，但是读完之后，事务结束之前，依然可能会其他事务进行修改，导致不可重复读）。<br>
三级封锁协议：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。：解决了丢失修改、脏读和不可重复读的问题。</p>
<h2 id="mysql-优化">mysql 优化</h2>
<ul>
<li>分表</li>
<li>存储过程和存储函数</li>
</ul>
<h3 id="数据库范式">数据库范式</h3>
<p>数据库设计对数据的存储性能，还有开发人员对数据的操作都有莫大的关系。所以建立科学的，规范的的数据库是需要满足一些规范的来优化数据数据存储方式。在关系型数据库中这些规范就可以称为范式。</p>
<p>第一范式：当关系模式R的所有属性都不能在分解为更基本的数据单位时，称R是满足第一范式的，简记为1NF。满足第一范式是关系模式规范化的最低要：</p>
<ul>
<li>字段不可分<br>
第二范式：如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式，简记为2NF。</li>
<li>有主键，非主键字段完全依赖主键而非主键的一部分<br>
第三范式：满足第二范式;设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，简记为3NF.</li>
<li>非主键字段不能相互依赖;</li>
</ul>
<h3 id="数据库连接池-和-事物">数据库连接池 和 事物</h3>
<h4 id="数据库连接池">数据库连接池</h4>
<p>1、连接池是创建和管理一个连接的缓冲池的技术，这些连接准备好被任何需要它们的线程使用。<br>
　　作用：避免频繁地创建与消毁，给服务器减压力。<br>
2、数据库的弊端：<br>
　　1.当用户群体少服务器可以支撑，如果群体比较大万级别服务器直接死机。数据库默认的并发访问50.<br>
　　2.每一个用完数据库之后直接关闭，不能重复利用太浪费资源。<br>
3、设计连接池：<br>
　　1.在池子中创建出多个连接供使用。<br>
　　2.当用户需要操作数据库时直接从池子中获取连接即可。<br>
　　3.当用户使用完毕之后把连接归还给连接池，可以达到重复使用。<br>
　　4.可以设定池子的最大容器。比如50个连接，当第51个人访问的时候，需要等待。<br>
　　5.其它用户释放资源的时候，可以使用。</p>
<h4 id="事物">事物</h4>
<p>事务是指一组操作，里面包含许多单一的逻辑。只要一个逻辑没有执行成功，那么就算失败。所有的数据都回归到最初的状态（回滚）<br>
A: 要么都发生,要么都不<br>
C: 事物发生前后保持一致性状态<br>
I: 隔离性,多个事物之间不相互干扰<br>
D: 发生之手产生持久性影响</p>
<h4 id="数据库连接池与事物-并非一一对应">数据库连接池与事物 并非一一对应</h4>
<ul>
<li>一个连接里可以启动多次事务，比如连接池，就是最明显的连接重用。</li>
<li>一个事务里，可以涉及到2个甚至多个连接，也就是XA的驱动，甚至跨不同数据库的事务。</li>
</ul>
<h4 id="其他-redis">其他 redis</h4>
<p>scan keys</p>
<h4 id="sql操作">sql操作</h4>
<blockquote>
<p>groupby having<br>
联合查询</p>
</blockquote>
<h4 id="mysql索引要使用b树而不是b树红黑树"><a href="https://segmentfault.com/a/1190000021488885" target="_blank" rel="noopener">mysql索引要使用B+树，而不是B树，红黑树</a></h4>
<ol>
<li>B+ vs hash</li>
</ol>
<blockquote>
<p>内存消耗,B+树的索引可以不一次性加载;而map需要</p>
</blockquote>
<ol start="2">
<li>B  VS B+</li>
</ol>
<blockquote>
<p>相对于B树仅在叶子节点存储数据,所以同样的内存空间可以容纳更多的节点元素,查询的io次数更少;<br>
其次主键索引的叶子节点的数据是相邻的,所以空间局部性会更好,方便范围查询<br>
稳定查询,每次都必须查询到叶子节点,而b树可能中间就可以了</p>
</blockquote>
<ol start="3">
<li>B+ VS 红黑树/二叉排序树</li>
</ol>
<blockquote>
<p>查询时间与树的高度相关,多路搜索树可以降低树的高度</p>
</blockquote>
<ol start="4">
<li>既然增加树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优的查找效率？</li>
</ol>
<blockquote>
<p>无线增加数的高度会导致最终形成一个一层的有序数组,数据量过大无法从一次性加载 而B+树可以以较小的内存代价降低高度;</p>
</blockquote>
<ol start="5">
<li>在内存中，红黑树比B树更优，但是涉及到磁盘操作B树就更优了，那么你能讲讲B+树吗？</li>
</ol>
<blockquote></blockquote>
<ol start="6">
<li>为什么B+树要这样设计？</li>
</ol>
<blockquote>
<p>这个跟它的使用场景有关，B+树在数据库的索引中用得比较多，数据库中select数据，不一定只选一条，很多时候会选中多条，比如按照id进行排序后选100条。如果是多条的话，B树需要做局部的中序遍历，可能要跨层访问。而B+树由于所有数据都在叶子结点不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能把所有数据取出来了。</p>
</blockquote>
<p><a href="https://segmentfault.com/a/1190000019619667" target="_blank" rel="noopener">MySQL重要知识点/面试题总结</a></p>
<p>mysql 执行一条指令的过程 存储引擎 <a href="https://cloud.tencent.com/developer/article/1418795" target="_blank" rel="noopener">MySQL命令执行过程和存储引擎概述</a></p>
<ol>
<li>连接管理。 主要是负责连接的建立与信息的认证
<ul>
<li>利用数据库连接池去管理连接实现高效复用(epoll?NIO?)</li>
</ul>
</li>
<li>解析与优化。 这一部分分为三个步骤处理：
<ul>
<li>查询缓存：对于相同的命令,会优先返回缓存中 的数据,此外缓存系统会监控缓存涉及的表,有变更的话,缓存失效</li>
<li>语法解析：对于查询文本做分析，判断请求的语法是否正确，然后从文本中要查询的表、各种查询条件都提取出来</li>
<li>查询优化：使用索引 外连接转内连接 子查询转连接 表达式简化</li>
</ul>
</li>
<li>存储引擎:它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作
<ul>
<li>读操作：涉及读缓存池,预读策略,LRU淘汰 - 双写;</li>
<li>写操作：涉及写缓存(唯一索引);</li>
</ul>
</li>
</ol>
<p>视图 VIEW</p>
<blockquote>
<p>虚标：从一个表或者多个表联合导出的虚拟的表,具有普通表的结构,但不实际存储数据</p>
</blockquote>
<ul>
<li>单表视图：可以用于查询,也可以用于修改</li>
<li>多表视图：一般用于查询,一般不会修改<br>
优点</li>
<li>逻辑独立：建立在表上的逻辑独立,隔离了实际表的影响</li>
<li>简化操作,可以定义常用操作为视图</li>
<li>安全性：首先是视图本身的虚拟性,与表结构不直接相关,可以向外暴露视图,保证数据安全</li>
</ul>
<p>缺点:</p>
<ul>
<li>修改限制</li>
<li>多表查询性能差</li>
</ul>
<p>存储过程 PROCEDURE</p>
<blockquote>
<p>程序化的sql语句组合; 一般是用来完成特定的数据操作（比如修改、插入数据库表或执行某些DDL语句等等)<br>
经过编译优化,相对于sql语句可以加快执行速度<br>
可以有参数</p>
</blockquote>
<p>函数 FUNCTION</p>
<blockquote>
<p>一般情况下是用来计算并返回一个计算结果;可以编译好使用</p>
</blockquote>
<p>函数 VS 存储过程</p>
<blockquote>
<p>是否可以独立运行,函数一般需要在配合查询操作使用<br>
存储过程一般可以入口参数以及返回值比函数更丰富,存储过程可以返回参数,记录集等,函数只能返回变量或者表对象<br>
存储过程一般适合复杂操作,修改等;</p>
</blockquote>
<p>光标（游标）</p>
<blockquote>
<p>查询语句可能查询出多条记录，在存储过程和函数中使用光标标来逐条读取查询结果集中的记录</p>
</blockquote>
<p>二级索引使用B+树,所以当他找到第一个符合要求的叶子节点之后,可以向后遍历判断索引是否相同,如果相同添加进返回列表,并继续下午,不同则停止遍历.</p>
<h4 id="mysql-innodb-3大特性-写缓冲-双写-自适应hash">mysql innodb 3大特性 写缓冲 双写 自适应hash</h4>
<h5 id="自适应hash">自适应hash</h5>
<p><a href="https://blog.csdn.net/qq_36431213/article/details/86512359" target="_blank" rel="noopener">自适应hash</a></p>
<blockquote>
<p>背景：哈希索引始终基于现有的二级索引构建,在索引树的任意长度的前缀上构建索引树(自适应:最近连续被访问三次的数据)<br>
由于哈希索引根据经常访问的索引构建,如此可以加速二级索引的访问速度,但是只使用于 = 和 in 操作,对于like 和joins操作 操作无能为力,此外 由于hash索引必然涉及锁的竞争(可能更新涉及索引的变更),高并发场景也可能会有消耗</p>
</blockquote>
<h5 id="缓冲池读请求">缓冲池：读请求</h5>
<p><a href="https://juejin.im/post/6844904051012796424" target="_blank" rel="noopener">参考1</a><br>
<a href="https://juejin.im/post/6844903874172551181" target="_blank" rel="noopener">参考2</a></p>
<blockquote>
<p>缓冲可以用于存储常访问的数据,mysql对应的有缓冲池的概念,增加了读请求的速度<br>
缓冲什么？缓冲池缓冲索引,和表数据(把磁盘数据加载到缓冲池),避免频繁的IO访问;</p>
</blockquote>
<p>如何管理和淘汰缓冲池？</p>
<blockquote>
<p>预读:出于局部性原理,mysql会提前预读一部分未读的数据,以期待未来访问不需要IO操作,但不命中时需要考虑淘汰策略<br>
<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-performance-read_ahead.html" target="_blank" rel="noopener">预读策略</a>：<br>
磁盘中的数据数据存储是以页为单位的一般4k,缓冲池是以extent为单位,包含64页,一般256K,需要满足预定条件出发异步预读</p>
</blockquote>
<ul>
<li>线性预读：缓冲池中当前的extent的被顺序读取的page数目&gt;=innodb_read_ahead_threshold(默认56)时会触发,对于下一个extent的异步预读</li>
<li>随机预读：缓缓池当前extent的数量大于13,那么该extent的其他页数据也会被预读,可以控制是否关闭该功能</li>
</ul>
<p>缓冲池中的页大小默认为 16KB(之所以不等于4K是为了提高数据的顺序读取性能,但降低了随机读取性能)</p>
<p><a href="https://juejin.im/post/6844904051012796424" target="_blank" rel="noopener">刷新策略</a></p>
<blockquote>
<p>通过策略将缓冲刷新磁盘保证数据的持久性,当数据库崩溃是可以通过redo log 操作</p>
</blockquote>
<ul>
<li>普通模式，当缓存池中的脏页比例超过innodb_max_dirty_pages_pct_lwm(低水平线默认为25%)时，启动普通模式将脏页刷新到磁盘中</li>
<li>aggressively flushes,当缓存池中的脏页比例超过innodb_max_dirty_pages_pct(默认为75%)时，启动更快的刷新模式，尽快的将脏页刷新到磁盘当中</li>
</ul>
<p><a href="https://juejin.im/post/6844904051012796424" target="_blank" rel="noopener">缓存池淘汰算法LRU</a></p>
<blockquote>
<p>基于LRU算法改进,避免了LRU列表被污染(避免出现只访问一次在不访问的情况,以及预读出现的缓存的污染)<br>
其他的算法还包括 FIFO LFU</p>
</blockquote>
<p>LRU算法</p>
<blockquote>
<p>维护一个链表,将刚出现的页查到链表头(如果已经在队列则改变位置),随着链表的长度增长达到总长度,链表尾的数据长期未被访问而被淘汰(但是会出现污染的情况,使得命中率下降)</p>
</blockquote>
<p>LRU-K</p>
<blockquote>
<p>其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。也就是说没有到达K次访问的数据并不会被缓存，这也意味着需要对于缓存数据的访问次数进行计数，并且访问记录不能无限记录，也需要使用替换算法进行替换。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据</p>
</blockquote>
<p>使用算法:LRU变种</p>
<blockquote>
<p>利用midpoint将LRU队列分为两部分 NEW(最近被访问) OLD,默认5:3 双方各自维护head tail<br>
成为OLD:用户读取的页面或者预读的页面首先插入OLD的head<br>
成为NEW：用户读取的页面在OLD中,则将其转移到NEW的head<br>
随着NEW和OLD的逐渐增加,页会被慢慢淘汰</p>
</blockquote>
<h5 id="写缓冲写请求">写缓冲:写请求</h5>
<blockquote>
<p>背景:insert buffer 只对insert操作有效,5.6后,改为change buffer 对于insert update操作有效<br>
目的:应用于非唯一索引页(唯一索引必须加载全部索引然后判断是否唯一)不在缓冲池时对于页进行写操作,仅仅记录变更,等未来数据被读取时,再讲数据变更合并到缓冲区,目的在于降低读磁盘IO的开销(之所以读是因为避免频繁写需要频繁的IO,在内存中写快多了);</p>
</blockquote>
<p>触发写缓冲合并的操操作：</p>
<ul>
<li>写缓冲涉及的页被访问</li>
<li>数据库空闲或者关闭时</li>
<li>数据库缓冲池不够,需要更新缓冲</li>
<li>redo log 写满(基本不会发生)</li>
</ul>
<p>什么业务场景，适合开启InnoDB的写缓冲机制</p>
<ul>
<li>大部分索引是唯一索引</li>
<li>业务写多读少或者写完之后不会立刻读(流水账)</li>
</ul>
<p>参数配置：</p>
<ul>
<li>innodb_change_buffer_max_size：配置写缓冲的大小，占整个缓冲池的比例，默认值是25%，最大值是50%</li>
<li>innodb_change_buffering：配置哪些写操作启用写缓冲，可以设置成all/none/inserts/deletes</li>
</ul>
<h5 id="双写">双写</h5>
<p><a href="https://dbaplus.cn/news-11-1170-1.html" target="_blank" rel="noopener">参考1</a></p>
<blockquote>
<p>由于cache pageSize一般不是4k那么意味着对于cahce块对于磁盘的写入分为4部分,可能部分成功(比如说断电),出现 partial page write,这时 即使借助redo日志也不能恢复数据,所以需要借助双写机制 实现副本 备份<br>
双写的额外存储：</p>
</blockquote>
<ul>
<li>double write buffer：2M =128 cache page的空间= 2簇的大小</li>
<li>共享表空间：磁盘上对应的2M的连续空间(128页= 120批量写脏页+8由用户发起的单个写脏页)<br>
双写过程：</li>
<li>LRU缓冲队列中淘汰的脏页复制到dwb</li>
<li>将dwb同步到磁盘存储备份(由于是顺序整体写,所以速度不会慢)(分两次写到共享表空间,1次1M)</li>
<li>开始将dwb中数据分页写回磁盘(在此可以通过把相邻近的页相邻的写回磁盘加快速度)</li>
</ul>
<p>varchar VS  char<br>
<a href="https://www.cnblogs.com/zhuyeshen/p/11642211.html" target="_blank" rel="noopener">参考1</a></p>
<ul>
<li>长度
<ul>
<li>CHAR 固定长度 最多28−1个字符，28−1个字节</li>
<li>VARCHAR 不定长度 最多216−1个字符，216−1个字节(前面保留1-2字节存储实际长度)</li>
</ul>
</li>
<li>空格处理
<ul>
<li>char 保留末尾空格和长度</li>
<li>varchar 删除末尾空格并根据真实长度存储</li>
</ul>
</li>
<li>碎片角度
<ul>
<li>varchar 可能导致存储碎片</li>
</ul>
</li>
<li>内存
<ul>
<li>查询varchar的表时为了保存数据结果转化为char,会按照其定义的大小分配空间,而非按照实际 长度</li>
</ul>
</li>
</ul>
<h4 id="mysql-的插入删除和更新插入删除和更新索引">mysql 的插入删除和更新<a href="https://www.cnblogs.com/qianxingmu/p/10746837.html" target="_blank" rel="noopener">插入删除和更新索引</a></h4>
<p>对于数据的操作实际上都是涉及对于索引的锁<br>
mysql的删除仅仅是标记数据行,没有实际的删除,删除的数据行位置可以被新插入的行记录复用<br>
mysql的删除和更新操作可能会使得空间占比低于MERGE_THRESHOLD (行数据 所占据页的空间比,一般为50%) ,导致当前页尝试与相邻页(如果也低于50%)进行合并<br>
mysql的插入和更新涉及页的分裂</p>
<blockquote>
<p>当按序插入时,只会在有空间的页中添加或者新占用一页;但是如果是在中间插入,那么可能出现该记录的前后记录所在的页都是满页,这时会出现页的分裂,会将前面记录所在的满页的1-MERGE_THRESHOLD复制到新页,然后该记录插在新页。频繁的也分裂可能造成数据也空洞<br>
可以通过降低 MERGE_THRESHOLD值去降低页合并的可能性;但是过小也可能造成数据页空洞,大量文件零散分布<br>
可以通过查看页的分裂数然后利用  optimize table t 重建表,但是耗时而且锁住索引<br>
这个命令的原理就是重建表，就是建立一个临时表 B，然后把表 A（存在数据空洞的表） 中的所有数据查询出来，接着把数据全部重新插入到临时表 B 中，最后再用临时表 B 替换表 A 即可，这就是重建表的过程。顺序插入的过程,可以避免页的分裂</p>
</blockquote>
<p>引发慢查询的情况有三种：</p>
<ul>
<li>索引没有设计好:可以建立索引解决</li>
<li>SQL 语句没有写好：优化语句</li>
<li>MYSQL 选错了索引 添加 <code>force index</code>强制使用索引</li>
</ul>
<p>expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键</p>
<p>索引建立原则 区分度<br>
查询语句中同时出现where 和group 怎么走索引，索引能走多个吗</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/28/工作求职/面经收集/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/28/工作求职/面经收集/" itemprop="url">面经收集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-28T15:30:33+08:00">
                2020-08-28
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-09-22T23:38:26+08:00" content="2020-09-22">
                2020-09-22
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java 后台开发<br>
<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">Github 知识总结</a></p>
<ul>
<li><a href="https://www.nowcoder.com/discuss/491234?channel=1013&amp;source_id=home_feed" target="_blank" rel="noopener">美团一面</a></li>
</ul>
<p>面试问题收集：</p>
<ol>
<li>
<p>volatile不是线程安全<br>
线程安全必须保证原子性，可见性，有序性。而volatile只能保证可见性和有序性,volatile 只能保证 可见性,有序性 不能保证操作的原子性,建议使用CAS操作 利用cocurrent.atomic包下面的封装</p>
</li>
<li>
<p>配置线程池需要考虑哪些因素</p>
</li>
</ol>
<blockquote>
<p>从任务的优先级，任务的执行时间长短，任务的性质（CPU密集/ IO密集），任务的依赖关系这四个角度来分析。并且近可能地使用有界的工作队列。<br>
性质不同的任务可用使用不同规模的线程池分开处理：</p>
</blockquote>
<ul>
<li>CPU密集型：尽可能少的线程，Ncpu+1</li>
<li>IO密集型：尽可能多的线程, Ncpu*2，比如数据库连接池</li>
<li>混合型：CPU密集型的任务与IO密集型任务的执行时间差别较小，拆分为两个线程池；否则没有必要拆分。</li>
</ul>
<ol start="3">
<li>集群基本概念—脑裂的产生和解决方案<br>
<a href="https://www.cnblogs.com/kevingrace/p/12433503.html" target="_blank" rel="noopener">脑裂</a></li>
</ol>
<ul>
<li>限定发送人数,确定集群有效无效</li>
<li>冗余通信(物理)</li>
<li>仲裁方式</li>
<li>磁盘锁定</li>
</ul>
<ol start="4">
<li>Map 接口及其实现类</li>
</ol>
<blockquote>
<p>HashMap<br>
LinkedHashMap<br>
TreeMap<br>
HashTable<br>
WeakHashMap:以弱键 实现的基于哈希表的 Map。在 WeakHashMap 中，当某个键不再正常使用时，将自动移除其条目。更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收<br>
EnumMap</p>
</blockquote>
<ol start="5">
<li>StringBuilder StringBuffer</li>
</ol>
<blockquote>
<p>StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。<br>
由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p>
</blockquote>
<ol start="6">
<li>
<p>juc</p>
</li>
<li>
<p>几个垃圾回收器（3对+1），Serial与Serial Old ,ps和po  ，pn和cms，g1</p>
</li>
<li>
<p>对象创建的生命周期(栈，线程本地，堆)，对象的分配(一般对象，大对象，一直存在的对象)，如何判断一个对象是否是垃圾对象(介绍了两个方法，各自特点)，强软弱需引用，有哪些垃圾回收算法（4个方法），各自的特点，还说了几个垃圾回收器（3对+1），Serial与Serial Old ,ps和po  ，pn和cms，g1，还介绍了各自的优点缺点，jdk怎么用的，stw的情况，还说了如何调优，jdk1.8默认ps po的调优（介绍了几个指令），最后还说了，我用的一直都是idea默认版本pspo。</p>
</li>
<li>
<p>AOP原理了解吗？</p>
</li>
</ol>
<blockquote>
<p>恒切面;切点；通知</p>
</blockquote>
<ol start="10">
<li>
<p>shard</p>
</li>
<li>
<p>分布式session</p>
</li>
</ol>
<ul>
<li>粘性session：粘性Session是指将用户锁定到某一个服务器上;在nginx出配置;但容错性低</li>
<li>服务器session复制：修改 传播所有机器</li>
<li>session共享机制：reids共享</li>
</ul>
<ol start="12">
<li>MySQL Explain详解</li>
</ol>
<blockquote>
<p>explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看</p>
</blockquote>
<ol start="13">
<li>concurrenthashmap 是否线程安全?</li>
</ol>
<blockquote>
<p>concurrenthashmap的线程安全是指他的put和get操作是原子操作，是线程安全的;outIfabsent</p>
</blockquote>
<ol start="14">
<li>在一个千万级的数据库查寻中，如何提高查询效率？</li>
</ol>
<ul>
<li>分表：femmale 枚举字段 分表</li>
<li>优化查询,避免全表查询,建立并使用索引</li>
<li>应尽可能的避免更新索引数据列(insert)，因为索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新索引数据列，那么需要考虑是否应将该索引建为索引</li>
<li>避免临时操作</li>
<li>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</li>
<li>避免全表查询
<ul>
<li>where 子句中使用!=或&lt;&gt;</li>
<li>where 子句中使用 or 来连接条件</li>
<li>in 和 not in  like</li>
</ul>
</li>
</ul>
<ol start="15">
<li>微信红包算法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static double getRandomMoney(RedPackage _redPackage) &#123;</span><br><span class="line">        // remainSize 剩余的红包数量</span><br><span class="line">        // remainMoney 剩余的钱</span><br><span class="line">        if (_redPackage.remainSize == 1) &#123;</span><br><span class="line">            _redPackage.remainSize--;</span><br><span class="line">            return (double) Math.round(_redPackage.remainMoney * 100) / 100;</span><br><span class="line">        &#125;</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        double min = 0.01; //</span><br><span class="line">        double max = _redPackage.remainMoney / _redPackage.remainSize * 2;</span><br><span class="line">        double money = r.nextDouble() * max;</span><br><span class="line">        money = money &lt;= min ? 0.01 : money;</span><br><span class="line">        money = Math.floor(money * 100) / 100;</span><br><span class="line">        _redPackage.remainSize--;</span><br><span class="line">        _redPackage.remainMoney -= money;</span><br><span class="line">        return money;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="16">
<li>为什么用B+树？</li>
</ol>
<blockquote>
<p>磁盘IO开销小 栈空间较小<br>
查找比较稳定。效率比较高</p>
</blockquote>
<ol start="17">
<li>解决哈希冲突有如下的方法：</li>
</ol>
<blockquote>
<p>开放定址法(线性探测，二次探测，伪随机探测)<br>
链地址法<br>
再散列法（双重散列，多重散列）<br>
建立一个公共溢出区</p>
</blockquote>
<ol start="18">
<li>外排序</li>
</ol>
<blockquote>
<p>利用外存也就是磁盘进行排序的一种简称。<br>
典型的应用是hadoop　的 mapreduce 的merge 阶段(map shuffle reduce)</p>
</blockquote>
<ol start="19">
<li>秒杀怎么解决超卖</li>
</ol>
<blockquote>
<p>redis 缓存数据库压力;消息队列;分步骤 下单 和 真正获取订单;限制用户访问频率和次数</p>
</blockquote>
<ol start="20">
<li>消息队列</li>
</ol>
<blockquote>
<p>异步通信:降低服务耦合;提高并发度;流量削峰</p>
</blockquote>
<ol start="21">
<li>HashMap 30分钟<br>
<a href="https://blog.csdn.net/zhengwangzw/article/details/104889549" target="_blank" rel="noopener"> HashMap 30分钟</a></li>
</ol>
<ul>
<li>因为1.7头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环；</li>
</ul>
<ol start="22">
<li>
<p>2-3树到红黑树</p>
</li>
<li>
<p>存储过程</p>
</li>
</ol>
<blockquote>
<p>存储过程可以说是一个记录集吧，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就<br>
由于数据库执行动作时，是先编译后执行的。然而存储过程是一个编译过的代码块，所以执行效率要比T-SQL语句高<br>
一个存储过程在程序在网络中交互时可以替代大堆的T-SQL语句，所以也能降低网络的通信量，提高通信</p>
</blockquote>
<ol start="24">
<li>linux 管道</li>
</ol>
<blockquote>
<p>管道是Linux中很重要的一种通信方式,是把一个程序的输出直接连接到另一个程序的输入,常说的管道多是指无名管道,无名管道只能用于具有亲缘关系的进程之间，这是它与有名管道的最大区别。</p>
</blockquote>
<ul>
<li>管道是一个固定大小的缓冲区。在Linux中，该缓冲区的大小为1页，即4K字节，使得它的大小不象文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，当这种情况发生时，随后对管道的write()调用将默认地被阻塞</li>
<li>读取进程也可能工作得比写进程快。当所有当前进程数据已被读取时，管道变空。当这种情况发生时，一个随后的read()调用将默认地被阻塞，等待某些数据被写入，这解决了read()调用返回文件结束的问题。</li>
<li>半双工</li>
</ul>
<ol start="25">
<li>request和response</li>
</ol>
<blockquote>
<p>Web服务器收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象、和代表响应的response对象</p>
</blockquote>
<ol start="26">
<li>NIO</li>
</ol>
<blockquote>
<p>NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道</p>
</blockquote>
<ol start="27">
<li>HashMap HashTable CocurrentHashmap LinkedHashMap TreeHashMap</li>
</ol>
<blockquote>
<p>JDK1.7版本锁的粒度是基于Segment的，包含多个HashEntry(ReentrantLock+Segment+HashEntry): volatile HashEntry&lt;K,V&gt; 确保可见性<br>
DK1.8锁的粒度就是HashEntry（首节点）(synchronized+CAS+HashEntry+红黑树)</p>
</blockquote>
<ol start="28">
<li>MVC 处理流程</li>
</ol>
<blockquote>
<p>用户发送请求至前端控制器DispatcherServlet<br>
DispatcherServlet收到请求调用HandlerMapping处理器映射器<br>
处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet<br>
DispatcherServlet调用HandlerAdapter处理器适配器<br>
HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)<br>
Controller执行完成返回ModelAndView。<br>
HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。<br>
DispatcherServlet将ModelAndView传给ViewReslover视图解析器<br>
响应客户</p>
</blockquote>
<ol start="29">
<li>静态方法和实例方法</li>
</ol>
<blockquote>
<p>从逻辑关系来看：若方法与类的实例不存在逻辑上的联系，那么用静态方法。反之则最好使用实例化方法。<br>
从性能角度:若方法经常被调用，则用静态方法更佳，因为这样可以避免频繁地实例化对象导致的资源占用，提高性能。然而，由于静态的东西，在构造的时候是在堆中声称的，在结束之前不会被释放与改变，会一直占用内存空间，所以不宜有过多的静态成员。<br>
从线程并发的角度考虑:如果并发的可能性很大，则不适宜使用静态方法。如果并发的可能性很小，或者通过简单的同步操作可以保证线程安全，那就可以考虑使用静态方法</p>
</blockquote>
<ol start="33">
<li>raft<br>
leader candidate follower</li>
</ol>
<blockquote>
<p>leader负责对整个集群进行控制管理，同时接受客户端的请求。在整个集群中，不能同时出现多个leader，任何时刻只会有一个或者没有。<br>
candidate就是处于选主阶段的状态，要么选举成功成为leader，要么退回到follower。<br>
一般情况下大部分服务器都处于follower状态。跟随者可以理解为master-slave结构中的slave，就像是将军领导下的小兵。follower不会主动向集群发起消息</p>
</blockquote>
<ol start="34">
<li>
<p>内连接左连接，完整型约束</p>
</li>
<li>
<p>top<br>
P：CPU排序；M：排序</p>
</li>
<li>
<p>如何保障缓存一致性(缓存与数据库的双写一致性)<br>
共识</p>
</li>
</ol>
<ul>
<li>缓存必须要有过期时间</li>
<li>保证数据库跟缓存的最终一致性即可，不必追求强一致性<br>
<a href="https://juejin.im/post/6844903941646319623" target="_blank" rel="noopener">数据库与缓存数据一致性问题</a><br>
更新缓存的的Design Pattern有四种</li>
<li>Cache Aside Pattern
<ul>
<li>失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中</li>
<li>命中：应用程序从cache中取数据，取到后返回。</li>
<li>更新：先把数据存到数据库中，成功后，再让缓存失效；更新的操作还有：
<ul>
<li>先更新数据库,再写缓存 可能出现 AB 先后更新数据库,但更新缓存的顺序为BA 导致脏数据;其次如果并不确定该数据是否被频繁访问,如果每次更新数据库都更新缓存,可能造成缓存空间的浪费;所以更新不可取,删除更好(需求方主动触发缓存更新)</li>
<li>先更新缓存,然后更新数据库：更新操作可能失败,导致数据可能丢失,不能保证最终一致性(应当以数据库为主);同时也存在操作乱序的问题</li>
<li>先删除缓存,然后更新数据库：可能在 A在删除缓存 和更新数据库之间 出现B 缓存不命中,读取脏值到redis中的情况(在读写分离的情况下更为严重)</li>
<li>先更新数据库,然后删除缓存：可能出现缓存失效的情况下,A-&gt;读取旧值-&gt;B更新数据库-&gt;B删除缓存-&gt;A写旧值到到缓存(是否可以通过写redis时要求比较值的时间戳);但可能性低 同时主从读写分离的情况下,可能出现从库数据未脏数据的情况</li>
</ul>
</li>
<li>定时删除缓存(消息队列,过期时间);比较高频数据的写时间戳</li>
<li>删除缓存可能导致的缓存击穿 可以利用锁操作( set 在发现缓存为空时,竞争读写数据库的机会)</li>
</ul>
</li>
</ul>
<p>更强的一致性实现：分布式读写锁(共享读锁,在写锁存在的情况下不可以申请读锁)</p>
<ol start="37">
<li>redis 锁<br>
单节点 锁INCR、SETNX、SET</li>
</ol>
<ul>
<li>SETNX：排他性;该命令只会在键不存在的情况下才会为键设置值,这样当别的进程再去使用这个命令设置这个键的时候就会失败进而无法获得锁</li>
<li>避免死锁：在获得setnx 同时设置锁的过期时间;</li>
<li>释放锁时检查:A在获得锁之后,超时自动释放而不自知,但后续主动释放已经被B获得的锁,破坏了B涉及的互斥过程。</li>
</ul>
<p>分布式锁<br>
共识算法<br>
raft paxos gossip</p>
<p>CopyOnWriteArrayList 线程安全</p>
<blockquote>
<p>CopyOnWriteArrayList 不强调线程之间的同步,强调数据的共享(对于可能的写不干扰其他读)<br>
对于所有涉及修改的操作,加锁,其实现都是复制一个与原本数据已知的数组对象,然后把指针指向这个对象;相当于线程的私有变量,随着线程的消亡而消亡(可能会面临内存泄漏的问题)<br>
适合于读多写少的场景,但是对于数据量比较大的场景,复制会比较消耗时间,在完成之前访问,仍然获得旧数据</p>
</blockquote>
<p>如何存储一个弹幕系统的弹幕，使用redis的什么类型，怎么保证热点数据，每秒会产生大量的数据，redis扛不住怎么办<br>
<a href="https://www.cnblogs.com/java920043111/p/9286123.html" target="_blank" rel="noopener">bilibili 高并发实时弹幕系统的实现</a><br>
消息队列  udp广播</p>
<p>spring AOP，JDK和CGlib的区别，除了针对接口和类以外的不同</p>
<blockquote>
<p>java动态代理是利用反射机制生成一个实现代理接口的代理类，在调用具体方法前调用InvokeHandler来处理。</p>
<ul>
<li>JDK代理是不需要以来第三方的库，只要要JDK环境就可以进行代理<br>
而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</li>
<li>CGLib 必须依赖于CGLib的类库</li>
</ul>
</blockquote>
<p>实现 ReadWriteLock</p>
<p><a href="https://www.cnblogs.com/yihujiu/p/6379279.html" target="_blank" rel="noopener">大量日志查找</a><br>
HAdoop mapreduce</p>
<p>Docker容器本质上是宿主机上的进程，卷相当于容器的磁盘。</p>
<blockquote>
<p>Docker通过nampespace实现了资源隔离，通过cgroups实现了资源限制，通过写时复制机制（copy-on-write）实现了高效的文件操作。</p>
</blockquote>
<p>轻量级锁</p>
<blockquote>
<p>他的出现并不是代替重量级锁，而是在没有多线程竞争的前提下，减少系统互斥量操作产生的性能消耗<br>
锁战友的而时间步长</p>
</blockquote>
<p><a href="https://blog.csdn.net/scdn_cp/article/details/86491792" target="_blank" rel="noopener">无锁 -&gt; 偏向锁 -&gt; 轻量级 -&gt; 重量级</a></p>
<ul>
<li>初期锁对象刚创建时，还没有任何线程来竞争，对象的Mark Word是下图的第一种情形，这偏向锁标识位是0，锁状态01，说明该对象处于无锁状态</li>
<li>当有一个线程来竞争锁时，先用偏向锁，表示锁对象偏爱这个线程，这个线程要执行这个锁关联的任何代码，不需要再做任何检查和切换，这种竞争不激烈的情况下，效率非常高。这时Mark Word会记录自己偏爱的线程的ID，把该线程当做自己的熟人。如下图第二种情形</li>
<li>当有两个线程开始竞争这个锁对象，情况发生变化了，不再是偏向（独占）锁了，锁会升级为轻量级锁(monitorenter)，两个线程公平竞争，哪个线程先占有锁对象并执行代码，锁对象的Mark Word就执行哪个线程的栈帧中的锁记录。如下图第三种情形</li>
<li>如果竞争的这个锁对象的线程更多，导致了更多的切换和等待，JVM会把该锁对象的锁升级为重量级锁，这个就叫做同步锁，这个锁对象Mark Word再次发生变化，会指向一个监视器对象，这个监视器对象用集合的形式，来登记和管理排队的线程</li>
</ul>
<p><a href="https://www.xttblog.com/?p=4881" target="_blank" rel="noopener">Java为什么要引入偏向锁？</a><br>
Java 对象头 记录 锁的状态以及当前线程ID 或时间戳<br>
堆栈中记录着当前持有的锁的对象</p>
<p><a href="https://juejin.im/post/6844904023540105229" target="_blank" rel="noopener">Class.forName &amp; ClassLoader.loadClass 比较</a><br>
<a href="https://juejin.im/post/6873691965892853767" target="_blank" rel="noopener">new Object()到底占用几个字节，看完这篇就彻底明白了</a></p>
<p>mysql里什么是检查点、保存点和中间点？：w</p>
<p>Object 有哪些方法？</p>
<ul>
<li>hashCode</li>
<li>equals 之间判断地址是否相等,可重写</li>
<li>clone  默认仅仅是复制引用,浅拷贝; 重写该接口必须 实现Cloneable接口</li>
<li>toString 对象名@hashcode</li>
<li>notify notifyAll wat</li>
<li>protected finalize 垃圾回收器准备释放内存的时候，会先调用finalize(),并且只会调用一次(可能会出现方法)</li>
</ul>
<h2 id="算法">算法</h2>
<h3 id="排序算法">排序算法</h3>
<table>
<thead>
<tr>
<th>算法名</th>
<th>稳定</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>核心思想</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入排序</td>
<td>稳定</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>在数组中实现,第一个节点构成的集合是有序的,然后依次增加集合相邻的元素进入,采取后移和插入的方式实现集合内的有序,直至集合包含所有元素</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>稳定</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>循环的比较相邻的值,如果前者大于后者则调换位置,一次遍历可以把最大的放置在最后,然后可以放置次大</td>
</tr>
<tr>
<td>归并排序</td>
<td>稳定</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>将数组分割为N个集合,集合内归并排序,然后合并集合</td>
</tr>
<tr>
<td>计数排序</td>
<td>稳定</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>在数组最大值和最小值的空间内,统计数组中每个元素出现的次数,然后输出即可</td>
</tr>
<tr>
<td>桶排序</td>
<td>稳定</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>可以把某个范围定义为桶,把元素分割到各个桶内,桶内使用任何排序使得有序,然后整体有序</td>
</tr>
<tr>
<td>基数排序</td>
<td>稳定</td>
<td>O(n*k)</td>
<td>O(n+k)</td>
<td>根据数组元素,将元素分为N个关键字,每次针对一个关键字排序,N个关键字排序之后保持有序</td>
</tr>
<tr>
<td>希尔排序</td>
<td>不稳定</td>
<td>O(n^1.3)</td>
<td>O(1)</td>
<td>设定步长为N,共可得到N个每个元素相邻下标为N的元素集合,集合内部插入排序,然后 不断缩减步长到1;由于 减少了集合间元素的比较,在当步长越小,集合也变得大体有序</td>
</tr>
<tr>
<td>选择排序</td>
<td>不稳定</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>选择最小/最大值到开头或者末尾,在剩下的元素中选择最小/最大,添加进之前的有序末尾</td>
</tr>
<tr>
<td>堆排序</td>
<td>不稳定</td>
<td>O(nlogn)</td>
<td>O(1）</td>
<td>基于完全二叉树,所以可以使用数组实现; 首先根据N个输入元素构建完全而二叉树;然后从节点N/2——1开始自下而上调整树,调整最大堆;随后将最大值和节点N互换,自上而下调整树,再次得到最大堆,持续可得到有序输出</td>
</tr>
<tr>
<td>快速排序</td>
<td>不稳定</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>通过选定一个基准,将所有小于该基准的放在左边,大于该基准的放在右边,随后对基准左右分别快排,获得全局有序</td>
</tr>
</tbody>
</table>
<p>mysql 事务的实现</p>
<blockquote>
<p>锁+MVCC<br>
锁：读写锁/共享独占锁(二阶段锁提交)+间隙锁/临界锁(在二段加锁的情况下,可能导致死锁)<br>
MVCC：undolog 实现未提交事务的原子性(redolog 保证已提交事务的持久性)<br>
MVCC 是快照读,不能读创建readview之后提交的事务的更新,可以添加for update 强制当前读<br>
innodb的RR隔离级别下,读自动开启行锁和间隙锁构成next-key锁,配合MVCC 解决幻读或者直接串行化</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/15/工作求职/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/15/工作求职/JVM/" itemprop="url">JVM</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-15T17:39:54+08:00">
                2020-08-15
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-09-29T17:14:58+08:00" content="2020-09-29">
                2020-09-29
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>JVM 内存</li>
</ol>
<ul>
<li>方法区：存放类运行时必须的结构信息,比如类的静态变量,常量,类的全局名称,方法信息,父类引用等如</li>
<li>堆：实际存储对象的地方,占据大量内存,主要GC对象,具体可以分为老年堆和年轻堆</li>
<li>虚拟机栈：每个线程都有一个自己独立的Java栈，每次线程执行到一个新的方法时就在栈里面压入一个栈帧。帧里包含了方法里的局部变量，操作数栈(数据运算)以及帧数据区。这三种区域中局部变量很好理解，就是在方法作用范围内的变量，包括基本变量和对象的引用</li>
<li>本地方法栈：调用系统提供的方法时,涉及的机制和数据</li>
<li>PC寄存器：线程运行时对于程序运行中的位置和状态的标识</li>
</ul>
<ol start="2">
<li>类加载/Class.forName</li>
</ol>
<ul>
<li>class文件记载到内,把字节码文件转换为二进制文件</li>
<li>在方法区中形成内部数据结构</li>
<li>验证类文件中数据合法性</li>
<li>初始化的过程（主要给静态变量和静态块初始化）</li>
</ul>
<ol start="3">
<li>实例化/newInstance</li>
</ol>
<ul>
<li>在堆中生成一个对象实例</li>
<li>对实例的内部变量初始化</li>
</ul>
<p>Eden区与Survivor的比例较大，HotSpot默认是 8:1，即分别占新生代的80%，10%，10%。如果一次回收中，Survivor+Eden中存活下来的内存超过了10%，则需要将一部分对象分配到 老年代。用-XX:SurvivorRatio参数来配置Eden区域Survivor区的容量比值，默认是8，代表Eden：Survivor1：Survivor2=8:1:1.<br>
Major GC vs Full GC<br>
Major GC 是清理永久代。Full GC 是清理整个堆空间—包括年轻代和老年代  永久代(方法区)<br>
堆大小=新生代+老年代，新生代与老年代的比例为1：2，新生代细分为一块较大的Eden空间和两块较小的Survivor空间，分别被命名为from和to。(方便复制-清除；from to GC后交换角色)</p>
<p>大对象直接进入老年代，实际上是为了保证Eden区具有充足的空间可用的一种策略(复制算法耗时，好空间)</p>
<p>垃圾收集器: 垃圾收集器是垃圾回收算法（标记-清除算法、复制算法、标记-整理算法、火车算法）的具体实现<br>
新生代收集器：Serial、ParNew、Parallel Scavenge<br>
老年代收集器：Serial Old、Parallel Old、CMS；<br>
整堆收集器：G1</p>
<ul>
<li>Serial收集器：新生代收集器，使用停止复制算法，使用一个线程进行GC，其它工作线程暂停</li>
<li>ParNew收集器：serial 多线程版本(除Serial外，目前只有它能与CMS收集器配合工作)</li>
<li>Parallel Scavenge:目标新生代,复制算法,多线程,但 CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间,而Parallel Scavenge收集器的目标则是达一个可控制的吞吐量（Throughput:吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间））；</li>
<li>Serial Old :目标老年代,标记整理,单线程</li>
<li>Parallel Old： serial的多线程版</li>
<li>cms：并发标记清理,针对老年代,标记清除(内存碎片);并发收集(使得用户线程可以工作)：浮动垃圾和内存碎片</li>
<li>G1（Garbage-First）<br>
- 能充分利用多CPU、多核环境下的硬件优势；可以并行来缩短&quot;Stop The World&quot;停顿时间；也可以并发让垃圾收集与用户程序同时进行<br>
- 分代收集，收集范围包括新生代和老年代：能独立管理整个GC堆（新生代和老年代），而不需要与其他收集器搭配；<br>
- 结合多种垃圾收集算法，空间整合，不产生碎片：从整体看，是基于标记-整理算法；从局部（两个Region间）看，是基于复制算法；这是一种类似火车算法的实现；<br>
- 可预测的停顿：低停顿的同时实现高吞吐量,可预测的停顿：低停顿的同时实现高吞吐量<br>
- 场景：服务端</li>
</ul>
<p>GC是什么时候触发的（面试最常见的问题之一）<br>
由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Minor GC和Full GC。<br>
采用“分代式垃圾收集”。这种方法会跟Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域：</p>
<ul>
<li>伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。</li>
<li>幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。</li>
<li>终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间</li>
</ul>
<p>Minor GC：<br>
  一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Minor GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。<br>
Full GC ：<br>
对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC：<br>
a) 年老代（Tenured）被写满；<br>
b) 持久代（Perm）被写满；<br>
c) System.gc()被显示调用；<br>
d) 上一次GC之后Heap的各域分配策略动态变化；<br>
面试题：jvm查看gc命令<br>
jstat -gc 12538 5000<br>
即会每5秒一次显示进程号为12538的java进成的GC情况，<br>
面试题：如果频繁老年代回收怎么分析解决(蚂蚁金服面试题)<br>
（个人理解）老年代是存放那些在程序中经历了好几次回收仍然还活着或者特别大的对象（这个大就要看你是否设置了-XX：PretenureSizeThreshold 参数了）。检查程序中是否有比较大的对象，或者这个参数设置是否合理。</p>
<ol start="5">
<li>Java 内存模型（JMM）</li>
</ol>
<blockquote>
<p>Java内存区域:PC+堆+本地方法栈+线程栈+方法区<br>
JMM:线程 和线程私有的工作内存(栈) 通过缓存一致性协议 实现对主内存的读写<br>
<img src="/images/JMM.png" alt="JMM"></p>
</blockquote>
<p>JVM 调优参数<br>
CyclicBarrier的使用<br>
CountDownLatch CyclicBarrier的使用</p>
<blockquote>
<p>多人回合制游戏(赛跑终点结束重新开始)<br>
CyclicBarrier<br>
包含一个可重入锁,该锁的condition,满足条件之后执行的任务(需要在其中设置退出条件不然无法退出),已经等待的人数<br>
方法：dowait:将调用线程 添加进condition的阻塞队列中,执行condition.wait 等待notifyAll(最后一个进入者执行既定任务,并重置一切);reset 重置一切重新使用</p>
</blockquote>
<p>GC 对象复制之后 的forward point<br>
OOpmap Cardtbale</p>
<p>fail-fast fail-safe</p>
<p>讲讲进程fork多个子进程和使用多线程的区别</p>
<ul>
<li>线程内fork进程,只能复制当前的线程</li>
<li>数据共享同步:进程间共享复杂,需要使用IPC,由于数据分离 所以同步简单,不需要加锁</li>
<li>资源(内存CPU)：进程占据资源多,切换复杂,CPU利用率低;</li>
<li>创建销毁：</li>
<li>编译调试复杂度</li>
<li>可靠性：进程之间不会有影响,线程挂了可能影响进程</li>
<li>分布式：进程适应天生支持分布式</li>
</ul>
<p>既然JVM有Full GC，为什么还会出现OutOfMemoryError?</p>
<ul>
<li>gc不了</li>
<li>产生对象太快来不及GC，GC需要安全点</li>
</ul>
<p>虚拟机性能检测工具</p>
<ul>
<li>jstat 虚拟机统计信息监控 -gc</li>
<li>jps：虚拟机进程状况检测</li>
<li>jinfo：java配置工具</li>
<li>jmap：java内存隐射工具</li>
<li>jstack java堆栈追踪工具</li>
<li></li>
</ul>
<p>升级老年代</p>
<ul>
<li>分配担保(允许担保失败的情况下进行mirroGC 可能引发fullgc)</li>
<li>年轻代 过15次GC</li>
<li>survior区的相同年龄的对象大于survior区的一般容量的话,那么大于这个年龄的进入老年代</li>
</ul>
<h2 id="jvm-调优">JVM 调优</h2>
<h2 id="synchronize-vs-lock-object-vs-condition">synchronize VS lock   object VS condition</h2>
<h3 id="synchronize">synchronize</h3>
<p>对象锁,保证只有一个线程能够获得锁,执行方法或者代码块,隐式的获得释放锁,无法感知中断<br>
可重入</p>
<h3 id="lock">lock</h3>
<p>相对于synchronize 更加灵活,需要显示的获得以及释放锁,可感知中断(lockInterruptly)<br>
其实现ReentrantLock 实现了lock接口,提供申请锁释放锁等基本功能<br>
ReentrantReadWriteLock实现了ReadWriteLock接口,读写分离,允许多线程读只允许一个线程写</p>
<h3 id="object-vs-condition">object VS condition</h3>
<p>Object</p>
<ul>
<li>wait:只能由获得锁的线程执行,释放锁并将自己放置在该对象的等待队列</li>
<li>notify:只能由获得锁的线程执行,会从该对象的等待队列中释放出一个线程,并不保证释放锁</li>
</ul>
<h3 id="blockedsynchronize-vs-waittingwait">blocked(synchronize) vs (waitting)wait</h3>
<p><a href="https://www.zhihu.com/question/27654579/answer/254496076" target="_blank" rel="noopener">参考</a><br>
线程新增了waitting 和 time-waitting 状态<br>
synchronize会导致线程陷入blocked状态,调用wait/LockSupport.park方法会导致线程陷入wait状态;notify会导致线程从waitting状态变为blocked状态</p>
<ul>
<li>blocked状态:对锁的等待导致陷入blocked,获得锁则进入ready或者运行态</li>
<li>waitting:调用 wait 或者 t.join 或者 LockSupport.pack 进入waiting态,notify/unpack 进入 block态</li>
<li>timed waitting:waiting方法中的增加了时间,以sleep方法(sleep方法不释放锁,时间过后进入就绪态) 超时或者被唤醒会进入block态</li>
</ul>
<p>thread yeild 将线程从运行态转化为就绪态</p>
<h3 id="objectwait-vs-conditionawait">object.wait  VS condition.await</h3>
<p>后者需要配合 lock使用,在利用CAS操作释放锁之后,执行LockSupport.park操作休眠线程,进入waitting态,等待unpack唤醒,进入阻塞 不需要处理中断异常(lock的lockinterrupt()中对此有相关处理)<br>
前者有系统提供支持,需要处理中断异常</p>
<h3 id="aqs-过程">AQS 过程</h3>
<h4 id="不包含condition">不包含condition</h4>
<p>lock操作尝试获取锁,失败后,将自己封装为head的next节点,只要自己的前继节点一直是head节点,那么死循环尝试获得锁,直到获得锁或者前继节点不是head节点,从而将调用LockSupport.park将自己休眠转化为waitting态<br>
unlock操作: 独占状态下,如果不再占有所,那么CAS更新独占线程标志位为null,并更新state否则仅更新state;根据该节点的waitstatus 决定是否通知后续的节点,如果通知那么会调用LockSupport.unpack 该节点的线程 进入阻塞态</p>
<h4 id="包含condition">包含condition</h4>
<p>condition的操作必然是在获得锁的前提下,进行的,等同object的操作<br>
lock获得锁成功<br>
condition.await():CAS 更新state,放弃锁,并调用LockSupport.park 放弃CPU时间<br>
此时因此而获得锁的线程执行signal操作,会找到该condition的阻塞队列里找到一个满足条件的 node,并调用LockSupport.park释放该node的线程,而线程获得CPU时间后,从LockSupport.park中返回,并尝试重新获得锁,要么获得锁或者陷入对lock的阻塞队列中<br>
如果获得锁,那么执行await后续代码,最后unlock释放锁</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/21/工作求职/DataStructure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/21/工作求职/DataStructure/" itemprop="url">DataStructure</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-21T16:07:22+08:00">
                2020-07-21
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-09-03T23:30:09+08:00" content="2020-09-03">
                2020-09-03
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>算法概述</p>
<h2 id></h2>
<p>递归<br>
动态规划<br>
树</p>
<h3 id="其他">其他</h3>
<p><a href="https://www.cnblogs.com/jason2003/p/9676729.html" target="_blank" rel="noopener">线段树</a></p>
<blockquote>
<p>这个东西感觉挺有意思</p>
</blockquote>
<p>红黑树</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/21/基础知识/Algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/21/基础知识/Algorithm/" itemprop="url">Algorithm</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-21T16:07:22+08:00">
                2020-07-21
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-08-30T13:21:09+08:00" content="2020-08-30">
                2020-08-30
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>算法概述</p>
<h2 id></h2>
<p>递归<br>
动态规划</p>
<p>###并查集<br>
<a href="https://blog.csdn.net/qq_19782019/article/details/78916595" target="_blank" rel="noopener">size数组和rank数组</a><br>
题目:<a href="https://leetcode-cn.com/problems/number-of-islands" target="_blank" rel="noopener">leetcode 200</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/06/工作求职/计算机网络/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/06/工作求职/计算机网络/" itemprop="url">计算机网络</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-06T09:29:04+08:00">
                2020-07-06
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-09-15T15:22:11+08:00" content="2020-09-15">
                2020-09-15
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基础问题">基础问题</h2>
<h3 id="http-报文键值对">http 报文键值对</h3>
<blockquote>
<p>host<br>
Content-*<br>
ACCEPT<br>
COOKIE</p>
</blockquote>
<h3 id="osi-7层">OSI 7层</h3>
<ul>
<li>物理层：电路交换 报文交换 分组交换</li>
<li>数据链路层：组帧,差错控制,流量控制,介质访问(频分时分波分码分复用)</li>
<li>网络层：异构网络互联;路由与转发;拥塞控制
<ul>
<li>ARP：查询IP与MAC地址的映射;DHCP：动态分配IP;ICMP:允许主机以及路由器报告差错情况;TRACEROTE</li>
<li>NAT CIDR(路由聚合)</li>
<li>OSPF RIP</li>
</ul>
</li>
<li>传输层：传输层寻址与端口;无连接服务和有连接服务
<ul>
<li>UDP:无连接不可靠,数据校验(源端口目的端口;udp报文长度;校 验和; 数据)</li>
<li>TCP：连接管理：可靠传输;流量控制和拥塞控制(源目的端口：序号确认号数据偏移;标志位：SYN ACK PUS FIN RST ；校验和 窗口字段)</li>
</ul>
</li>
<li>会话层</li>
<li>表示层(加密)</li>
<li>应用层：CS 模式 P2P模式
<ul>
<li>PING;HTTP:TCP 80</li>
<li>DNS udp 53</li>
<li>FTP TCP 2021</li>
<li>EMAIL:TCP SMTP:25 POP3 110</li>
</ul>
</li>
</ul>
<h3 id="close_wait-和-time_wait">close_wait 和 time_wait</h3>
<blockquote>
<p>close_wait 在 被关闭防 接收到fin报文时,发出ack 报文 进入close_wait状态 ,发送完报文,调用close(),close_wait 状态结束<br>
socket 其实就是一个五元组，包括：源IP, 源端口, 目的IP, 目的端口, 类型(TCP or UDP)<br>
TIME_WAIT</p>
<ul>
<li>防止前一个连接上延迟的数据包或者丢失重传的数据包，被后面复用的连接错误的接收</li>
<li>确保连接方能在时间范围内，关闭自己的连接(考虑到丢包的情况)</li>
</ul>
</blockquote>
<p>在高并发短连接的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接,避免有时出现客户端连接不上</p>
<ul>
<li>高并发导致服务器过多使用端口资源(0-65535)</li>
<li>短连接表示“业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间”的连接。<br>
解决：</li>
<li>开启SYN cookie</li>
<li>开启 tcp_tw_reuse 允许TIME_WAIT的socket重用于TCP连接</li>
<li>开启 tcp_tw_recycle,开启TCP连接中TIME-WAIT sockets的快速回收,会丢弃时间戳较小的syn报文(在最新的linux内核中放弃这个参数,可能导致tcp网络极不稳定)</li>
</ul>
<h4 id="time_wait-和-close_wait大量出现">time_wait 和 close_wait大量出现</h4>
<blockquote>
<p>当time_wait(2MSL 60S) 比较多时,客户建立的连接没有有效利用 ,可以考虑tcp长连接复用;</p>
</blockquote>
<blockquote>
<p>大量close_wait的现象，主要原因是某种情况下对方关闭了socket链接，但是我方忙与读或者写，没有关闭连接</p>
</blockquote>
<p>tcp为什么可靠，和udp的区别，序号的作用除了可靠性还有什么？</p>
<ul>
<li>校验</li>
<li>序列号和确认机制</li>
<li>序列号</li>
<li>重传机制</li>
</ul>
<h3 id="tcp三次握手四次挥手为什么要三次握手">TCP三次握手四次挥手，为什么要三次握手</h3>
<blockquote>
<p>三次握手是为了避免两次握手带来的漏洞（如果两次建立连接，那么假设A-&gt;B，B-&gt;A的请求未到达，B认为链接建立，放数据，A认为链接未建立，不接受数据，B数据超时会再重发，引发锁）<br>
四次挥手：最后一次挥手可能应为网络原因而丢失，故等待2MSL再没收到FIN 则认为对方收到了最后一次挥手<br>
数据传输，所以四次挥手而非3次</p>
</blockquote>
<p>TCP拥塞协议，tcpudp区别</p>
<ul>
<li>是否连接</li>
<li>是否可靠传输,保证有序</li>
<li>一对读通信,udp广播多播</li>
<li>面向报文,面向字节流</li>
<li>首部开销</li>
<li>使用场景：适用于实时场景(视频频电话直播),可靠的传输(文件数据传输)</li>
</ul>
<h3 id="http和https区别">HTTP和HTTPs区别</h3>
<blockquote>
<p>http：超文本传输协议，明文传播<br>
https： TCP 层与 HTTP 层之间加入了 SSL/TLS;http+ssl加密数据；<br>
对称加密，非对称加密（公钥加密，私钥解密，GitHub，ssh，身份签名）</p>
</blockquote>
<h3 id="http">HTTP</h3>
<blockquote>
<p>Method<br>
GET: 获取资源###<br>
HEAD: 获取报文头部###<br>
POST: 传输实体主体###<br>
PUT: 传输文件###<br>
DELETE: 删除文件###<br>
OPTIONS: 询问支持方法####<br>
Status Code：<br>
200 （成功） 服务器已成功处理了请求<br>
301 （永久移动） 永久重定向<br>
302 （临时移动）<br>
304 （未修改） 自从上次请求后，请求的网页未修改过。<br>
307 （临时重定向） 服务器目前从不同位置的网页响应请求<br>
401 （未授权） 请求要求身份验证<br>
403 （禁止） 服务器拒绝请求<br>
404 （未找到） 服务器找不到请求的网页<br>
500 （服务器内部错误） 服务器遇到错误，无法完成请求<br>
502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应</p>
<p>HTTP vs HTTPS<br>
https=http+对于数据进行SSL（Secure Sockets Layer）加密<br>
1.https协议需要到ca申请证书，一般免费证书较少<br>
2.http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议<br>
3.http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443<br>
4.http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全</p>
</blockquote>
<h3 id="http报文格式">http报文格式</h3>
<p>请求报文</p>
<ul>
<li>请求行：方法,url 协议版本 (GET /index.html HTTP/1.1)</li>
<li>请求头部 header 键值对(User-Agent,Accept,Host)</li>
<li>请求数据:GET 中不使用,POST中使用<br>
响应报文</li>
<li>状态行：HTTP-Version Status-Code Reason-Phrase(状态代码的文本描述)</li>
<li>消息报头</li>
<li>响应正文</li>
</ul>
<p>GET VS POST</p>
<ul>
<li>数据位置:GET提交,请求的数据会附在URL之后,POST提交：把提交的数据放置在是HTTP包的body中</li>
<li>数据长度:GET:特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节(2K+35) 而 POST对提交数据的大小有限制</li>
<li>安全性</li>
</ul>
<h4 id="ipv4-报文格式">IPV4 报文格式</h4>
<ul>
<li>版本 首部长度 总长度</li>
<li>标识 标志 片偏移(数据报分组之后在元报文的偏移量;数据链路层有最大报文传输单元限制MTU)</li>
<li>生存时间 具体协议(TCP UDP) 首部校验和</li>
<li>源目的地址</li>
<li>可选字段 填充</li>
<li>数据</li>
</ul>
<p>路由算法</p>
<ul>
<li>OSPF</li>
<li>RIP</li>
</ul>
<h4 id="dns">DNS</h4>
<p>13台根服务器 顶级域名服务器  权限域名服务器 本地域名服务器<br>
定义域名 一级域名  二级域名<br>
域名解析服务器分类：</p>
<ul>
<li>主域名服务器：负责维护一个区域所有域名信息，为特定域名的所有信息的权威来源，可以修改信息。</li>
<li>辅助域名服务器：当主域名服务器出现故障，关机或负载过重等情况，辅助域名服务器作为备份服务器来提供域名解析服务，辅助域名服务器是从另一台远程域名服务器下载的所有域名信息，域名信息不具有修改权限</li>
<li>缓存域名服务器：当从远程域名服务器获得域名解析信息后，将其缓存到高速缓存中，当下次需要请求相同的域名解析时，直接从本地缓存中读取，缓存域名信息不具有权威性</li>
<li>转发域名服务器：转发域名服务器用来请求不在本地域名服务器上的信息，当收到域名请求服务时，现在本地缓存中查取，如果查询不到。即依次向指定的域名服务器发出请求，直到查到所需信息返回结果。否则，返回无法映射的信息。<br>
dig :命令主要用来从 DNS 域名服务器查询主机地址信息</li>
</ul>
<h4 id="浏览器访问wwwbaiducom的过程"><a href="https://blog.nowcoder.net/n/a8337baa9c554acdab25b898f7b0970b" target="_blank" rel="noopener">浏览器访问www.baidu.com的过程</a></h4>
<blockquote>
<p>DNS域名解析:从浏览器缓存中获取,从本机/操作系统中尝试查找域名(host文件)</p>
<ul>
<li>如果在局域网,可能在路由器或者在ISP存在缓存</li>
<li>询问本地域名服务器,本地域名没有的话,询问根域名服务器,如果是迭代的话,可能从根域名服务器获得下一步需要去查询的顶级域名服务器,可能获得下一步的授权域名服务器,获得真实的IP,缓存并返回给主机。<br>
获得ip 然后发送TCP连接</li>
</ul>
</blockquote>
<p>tcpdump</p>
<blockquote>
<p>使用tcpdump抓包在卡顿的时候会抓到大量的syn请求</p>
</blockquote>
<p>SYN FLOOD</p>
<blockquote>
<p>前提:服务端在第二次握手时,就分配相关资源给该tcp连接<br>
synflood利用这一缺陷,大量发送syn request包,耗尽服务端的资源从而使之无法提供正常服务<br>
解决：<br>
限制ip的访问次数<br>
开启syncookie:在第二次握手时,不分配资源而是根据syn包的一些信息以及自己的秘钥经过算法计算出cookie值,下次返回ack 再计算一次,相同才开始分配资源;延迟资源分配到简历真正连接的时候</p>
</blockquote>
<p>http1 VS http1.1</p>
<ul>
<li>http1:增加HTTP头、扩展PUT、POST等方法</li>
<li>HTTP1.1 :长连接、流水线支持，最广泛使用的HTTP传输协议</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/06/工作求职/OS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/06/工作求职/OS/" itemprop="url">OS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-06T09:28:41+08:00">
                2020-07-06
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-10-07T12:45:13+08:00" content="2020-10-07">
                2020-10-07
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程状态及各状态之间的转换">线程状态及各状态之间的转换</h2>
<blockquote>
<p>新建状态、就绪状态、运行状态、阻塞状态及死亡状态</p>
</blockquote>
<h2 id="进程的内存结构">进程的内存结构</h2>
<blockquote>
<p>可执行文件的内容：代码段、数据段、BSS段和其他段<br>
代码段：代码<br>
数据段：存储初始化了的全局静态变量和局部静态变量和只读数据<br>
BSS段（Block Start By Symbol）:未初始化的全部静态变量和局部静态变量，为其预留空间<br>
其他段；保存于程序相关的其他信息，比如编译器信息，调试信息，动态链接信息等</p>
<p>装载可执行文件后，进程的空间大致可分为 代码区、数据区（bss+数据段）、向上的堆和向下的栈<br>
代码段：可读可执行<br>
数据段：可读可写<br>
堆：malloc 等程序员申请空间<br>
栈：系统运行时产生的变量，比如运行系统的信息、方法的参数、方法返回地址、局部变量等</p>
</blockquote>
<h2 id="线程的内存结构">线程的内存结构</h2>
<blockquote>
<p>线程共享进程的代码段，数据段，堆段，但是每个线程都拥有自己的私有栈，存储线程 ID、栈指针、PC、通用目的寄存器和条件码。<br>
Linux的线程栈是在进程的堆空间申请的。<br>
linux线程同步：<a href="https://www.cnblogs.com/yinbiao/p/11190336.html" target="_blank" rel="noopener">https://www.cnblogs.com/yinbiao/p/11190336.html</a><br>
互斥锁（临界区）：特殊全局变量划分临界区<br>
条件变量：等待该变量发生变化的等待队列，线程因特定条件休眠<br>
信号量：互斥锁只允许一个线程进入临界区，而信号量允许多个线程进入临界区<br>
读写锁：可以同时读，但不可以同时写</p>
</blockquote>
<h2 id="fork">fork</h2>
<blockquote>
<p>fork()函数用于从一个已经存在的进程内创建一个新的进程，新的进程称为“子进程”，相应地称创建子进程的进程为“父进程”。使用fork()函数得到的子进程是父进程的复制品，子进程完全复制了父进程的资源，包括进程上下文、代码区、数据区、堆区、栈区、内存信息、打开文件的文件描述符、信号处理函数、进程优先级、进程组号、当前工作目录、根目录、资源限制和控制终端等信息，而子进程与父进程的区别有进程号、资源使用情况和计时器等</p>
<p>由于复制父进程的资源需要大量的操作，十分浪费时间与系统资源，因此Linux内核采取了写时拷贝技术（copy on write）来提高效率<br>
在使用fork()函数创建子进程的时候，在调用fork()函数前是一个进程在执行这段代码，而调用fork()函数后就变成了两个进程在执行这段代码。两个进程所执行的代码完全相同，都会执行接下来的if-else判断语句块。</p>
<p>当子进程从父进程内复制后，父进程与子进程内都有一个&quot;pid&quot;变量：在父进程中，fork()函数会将子进程的PID返回给父进程，即父进程的pid变量内存储的是一个大于0的整数；而在子进程中，fork()函数会返回0，即子进程的pid变量内存储的是0；如果创建进程出现错误，则会返回-1，不会创建子进程。</p>
</blockquote>
<blockquote>
<p>父进程pid和子进程pid的大小关系<br>
如果进程ID最大值没有达到系统进程数的上限,子进程比父进程ID大.<br>
但是如果进程ID达到上限,系统会分配之前分配但是已经退出的进程ID给新进程,这样有可能出现子进程ID比父进程小.</p>
</blockquote>
<p>需要注意的是在一个线程中,调用fork函数,只会复制进程空间内该线程,不会复制其他线程(在当前线程上下文操作,该线程不能感知其他线程)</p>
<h2 id="内存管理">内存管理</h2>
<h3 id="非连续分配管理方式">非连续分配管理方式</h3>
<blockquote>
<p>允许程序分散的装入不相邻的内存分区 配合后面的虚存技术<br>
固定分区会产生内部碎片,动态分配会产生外部碎片<br>
根据分区的大小是否固定又分为 分页存储管理方式(基本分页存储管理方式和请求分页管理方式) 和 分段存储管理方式</p>
</blockquote>
<h4 id="基本分页管理方式">基本分页管理方式</h4>
<p>页的大小一般为4K(大小有页面大小和管理页的开销决定;内存为页帧,外存称之为块)<br>
从而把64位地址空间分为 页号和页内偏移量<br>
页表 为 <code>页号</code> 和 <code>块号</code> 的 对应<br>
系统中存在页表寄存器,包含 <code>页表的起始地址</code> <code>页表长度</code><br>
而每个进程都在进程控制块PCB存储自己的 页表寄存器值,当进程运行时将值放进页表寄存器 将进程内部的地址与之对应,把进程的虚拟地址的页号与之相对应 获取真实的块号(由于每次访存操作都涉及逻辑地址到物理地址的转换所以转换速度必须快,而且在内存中都需要存储页表 =&gt; 页表项即页号不能太大,页不能太小 同时 页太大会导致 内存利用率低加载慢 取折中 4K)</p>
<p>存储一个数据至少需要访问两次内存</p>
<ul>
<li>首先访问页表,获取块号</li>
<li>如果块在内存,就在内存中读取</li>
</ul>
<p>为了降低第一次访存的消耗,引入快表(联想寄存器TLB),即利用时间局部性原理 存储最近的页号和块号的映射</p>
<p>为了避免一层页表导致占据太多进程内存空间,引入多级页表(64位地址分为n级页号-1级页号),使得只需要保持当前使用的页表在内存即可(通过n级页号锁定n级页表)</p>
<h3 id="虚拟内存管理">虚拟内存管理</h3>
<p>处于局部性原理,不需要把进程的数据一次性装入内存;利用虚存技术,可以将内存的数据多次装入内存同时由于局部性原理保证程序的运行正常<br>
虚拟存储器基于局部性原理,给用户提供了远大于内存的空间;</p>
<h4 id="请求分页式">请求分页式</h4>
<p>页表机制+缺页中断机制+地址变换机制<br>
页表项= 页号 + 物理块号 + 状态位(是否在内存) + 访问字段 + 修改位 + 外存地址<br>
访问字段：用于记录页面在一段时间内的访问次数以及多长时间未被访问</p>
<h4 id="请求分段式">请求分段式</h4>
<h4 id="请求段页式">请求段页式</h4>
<h2 id="协程">协程</h2>
<blockquote>
<p>又称微线程，纤程。英文名Coroutine;<br>
可以看做用户态下的线程，协程的切换逻辑由可以在用户态下实现，同时不需要进行上下文的切换，因而相对于线程速度快很多；之所以不需要切换上下文，是因为传统的线程生命周期是一种嵌套形式的，同时只有一个线程有效，且线程无效后切换需要进行上下文的切换，而协程切换后，会向相应东西存放在随时可用的活动栈中(在堆中分配内存)<br>
每个协程都有自己私有栈,同时协程之间存在共享栈,由runnig-&gt;suspend设及私有栈恢复到共享栈,相反运行意味着保存到私有栈<br>
携程的状态从ready 到 running 到 susbpend 到 running 到 dead<br>
协程 VS 线程：不切换上下文;不涉及锁(自己实现协程间调度) 但linux并不支持携程 协程因为线程不会主动释放CPU时间,与机遇优先级抢占式的cpu调度不符</p>
</blockquote>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/94018082" target="_blank" rel="noopener">有栈协程实现原理</a> <a href="https://blog.csdn.net/liushengxi_root/article/details/85114692" target="_blank" rel="noopener">云风协程库保存和恢复协程运行栈原理讲解</a></p>
</blockquote>
<h2 id="作业调度算法">作业调度算法</h2>
<ul>
<li>FCFS：利于长进程，而不利于短进程</li>
<li>短作业优先：利于短进程，而不利于长进程</li>
<li>时间片轮转：时间片轮转调度算法</li>
<li>优先级调度算法</li>
<li>响应比高这优先：响应比= 等待时间+运行时间/运行时间 :既照顾了短进程，又考虑了进程到达的先后次序，也不会使长进程长期得不到服务，因此是一个比较全面考虑的算法，但每次进行调度时，都需要对各个进程计算响应比。所以系统开销很大，比较复杂</li>
<li>多级队列调度算法</li>
</ul>
<h2 id="存储器连续分配方式中分区分配算法">存储器连续分配方式中分区分配算法</h2>
<ul>
<li>首次适应分配算法:总是从第1条记录开始顺序查找空闲分区表，找到第一个能满足作业长度要求的空闲区，分割这个空闲区，一部分分配给作业，另一部分仍为空闲区</li>
<li>循环首次适应算法:每次分配均从上次分配的位置之后开始查</li>
<li>最佳适应分配算法(BF)：是按作业要求从所有的空闲分区中挑选一个能满足作业要求的最小空闲区，这样可保证不去分割一个更大的区域，使装入大作业时比较容易得到满足。为实现这种算法，把空闲区按长度递增次序登记在空闲区表中，分配时，顺序查找。</li>
<li>最坏适应算法(worst fit algorithm)：要求空闲区按其大小递减的顺序组成空闲区可用表或自由链。当用户作业或进程申请一个空闲区时，先检查空闲区可用表或自由链的第一个空闲可用区的大小是否大于或等于所要求的内存长度，若可用表或自由链的第一个项所示空闲区长度小于所要求的，则分配失败，否则从空闲区可用表或自由链中分配相应的存储空间给用户，然后修改和调整空闲区可用表或自由链。</li>
</ul>
<h2 id="页面置换算法">页面置换算法</h2>
<ul>
<li>最佳置换算法（OPT) ：选择以后永不使用或在最长时间内不再被访问的内存页面予以淘汰。</li>
<li>先进先出置换算法（FIFO）：选择最先进入内存的页面予以淘汰。</li>
<li>最近最久未使用算法（LRU）：选择在最近一段时间内最久没有使用过的页，把它淘汰。</li>
<li>最少使用算法（LFU）：选择到当前时间为止被访问次数最少的页转换。</li>
<li>时钟算法/最近未用算法：使用访问位和修改位标记页,优先替换未使用未修改的页,然后替换已修改的页。</li>
</ul>
<h2 id="页面分配策略">页面分配策略</h2>
<p>分页式的虚拟内存系统,对于每个进程如何分配主存空间</p>
<ul>
<li>固定分配局部置换：每个进程固定分配物理块,置换只发生在进程分配的空间</li>
<li>可变分配全局置换：每个进程分配少量物理块,同时维持全局空闲块,进程空间不足时从全局获取</li>
<li>可变分配局部置换：每个进程分配部分物理块,根据每个进程的缺页频率,动态增减进程的空间物理块数</li>
</ul>
<h2 id="磁盘调度">磁盘调度</h2>
<ul>
<li>先来先服务（FCFS）：是按请求访问者的先后次序启动磁盘驱动器，而不考虑它们要访问的物理位置</li>
<li>最短寻道时间优先（SSTF）：让离当前磁道最近的请求访问者启动磁盘驱动器，即是让查找时间最短的那个作业先执行，而不考虑请求访问者到来的先后次序，这样就克服了先来先服务调度算法中磁臂移动过大的问题</li>
<li>扫描算法（SCAN）或电梯调度算法：总是从磁臂当前位置开始，沿磁臂的移动方向去选择离当前磁臂最近的那个柱面的访问者。如果沿磁臂的方向无请求访问时，就改变磁臂的移动方向。在这种调度方法下磁臂的移动类似于电梯的调度，所以它也称为电梯调度算法。</li>
<li>循环扫描算法（CSCAN）：循环扫描调度算法是在扫描算法的基础上改进的。磁臂改为单项移动，由外向里。当前位置开始沿磁臂的移动方向去选择离当前磁臂最近的哪个柱面的访问者。如果沿磁臂的方向无请求访问时，再回到最外，访问柱面号最小的作业请求。</li>
</ul>
<h2 id="高速缓存与主存的三种映射方式">高速缓存与主存的三种映射方式</h2>
<ul>
<li>全相联映射：存中任意一个块都可以映射到cache中任意一个块的方式:利用率高但寻找困难</li>
<li>直接相联映射：内存块数%cache块数的值或者其低位地址决定其映射的cache行;寻找方便但是冲突率高</li>
<li>组相连映射:把cache分为x行一组,共y组,对于组实行直接相连映射,对于组内全相联映射</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/83597838" target="_blank" rel="noopener">参考0</a><br>
<a href="https://www.zhihu.com/question/19732473/answer/241673170" target="_blank" rel="noopener">参考1</a><br>
BIO NIO AIO<br>
同步 VS 异步</p>
<blockquote>
<p>是否需要自己主动去获取结果;<br>
场景：发送完请求,可以不等待请求结果,发送下一个请求,提高效率,保证并发<br>
是否存在异步阻塞IO?既然异步了,由OS负责准备数据到用户空间,由OS和线程/进程争抢总线,完成之后通知结果,进程本身可以轮询,仍然有自己控制,不算阻塞把</p>
</blockquote>
<p>阻塞 VS 非阻塞</p>
<blockquote>
<p>调用者是否被阻塞,或者说丧失自由/放弃CPU时间<br>
传统的IO流都是阻塞式的</p>
<ul>
<li>本地IO:当一个线程调用read()或者write()方法时，该线程将被阻塞，直到有一些数据读读取或者被写入，在此期间，该线程不能执行其他任何任务</li>
<li>网络IO：在完成网络通信进行IO操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量的客户端时，性能急剧下降<br>
非阻塞IO 不阻塞当前线程,可以做其他事情;由于大多时候,IO操作并不频繁,每个通道/外设 不是随时都有,所以可以有少数线程负责很多IO的输入输出的管理(减少上下文切换时间)</li>
</ul>
</blockquote>
<p>IO模型主要分类：</p>
<ul>
<li>同步IO 和 异步IO</li>
<li>阻塞IO 和 非阻塞IO</li>
<li>同步阻塞IO(synchronize block io): BIO</li>
<li>同步非阻塞IO(synchronize noblock io)</li>
<li>IO多路复用JAVA NIO</li>
<li>异步非阻塞IO(asychronous noblock io): AIO/IOCP</li>
</ul>
<p>用户程序进行IO的读写，基本上会用到系统调用read&amp;write，read把数据从内核缓冲区复制到进程缓冲区，write把数据从进程缓冲区复制到内核缓冲区，它们不等价于数据在内核缓冲区和磁盘之间的交换。<br>
BIO</p>
<blockquote>
<p>创建连接的那个线程会阻塞自己到等待数据到达,由内核进程复制数据到用户空间,之后可以运行</p>
</blockquote>
<p>同步非阻塞</p>
<blockquote>
<p>创建连接的线程调用完之后可以得到是否调用成功的结果,然后可以轮询询问是否完成(也可以分批获取缓冲区的数据,不必要一次性获得)<br>
适用于大量网络连接且IO不频繁的状态,避免大量创建线程同时可以从内核缓冲区读取不完整的数据(例如拆包粘包Netty)</p>
</blockquote>
<p>NIO</p>
<blockquote>
<p>创建连接的线程向selector注册一个channel,由其负责处理所有I操作,监控channel,并分发写进buffer,然后自己转做其他事情</p>
</blockquote>
<p>BIO VS NIO</p>
<blockquote>
<p>面向流 面向缓冲区<br>
阻塞   非阻塞<br>
无     selector</p>
</blockquote>
<p>BIO、NIO、AIO适用场景</p>
<blockquote>
<p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择。<br>
NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂。<br>
AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持</p>
</blockquote>
<p>selcet/poll/epoll 都属于 同步IO</p>
<p>Netty</p>
<h3 id="大端存储-小端存储">大端存储 小端存储</h3>
<blockquote>
<p>大端存储与小端存储模式主要指的是数据在计算机中存储的两种字节优先顺序。<br>
小端存储指从内存的低地址开始,先存储数据的低序字节再存高序字节;相反,大端存储指从内存的低地址开始,先存储数据的高序字节再存储数据的低序字节</p>
</blockquote>
<p>用途：</p>
<blockquote>
<p>小端存储:常见于本地主机上(也有部分类型主机为大端存储)<br>
大端存储:常见于网络通信上，网际协议TCP/IP在传输整型数据时一般使用大端存储模式表示,例如TCP/IP中表示端口和IP时，均采用的是大端存储</p>
</blockquote>
<p>如何避免死锁：</p>
<ul>
<li>银行家算法：分配资源前先评估风险，会不会在分配后导致死锁。</li>
<li>顺序加锁，这样能防止死锁现象</li>
</ul>
<p>多线程 VS 多进程</p>
<ul>
<li>线程只是进程的一个执行路径</li>
</ul>
<h3 id="文件描述符">文件描述符</h3>
<p><a href="https://segmentfault.com/a/1190000009724931" target="_blank" rel="noopener">文件描述符（File Descriptor）简介</a><br>
系统为了维护文件描述符,维持了3个层次的表</p>
<ul>
<li>进程层次的文件描述符表
<ul>
<li>文件描述符flag</li>
<li>指向系统级表的指针</li>
</ul>
</li>
<li>系统级的文件描述符表
<ul>
<li>当前文件的偏移</li>
<li>状态标识</li>
<li>文件访问模式:读 写 读写</li>
<li>inode引用</li>
<li>其他:访问权限,文件其他属性等</li>
</ul>
</li>
<li>文件系统的inode表
<ul>
<li>文件类型</li>
<li>文件锁</li>
</ul>
</li>
</ul>
<p>当我们打开一个文件或者建立socket时,会返回一个文件描述符,就是一个数字(0 1 2 分别默认标准输入/输出/错误输出),标识在进程空间内文件描述符表的索引(进程描述符表的长度默认为1024)</p>
<p>socket 连接使用过程</p>
<ul>
<li>create socket :寻找inode文件,创建相关数据结构,并返回文件描述符</li>
<li>bind：把socket与ip port 绑定(客户端无需调用,在connect时会自动分配一个port)</li>
<li>listen：将连接socket转化为监听套接字(更改socket状态为LISTEN)由tcp/ip协议簇完成监听</li>
<li>accept:
<ul>
<li>客户端会通过connect连接服务端,服务端会维持两个连接队列,未完成3次握手的和已完成3次握手的</li>
<li>accept函数默认为阻塞函数,当已完成握手连接队列非空时,会返回队列首的连接文件描述符(一个完整的连接套接字,包含源目的端口ip,这样可以实现socket复用)</li>
</ul>
</li>
<li>send/recv：</li>
<li>select/poll/epoll
<ul>
<li>select 成功返回就绪的文件描述符数量,如果&gt;0,则循环遍历事件,然后确定是哪个并处理</li>
</ul>
</li>
</ul>
<p>socket描述</p>
<blockquote>
<p>accept建立连接之后,返回一个文件描述符,指向socket套接字,包含源ip/端口 目的ip/端口 也就是父进程与fork出的子进程共同监听一个端口,但是由于请求类型不同(建立连接由主进程负责,而已建立的连接由多个子进程竞争锁获得负责) 可以区分<br>
<a href="http://blog.chinaunix.net/uid-23629988-id-285722.html" target="_blank" rel="noopener">kernel如何选择socket接收数据</a> 根据协议选择不同链表,然后遍历选择(源ip端口等信息)最符合的socket</p>
</blockquote>
<p>select</p>
<blockquote>
<p>在内核处理时需要两次循环遍历发现就绪,在外也需要循环遍历发现就绪事件,耗时,且传进去的fd_set位图表示监视的文件描述符,默认限制1024长度<br>
select在调用时使用不同set表示监听不同的事件类型(读写异常);do-select 中会对调用返回对应文件的poll函数,检测是否有时间发生,如果发生返回类型mask,并判断是否是读/写/异常,然后添加进不同的返回列表中;</p>
</blockquote>
<p>poll<br>
<a href="https://blog.51cto.com/10706198/1783610" target="_blank" rel="noopener">使用示例</a></p>
<h4 id="select-解析">select 解析</h4>
<p><a href="http://lxr.linux.no/linux+v3.9/fs/select.c" target="_blank" rel="noopener">select 内核源码</a><br>
<a href="https://blog.csdn.net/weixin_42462202/article/details/95315926" target="_blank" rel="noopener">Linux select内核源码剖析</a><br>
<a href="https://blog.csdn.net/caogenwangbaoqiang/article/details/80949643" target="_blank" rel="noopener">select模型linux内核源码注释总结</a></p>
<p>select函数的参数</p>
<ul>
<li>最大文件描述符+1</li>
<li>读事件监听set</li>
<li>写事件监听set</li>
<li>异常事件监听set</li>
<li>默认等待时间(null:阻塞;0:立刻返回;其他)</li>
</ul>
<p>select -&gt; do_select<br>
在死循环中,</p>
<ul>
<li>遍历文件描述符,并调用其poll函数,将该进程添加进其等待队列 然后陷入睡眠</li>
<li>如果时间到达或者被中断唤醒,会继续循环遍历文件描述符,如果调用poll函数后发现有时间发生,就绪事件记录+1,遍历完成后,如果就绪事件&gt;0或者等待超时,就跳出死循环,否则继续休眠</li>
</ul>
<p>缺点：</p>
<ul>
<li>fd set长度有限制</li>
<li>需要在用户空间和内核空间之间拷贝fdset数据</li>
<li>检查是否发生事件时,是轮询遍历,而且范围内包含不关注的文件描述符;返回结果也需要轮询</li>
</ul>
<h3 id="poll-解析">poll 解析</h3>
<p><a href="https://blog.51cto.com/10706198/1783610" target="_blank" rel="noopener">使用示例</a><br>
<a href="http://gityuan.com/2019/01/05/linux-poll-select/" target="_blank" rel="noopener">源码解析</a><br>
<a href="https://www.cnblogs.com/shuqin/p/11662645.html" target="_blank" rel="noopener">poll(2) 源码分析</a><br>
poll 函数的参数</p>
<ul>
<li>pollfd数组</li>
<li>最大文件描述符</li>
<li>时间</li>
</ul>
<p>poll利用 pollfd 结构体记录 file-description 和 event(POLLINT/POLLOUT/异常) 以及 revents(系统触发的事件)<br>
过程</p>
<ul>
<li>利用 pollfd 数组记录监听的文件描述符对应的连接以及类型;</li>
<li>之后调用poll函数,其内会将数组转化为链表(按页分配内存申请内存,每页存储一个pollfd数组,利用<a href="https://lenzhao.com/topic/5a28f4b52e95f0fd0a9818a8" target="_blank" rel="noopener">copy_from_user</a>把用户空间的pollfd拷贝到核心空间,然后next页,如果分配失败就会free所有节点,然后返回内存错误);</li>
<li>之后根据链表来遍历;大致过程与select类似,但是会将触发的事件类型记录在revents中(首先会过滤掉不感兴趣的事件);并通过copy_to_user 拷贝回用户空间</li>
<li>在poll返回的结果&gt;0则会轮询查询event与revents是否一致</li>
</ul>
<p>相对于select 突破了1024的默认长度限制,只要满足长度小于RLIMIT_NOFILE(进程最大打开文件描述符限制即可;可以设置65535)</p>
<p>缺点：</p>
<ul>
<li>仍需在用户和内核空间拷贝数据,量变得更大</li>
<li>相对于select更精确,但检查事件以及返回时然后需要遍历确认</li>
</ul>
<h3 id="epoll-解析">epoll 解析</h3>
<p><a href="http://lxr.linux.no/linux+v3.9/fs/eventpoll.c" target="_blank" rel="noopener">eventspoll源码</a><br>
<a href="http://lxr.linux.no/linux+v3.9/include/linux/fs.h" target="_blank" rel="noopener">struct file</a><br>
<a href="http://wxgg.cc/blogs/2018/12/libevent-cpp-5-%E5%B0%81%E8%A3%85epoll%E5%8F%8Aepoll%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" target="_blank" rel="noopener">封装epoll及epoll内核实现原理</a><br>
<a href="https://www.iminho.me/wiki/blog-23.html" target="_blank" rel="noopener">IO多路复用原理剖析</a><br>
<a href="http://gityuan.com/2019/01/06/linux-epoll/" target="_blank" rel="noopener">源码解读epoll内核机制</a><br>
<a href="https://www.cnblogs.com/apprentice89/p/3234677.html" target="_blank" rel="noopener">epoll用法回顾</a><br>
<a href="https://icoty.github.io/2019/06/03/epoll-source/" target="_blank" rel="noopener">epoll源码分析(基于linux-5.1.4)</a><br>
<a href="https://zhuanlan.zhihu.com/p/64746509" target="_blank" rel="noopener">如果这篇文章说不清epoll的本质，那就过来掐死我吧</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct eventpoll &#123;</span><br><span class="line">    spinlock_t lock;</span><br><span class="line">    struct mutex mtx;</span><br><span class="line">    //调用epoll_wait过程中陷入阻塞的进程队列</span><br><span class="line">    wait_queue_head_t wq;</span><br><span class="line">    //与文件相关的等待队列,保存了所有等待该文件相关事件的进程(file-&gt;poll()),对于该文件的读写操作会唤醒该队列</span><br><span class="line">    wait_queue_head_t poll_wait;</span><br><span class="line">    //就绪状态的文件描述符的列表</span><br><span class="line">    struct list_head rdllist;</span><br><span class="line">    //存储监控的红黑树</span><br><span class="line">    struct rb_root rbr;</span><br><span class="line">    struct file *file;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>过程：</p>
<ul>
<li>epoll_create:创建file实例,创建eventpoll,赋值给file-&gt;private_date,获得未使用fd与改file绑定,然后返回fd</li>
<li>epoll_ctl:控制监听的事件,增加/删除/修改,实质是通过对之前创建的eventpoll中的红黑树进行操作以insert为例
<ul>
<li>初始化epollitem(fd file)</li>
<li>初始化ep_pqueue,添加到socket文件的等待队列并注册回调函数ep_ptable_queue_proc-&gt;ep_poll_callback(判断是否是感兴趣的事件,添加进epoll的就绪队列,并唤醒epoll在wait阶段的阻塞进程)</li>
<li>在红黑树中插入节点</li>
</ul>
</li>
<li>epoll_wait: 调用 ep_poll ,在死循环中判断:如果就绪队列为空,那么休眠,将自己阻塞在eventpoll的等待队列,等待ep_poll_callback 唤醒 否则跳出循环,拷贝就绪队列的events事件到用户空间</li>
</ul>
<p>其他</p>
<ol>
<li>红黑树中存储需要监听的事件,节点类型是epollitem,比较的方法是首先比较socket对应的file指针地址(没看到重写比较符) 然后比较fd值</li>
<li>ep_poll_callback 函数 会首先将当前触发的操作的添加到eventpoll的就绪队列,然后唤醒该eventpoll的等待队列</li>
</ol>
<p>优点:相对于select/poll 的轮询和数据拷贝操作</p>
<ul>
<li>利用回调函数,在唤醒时将就绪的文件添加到就绪队列,拷贝回用户空间,无需轮询(将之前的wait操作拆分为ctl和wait操作)</li>
<li>利用eventpoll中的红黑树存储关注的文件描述符和事件,无需频繁的拷贝所有数据</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于大量的频发事件,会频繁调用回调函数,效率不高,适合大量低速的连接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct epitem &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        struct rb_node rbn; //RB树节点将此结构链接到eventpoll RB树</span><br><span class="line">        struct rcu_head rcu; //用于释放结构体epitem</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    struct list_head rdllink; //用于将此结构链接到eventpoll就绪列表的列表标头</span><br><span class="line">    struct epitem *next; //配合ovflist一起使用来保持单向链的条目</span><br><span class="line">    struct epoll_filefd ffd; //此条目引用的文件描述符信息</span><br><span class="line">    int nwait; //附加到poll轮询中的活跃等待队列数</span><br><span class="line"></span><br><span class="line">    struct list_head pwqlist;</span><br><span class="line">    struct eventpoll *ep;  //epi所属的ep</span><br><span class="line">    struct list_head fllink; //链接到file条目列表的列表头</span><br><span class="line">    struct wakeup_source __rcu *ws; //设置EPOLLWAKEUP时使用的wakeup_source</span><br><span class="line">    struct epoll_event event; //监控的事件和文件描述符</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="et-lt">ET LT</h3>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/05/Blog/个人网站/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/05/Blog/个人网站/" itemprop="url">个人网站搭建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-05T22:52:19+08:00">
                2020-07-05
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-12-09T20:15:05+08:00" content="2020-12-09">
                2020-12-09
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="域名">域名</h1>
<h2 id="域名购买">域名购买</h2>
<p>国内域名</p>
<h2 id="域名解析">域名解析</h2>
<p>godaddy<br>
国内解析<br>
cloudflare</p>
<h1 id="审核">审核</h1>
<h2 id="阿里云-初审">阿里云 初审</h2>
<p>主要是网站名称的问题，发现不能使用成语。</p>
<h2 id="管局审核">管局审核</h2>
<h2 id="公安局审核">公安局审核</h2>
<p>公安联网备案申请</p>
<h1 id="部署">部署</h1>
<h2 id="服务器部署hexo">服务器部署hexo</h2>
<h3 id="安装必要软件">安装必要软件</h3>
<p>git nginx<br>
‘’’<br>
sudo apt-get-install nodejs npm<br>
npm install -g hexo-cli<br>
‘’’</p>
<h3 id="配置服务器文件夹接受本地hexo传输文件">配置服务器文件夹接受本地hexo传输文件</h3>
<p>参考<a href="https://www.cnblogs.com/luoshuitianyi/p/10333928.html" target="_blank" rel="noopener">Hexo搭建(VPS)</a></p>
<ol>
<li>创建裸仓库，用于接受文件</li>
</ol>
<p>‘’’<br>
mkdir hexo.git<br>
cd hexo.git<br>
git init --bare # 裸仓库只存储历史和元数据信息，不维护工作目录<br>
‘’’</p>
<ol start="2">
<li></li>
</ol>
<ol start="4">
<li>
<p>配置https<br>
从阿里云申请免费证书，下载证书，放置在相关位置，并修改nginx配置文件<br>
‘’’<br>
#Config of Hexo<br>
server {<br>
listen 80;<br>
listen [::]:80;<br>
server_name _;</p>
<pre><code> rewrite ^/(.*)$ https://www.whetstone.life:443/$1 permanent;
</code></pre>
</li>
</ol>
<p>}<br>
#Config of https<br>
server {<br>
listen 443;<br>
listen [::]:443;<br>
server_name _;<br>
ssl on;<br>
ssl_certificate /etc/nginx/ssl/www.whetstone.life.pem;<br>
ssl_certificate_key /etc/nginx/ssl/www.whetstone.life.key;<br>
ssl_session_timeout 5m;<br>
ssl_protocols TLSv1 TLSv1.1 TLSv1.2;<br>
ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;<br>
ssl_prefer_server_ciphers on;</p>
<pre><code>    server_name _;
    location / {
            root /var/www/hexo;
            index index.html;
    }
</code></pre>
<p>}<br>
‘’’</p>
<p>修改防火墙,在阿里云ECS实例中修改安全组规则<br>
‘’’<br>
iptables -A INPUT -p tcp --dport 443 -j ACCEPT<br>
‘’’</p>
<h2 id="配置-ssh-互信">配置 ssh 互信</h2>
<p>只需要服务器信任本地host即可,方便从本地传输文件到服务器无需输入密码<br>
‘’’<br>
scp ./.ssh/id_rsa.pub root@ip:/root<br>
cat id_rsa.pub &gt; .ssh/authorized_keys<br>
‘’’</p>
<h2 id="本地hexo配置deploy">本地hexo配置deploy</h2>
<p>配置多个deploy对象，参考 <a href="https://hexo.io/zh-cn/docs/one-command-deployment" target="_blank" rel="noopener">hexo deploy配置</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/05/Blog/blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/05/Blog/blog/" itemprop="url">blog 产生记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-05T22:52:19+08:00">
                2020-07-05
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-12-09T16:00:31+08:00" content="2020-12-09">
                2020-12-09
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">chengr</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">98</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">54</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chengr</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
