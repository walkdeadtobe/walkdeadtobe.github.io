<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":250,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="知行合一">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="知行合一">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="知行合一">

<link rel="canonical" href="http://yoursite.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>知行合一</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">知行合一</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/28/工作求职/面经收集/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/28/工作求职/面经收集/" class="post-title-link" itemprop="url">面经收集</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-28 15:30:33" itemprop="dateCreated datePublished" datetime="2020-08-28T15:30:33+08:00">2020-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-15 10:57:59" itemprop="dateModified" datetime="2021-01-15T10:57:59+08:00">2021-01-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Java 后台开发<br>
<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">Github 知识总结</a></p>
<ul>
<li><a href="https://www.nowcoder.com/discuss/491234?channel=1013&amp;source_id=home_feed" target="_blank" rel="noopener">美团一面</a></li>
</ul>
<p>面试问题收集：</p>
<ol>
<li>
<p>volatile不是线程安全<br>
线程安全必须保证原子性，可见性，有序性。而volatile只能保证可见性和有序性,volatile 只能保证 可见性,有序性 不能保证操作的原子性,建议使用CAS操作 利用cocurrent.atomic包下面的封装</p>
</li>
<li>
<p>配置线程池需要考虑哪些因素</p>
</li>
</ol>
<blockquote>
<p>从任务的优先级，任务的执行时间长短，任务的性质（CPU密集/ IO密集），任务的依赖关系这四个角度来分析。并且近可能地使用有界的工作队列。<br>
性质不同的任务可用使用不同规模的线程池分开处理：</p>
</blockquote>
<ul>
<li>CPU密集型：尽可能少的线程，Ncpu+1</li>
<li>IO密集型：尽可能多的线程, Ncpu*2，比如数据库连接池</li>
<li>混合型：CPU密集型的任务与IO密集型任务的执行时间差别较小，拆分为两个线程池；否则没有必要拆分。</li>
</ul>
<ol start="3">
<li>集群基本概念—脑裂的产生和解决方案<br>
<a href="https://www.cnblogs.com/kevingrace/p/12433503.html" target="_blank" rel="noopener">脑裂</a></li>
</ol>
<ul>
<li>限定发送人数,确定集群有效无效</li>
<li>冗余通信(物理)</li>
<li>仲裁方式</li>
<li>磁盘锁定</li>
</ul>
<ol start="4">
<li>Map 接口及其实现类</li>
</ol>
<blockquote>
<p>HashMap<br>
LinkedHashMap<br>
TreeMap<br>
HashTable<br>
WeakHashMap:以弱键 实现的基于哈希表的 Map。在 WeakHashMap 中，当某个键不再正常使用时，将自动移除其条目。更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收<br>
EnumMap</p>
</blockquote>
<ol start="5">
<li>StringBuilder StringBuffer</li>
</ol>
<blockquote>
<p>StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。<br>
由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p>
</blockquote>
<ol start="6">
<li>
<p>juc</p>
</li>
<li>
<p>几个垃圾回收器（3对+1），Serial与Serial Old ,ps和po  ，pn和cms，g1</p>
</li>
<li>
<p>对象创建的生命周期(栈，线程本地，堆)，对象的分配(一般对象，大对象，一直存在的对象)，如何判断一个对象是否是垃圾对象(介绍了两个方法，各自特点)，强软弱需引用，有哪些垃圾回收算法（4个方法），各自的特点，还说了几个垃圾回收器（3对+1），Serial与Serial Old ,ps和po  ，pn和cms，g1，还介绍了各自的优点缺点，jdk怎么用的，stw的情况，还说了如何调优，jdk1.8默认ps po的调优（介绍了几个指令），最后还说了，我用的一直都是idea默认版本pspo。</p>
</li>
<li>
<p>AOP原理了解吗？</p>
</li>
</ol>
<blockquote>
<p>恒切面;切点；通知</p>
</blockquote>
<ol start="10">
<li>
<p>shard</p>
</li>
<li>
<p>分布式session</p>
</li>
</ol>
<ul>
<li>粘性session：粘性Session是指将用户锁定到某一个服务器上;在nginx出配置;但容错性低</li>
<li>服务器session复制：修改 传播所有机器</li>
<li>session共享机制：reids共享</li>
</ul>
<ol start="12">
<li>MySQL Explain详解</li>
</ol>
<blockquote>
<p>explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看</p>
</blockquote>
<ol start="13">
<li>concurrenthashmap 是否线程安全?</li>
</ol>
<blockquote>
<p>concurrenthashmap的线程安全是指他的put和get操作是原子操作，是线程安全的;outIfabsent</p>
</blockquote>
<ol start="14">
<li>在一个千万级的数据库查寻中，如何提高查询效率？</li>
</ol>
<ul>
<li>分表：femmale 枚举字段 分表</li>
<li>优化查询,避免全表查询,建立并使用索引</li>
<li>应尽可能的避免更新索引数据列(insert)，因为索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新索引数据列，那么需要考虑是否应将该索引建为索引</li>
<li>避免临时操作</li>
<li>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</li>
<li>避免全表查询
<ul>
<li>where 子句中使用!=或&lt;&gt;</li>
<li>where 子句中使用 or 来连接条件</li>
<li>in 和 not in  like</li>
</ul>
</li>
</ul>
<ol start="15">
<li>微信红包算法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static double getRandomMoney(RedPackage _redPackage) &#123;</span><br><span class="line">        // remainSize 剩余的红包数量</span><br><span class="line">        // remainMoney 剩余的钱</span><br><span class="line">        if (_redPackage.remainSize == 1) &#123;</span><br><span class="line">            _redPackage.remainSize--;</span><br><span class="line">            return (double) Math.round(_redPackage.remainMoney * 100) / 100;</span><br><span class="line">        &#125;</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        double min = 0.01; //</span><br><span class="line">        double max = _redPackage.remainMoney / _redPackage.remainSize * 2;</span><br><span class="line">        double money = r.nextDouble() * max;</span><br><span class="line">        money = money &lt;= min ? 0.01 : money;</span><br><span class="line">        money = Math.floor(money * 100) / 100;</span><br><span class="line">        _redPackage.remainSize--;</span><br><span class="line">        _redPackage.remainMoney -= money;</span><br><span class="line">        return money;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="16">
<li>为什么用B+树？</li>
</ol>
<blockquote>
<p>磁盘IO开销小 栈空间较小<br>
查找比较稳定。效率比较高</p>
</blockquote>
<ol start="17">
<li>解决哈希冲突有如下的方法：</li>
</ol>
<blockquote>
<p>开放定址法(线性探测，二次探测，伪随机探测)<br>
链地址法<br>
再散列法（双重散列，多重散列）<br>
建立一个公共溢出区</p>
</blockquote>
<ol start="18">
<li>外排序</li>
</ol>
<blockquote>
<p>利用外存也就是磁盘进行排序的一种简称。<br>
典型的应用是hadoop　的 mapreduce 的merge 阶段(map shuffle reduce)</p>
</blockquote>
<ol start="19">
<li>秒杀怎么解决超卖</li>
</ol>
<blockquote>
<p>redis 缓存数据库压力;消息队列;分步骤 下单 和 真正获取订单;限制用户访问频率和次数</p>
</blockquote>
<ol start="20">
<li>消息队列</li>
</ol>
<blockquote>
<p>异步通信:降低服务耦合;提高并发度;流量削峰</p>
</blockquote>
<ol start="21">
<li>HashMap 30分钟<br>
<a href="https://blog.csdn.net/zhengwangzw/article/details/104889549" target="_blank" rel="noopener"> HashMap 30分钟</a></li>
</ol>
<ul>
<li>因为1.7头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环；</li>
</ul>
<ol start="22">
<li>
<p>2-3树到红黑树</p>
</li>
<li>
<p>存储过程</p>
</li>
</ol>
<blockquote>
<p>存储过程可以说是一个记录集吧，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就<br>
由于数据库执行动作时，是先编译后执行的。然而存储过程是一个编译过的代码块，所以执行效率要比T-SQL语句高<br>
一个存储过程在程序在网络中交互时可以替代大堆的T-SQL语句，所以也能降低网络的通信量，提高通信</p>
</blockquote>
<ol start="24">
<li>linux 管道</li>
</ol>
<blockquote>
<p>管道是Linux中很重要的一种通信方式,是把一个程序的输出直接连接到另一个程序的输入,常说的管道多是指无名管道,无名管道只能用于具有亲缘关系的进程之间，这是它与有名管道的最大区别。</p>
</blockquote>
<ul>
<li>管道是一个固定大小的缓冲区。在Linux中，该缓冲区的大小为1页，即4K字节，使得它的大小不象文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，当这种情况发生时，随后对管道的write()调用将默认地被阻塞</li>
<li>读取进程也可能工作得比写进程快。当所有当前进程数据已被读取时，管道变空。当这种情况发生时，一个随后的read()调用将默认地被阻塞，等待某些数据被写入，这解决了read()调用返回文件结束的问题。</li>
<li>半双工</li>
</ul>
<ol start="25">
<li>request和response</li>
</ol>
<blockquote>
<p>Web服务器收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象、和代表响应的response对象</p>
</blockquote>
<ol start="26">
<li>NIO</li>
</ol>
<blockquote>
<p>NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道</p>
</blockquote>
<ol start="27">
<li>HashMap HashTable CocurrentHashmap LinkedHashMap TreeHashMap</li>
</ol>
<blockquote>
<p>JDK1.7版本锁的粒度是基于Segment的，包含多个HashEntry(ReentrantLock+Segment+HashEntry): volatile HashEntry&lt;K,V&gt; 确保可见性<br>
DK1.8锁的粒度就是HashEntry（首节点）(synchronized+CAS+HashEntry+红黑树)</p>
</blockquote>
<ol start="28">
<li>MVC 处理流程</li>
</ol>
<blockquote>
<p>用户发送请求至前端控制器DispatcherServlet<br>
DispatcherServlet收到请求调用HandlerMapping处理器映射器<br>
处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet<br>
DispatcherServlet调用HandlerAdapter处理器适配器<br>
HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)<br>
Controller执行完成返回ModelAndView。<br>
HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。<br>
DispatcherServlet将ModelAndView传给ViewReslover视图解析器<br>
响应客户</p>
</blockquote>
<ol start="29">
<li>静态方法和实例方法</li>
</ol>
<blockquote>
<p>从逻辑关系来看：若方法与类的实例不存在逻辑上的联系，那么用静态方法。反之则最好使用实例化方法。<br>
从性能角度:若方法经常被调用，则用静态方法更佳，因为这样可以避免频繁地实例化对象导致的资源占用，提高性能。然而，由于静态的东西，在构造的时候是在堆中声称的，在结束之前不会被释放与改变，会一直占用内存空间，所以不宜有过多的静态成员。<br>
从线程并发的角度考虑:如果并发的可能性很大，则不适宜使用静态方法。如果并发的可能性很小，或者通过简单的同步操作可以保证线程安全，那就可以考虑使用静态方法</p>
</blockquote>
<ol start="33">
<li>raft<br>
leader candidate follower</li>
</ol>
<blockquote>
<p>leader负责对整个集群进行控制管理，同时接受客户端的请求。在整个集群中，不能同时出现多个leader，任何时刻只会有一个或者没有。<br>
candidate就是处于选主阶段的状态，要么选举成功成为leader，要么退回到follower。<br>
一般情况下大部分服务器都处于follower状态。跟随者可以理解为master-slave结构中的slave，就像是将军领导下的小兵。follower不会主动向集群发起消息</p>
</blockquote>
<ol start="34">
<li>
<p>内连接左连接，完整型约束</p>
</li>
<li>
<p>top<br>
P：CPU排序；M：排序</p>
</li>
<li>
<p>如何保障缓存一致性(缓存与数据库的双写一致性)<br>
共识</p>
</li>
</ol>
<ul>
<li>缓存必须要有过期时间</li>
<li>保证数据库跟缓存的最终一致性即可，不必追求强一致性<br>
<a href="https://juejin.im/post/6844903941646319623" target="_blank" rel="noopener">数据库与缓存数据一致性问题</a><br>
更新缓存的的Design Pattern有四种</li>
<li>Cache Aside Pattern
<ul>
<li>失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中</li>
<li>命中：应用程序从cache中取数据，取到后返回。</li>
<li>更新：先把数据存到数据库中，成功后，再让缓存失效；更新的操作还有：
<ul>
<li>先更新数据库,再写缓存 可能出现 AB 先后更新数据库,但更新缓存的顺序为BA 导致脏数据;其次如果并不确定该数据是否被频繁访问,如果每次更新数据库都更新缓存,可能造成缓存空间的浪费;所以更新不可取,删除更好(需求方主动触发缓存更新)</li>
<li>先更新缓存,然后更新数据库：更新操作可能失败,导致数据可能丢失,不能保证最终一致性(应当以数据库为主);同时也存在操作乱序的问题</li>
<li>先删除缓存,然后更新数据库：可能在 A在删除缓存 和更新数据库之间 出现B 缓存不命中,读取脏值到redis中的情况(在读写分离的情况下更为严重)</li>
<li>先更新数据库,然后删除缓存：可能出现缓存失效的情况下,A-&gt;读取旧值-&gt;B更新数据库-&gt;B删除缓存-&gt;A写旧值到到缓存(是否可以通过写redis时要求比较值的时间戳);但可能性低 同时主从读写分离的情况下,可能出现从库数据未脏数据的情况</li>
</ul>
</li>
<li>定时删除缓存(消息队列,过期时间);比较高频数据的写时间戳</li>
<li>删除缓存可能导致的缓存击穿 可以利用锁操作( set 在发现缓存为空时,竞争读写数据库的机会)</li>
</ul>
</li>
</ul>
<p>更强的一致性实现：分布式读写锁(共享读锁,在写锁存在的情况下不可以申请读锁)</p>
<ol start="37">
<li>redis 锁<br>
单节点 锁INCR、SETNX、SET</li>
</ol>
<ul>
<li>SETNX：排他性;该命令只会在键不存在的情况下才会为键设置值,这样当别的进程再去使用这个命令设置这个键的时候就会失败进而无法获得锁</li>
<li>避免死锁：在获得setnx 同时设置锁的过期时间;</li>
<li>释放锁时检查:A在获得锁之后,超时自动释放而不自知,但后续主动释放已经被B获得的锁,破坏了B涉及的互斥过程。</li>
</ul>
<p>分布式锁<br>
共识算法<br>
raft paxos gossip</p>
<p>CopyOnWriteArrayList 线程安全</p>
<blockquote>
<p>CopyOnWriteArrayList 不强调线程之间的同步,强调数据的共享(对于可能的写不干扰其他读)<br>
对于所有涉及修改的操作,加锁,其实现都是复制一个与原本数据已知的数组对象,然后把指针指向这个对象;相当于线程的私有变量,随着线程的消亡而消亡(可能会面临内存泄漏的问题)<br>
适合于读多写少的场景,但是对于数据量比较大的场景,复制会比较消耗时间,在完成之前访问,仍然获得旧数据</p>
</blockquote>
<p>如何存储一个弹幕系统的弹幕，使用redis的什么类型，怎么保证热点数据，每秒会产生大量的数据，redis扛不住怎么办<br>
<a href="https://www.cnblogs.com/java920043111/p/9286123.html" target="_blank" rel="noopener">bilibili 高并发实时弹幕系统的实现</a><br>
消息队列  udp广播</p>
<p>spring AOP，JDK和CGlib的区别，除了针对接口和类以外的不同</p>
<blockquote>
<p>java动态代理是利用反射机制生成一个实现代理接口的代理类，在调用具体方法前调用InvokeHandler来处理。</p>
<ul>
<li>JDK代理是不需要以来第三方的库，只要要JDK环境就可以进行代理<br>
而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</li>
<li>CGLib 必须依赖于CGLib的类库</li>
</ul>
</blockquote>
<p>实现 ReadWriteLock</p>
<p><a href="https://www.cnblogs.com/yihujiu/p/6379279.html" target="_blank" rel="noopener">大量日志查找</a><br>
HAdoop mapreduce</p>
<p>Docker容器本质上是宿主机上的进程，卷相当于容器的磁盘。</p>
<blockquote>
<p>Docker通过nampespace实现了资源隔离，通过cgroups实现了资源限制，通过写时复制机制（copy-on-write）实现了高效的文件操作。</p>
</blockquote>
<p>轻量级锁</p>
<blockquote>
<p>他的出现并不是代替重量级锁，而是在没有多线程竞争的前提下，减少系统互斥量操作产生的性能消耗<br>
锁战友的而时间步长</p>
</blockquote>
<p><a href="https://blog.csdn.net/scdn_cp/article/details/86491792" target="_blank" rel="noopener">无锁 -&gt; 偏向锁 -&gt; 轻量级 -&gt; 重量级</a></p>
<ul>
<li>初期锁对象刚创建时，还没有任何线程来竞争，对象的Mark Word是下图的第一种情形，这偏向锁标识位是0，锁状态01，说明该对象处于无锁状态</li>
<li>当有一个线程来竞争锁时，先用偏向锁，表示锁对象偏爱这个线程，这个线程要执行这个锁关联的任何代码，不需要再做任何检查和切换，这种竞争不激烈的情况下，效率非常高。这时Mark Word会记录自己偏爱的线程的ID，把该线程当做自己的熟人。如下图第二种情形</li>
<li>当有两个线程开始竞争这个锁对象，情况发生变化了，不再是偏向（独占）锁了，锁会升级为轻量级锁(monitorenter)，两个线程公平竞争，哪个线程先占有锁对象并执行代码，锁对象的Mark Word就执行哪个线程的栈帧中的锁记录。如下图第三种情形</li>
<li>如果竞争的这个锁对象的线程更多，导致了更多的切换和等待，JVM会把该锁对象的锁升级为重量级锁，这个就叫做同步锁，这个锁对象Mark Word再次发生变化，会指向一个监视器对象，这个监视器对象用集合的形式，来登记和管理排队的线程</li>
</ul>
<p><a href="https://www.xttblog.com/?p=4881" target="_blank" rel="noopener">Java为什么要引入偏向锁？</a><br>
Java 对象头 记录 锁的状态以及当前线程ID 或时间戳<br>
堆栈中记录着当前持有的锁的对象</p>
<p><a href="https://juejin.im/post/6844904023540105229" target="_blank" rel="noopener">Class.forName &amp; ClassLoader.loadClass 比较</a><br>
<a href="https://juejin.im/post/6873691965892853767" target="_blank" rel="noopener">new Object()到底占用几个字节，看完这篇就彻底明白了</a></p>
<p>mysql里什么是检查点、保存点和中间点？：w</p>
<p>Object 有哪些方法？</p>
<ul>
<li>hashCode</li>
<li>equals 之间判断地址是否相等,可重写</li>
<li>clone  默认仅仅是复制引用,浅拷贝; 重写该接口必须 实现Cloneable接口</li>
<li>toString 对象名@hashcode</li>
<li>notify notifyAll wat</li>
<li>protected finalize 垃圾回收器准备释放内存的时候，会先调用finalize(),并且只会调用一次(可能会出现方法)</li>
</ul>
<h2 id="算法">算法</h2>
<h3 id="排序算法">排序算法</h3>
<table>
<thead>
<tr>
<th>算法名</th>
<th>稳定</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>核心思想</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入排序</td>
<td>稳定</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>在数组中实现,第一个节点构成的集合是有序的,然后依次增加集合相邻的元素进入,采取后移和插入的方式实现集合内的有序,直至集合包含所有元素</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>稳定</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>循环的比较相邻的值,如果前者大于后者则调换位置,一次遍历可以把最大的放置在最后,然后可以放置次大</td>
</tr>
<tr>
<td>归并排序</td>
<td>稳定</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>将数组分割为N个集合,集合内归并排序,然后合并集合</td>
</tr>
<tr>
<td>计数排序</td>
<td>稳定</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>在数组最大值和最小值的空间内,统计数组中每个元素出现的次数,然后输出即可</td>
</tr>
<tr>
<td>桶排序</td>
<td>稳定</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>可以把某个范围定义为桶,把元素分割到各个桶内,桶内使用任何排序使得有序,然后整体有序</td>
</tr>
<tr>
<td>基数排序</td>
<td>稳定</td>
<td>O(n*k)</td>
<td>O(n+k)</td>
<td>根据数组元素,将元素分为N个关键字,每次针对一个关键字排序,N个关键字排序之后保持有序</td>
</tr>
<tr>
<td>希尔排序</td>
<td>不稳定</td>
<td>O(n^1.3)</td>
<td>O(1)</td>
<td>设定步长为N,共可得到N个每个元素相邻下标为N的元素集合,集合内部插入排序,然后 不断缩减步长到1;由于 减少了集合间元素的比较,在当步长越小,集合也变得大体有序</td>
</tr>
<tr>
<td>选择排序</td>
<td>不稳定</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>选择最小/最大值到开头或者末尾,在剩下的元素中选择最小/最大,添加进之前的有序末尾</td>
</tr>
<tr>
<td>堆排序</td>
<td>不稳定</td>
<td>O(nlogn)</td>
<td>O(1）</td>
<td>基于完全二叉树,所以可以使用数组实现; 首先根据N个输入元素构建完全而二叉树;然后从节点N/2——1开始自下而上调整树,调整最大堆;随后将最大值和节点N互换,自上而下调整树,再次得到最大堆,持续可得到有序输出</td>
</tr>
<tr>
<td>快速排序</td>
<td>不稳定</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>通过选定一个基准,将所有小于该基准的放在左边,大于该基准的放在右边,随后对基准左右分别快排,获得全局有序</td>
</tr>
</tbody>
</table>
<p>mysql 事务的实现</p>
<blockquote>
<p>锁+MVCC<br>
锁：读写锁/共享独占锁(二阶段锁提交)+间隙锁/临界锁(在二段加锁的情况下,可能导致死锁)<br>
MVCC：undolog 实现未提交事务的原子性(redolog 保证已提交事务的持久性)<br>
MVCC 是快照读,不能读创建readview之后提交的事务的更新,可以添加for update 强制当前读<br>
innodb的RR隔离级别下,读自动开启行锁和间隙锁构成next-key锁,配合MVCC 解决幻读或者直接串行化</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/15/工作求职/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/15/工作求职/JVM/" class="post-title-link" itemprop="url">JVM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-15 17:39:54" itemprop="dateCreated datePublished" datetime="2020-08-15T17:39:54+08:00">2020-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-15 10:57:32" itemprop="dateModified" datetime="2021-01-15T10:57:32+08:00">2021-01-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>JVM 内存</li>
</ol>
<ul>
<li>方法区：存放类运行时必须的结构信息,比如类的静态变量,常量,类的全局名称,方法信息,父类引用等如</li>
<li>堆：实际存储对象的地方,占据大量内存,主要GC对象,具体可以分为老年堆和年轻堆</li>
<li>虚拟机栈：每个线程都有一个自己独立的Java栈，每次线程执行到一个新的方法时就在栈里面压入一个栈帧。帧里包含了方法里的局部变量，操作数栈(数据运算)以及帧数据区。这三种区域中局部变量很好理解，就是在方法作用范围内的变量，包括基本变量和对象的引用</li>
<li>本地方法栈：调用系统提供的方法时,涉及的机制和数据</li>
<li>PC寄存器：线程运行时对于程序运行中的位置和状态的标识</li>
</ul>
<ol start="2">
<li>类加载/Class.forName</li>
</ol>
<ul>
<li>class文件记载到内,把字节码文件转换为二进制文件</li>
<li>在方法区中形成内部数据结构</li>
<li>验证类文件中数据合法性</li>
<li>初始化的过程（主要给静态变量和静态块初始化）</li>
</ul>
<ol start="3">
<li>实例化/newInstance</li>
</ol>
<ul>
<li>在堆中生成一个对象实例</li>
<li>对实例的内部变量初始化</li>
</ul>
<p>Eden区与Survivor的比例较大，HotSpot默认是 8:1，即分别占新生代的80%，10%，10%。如果一次回收中，Survivor+Eden中存活下来的内存超过了10%，则需要将一部分对象分配到 老年代。用-XX:SurvivorRatio参数来配置Eden区域Survivor区的容量比值，默认是8，代表Eden：Survivor1：Survivor2=8:1:1.<br>
Major GC vs Full GC<br>
Major GC 是清理永久代。Full GC 是清理整个堆空间—包括年轻代和老年代  永久代(方法区)<br>
堆大小=新生代+老年代，新生代与老年代的比例为1：2，新生代细分为一块较大的Eden空间和两块较小的Survivor空间，分别被命名为from和to。(方便复制-清除；from to GC后交换角色)</p>
<p>大对象直接进入老年代，实际上是为了保证Eden区具有充足的空间可用的一种策略(复制算法耗时，好空间)</p>
<p>垃圾收集器: 垃圾收集器是垃圾回收算法（标记-清除算法、复制算法、标记-整理算法、火车算法）的具体实现<br>
新生代收集器：Serial、ParNew、Parallel Scavenge<br>
老年代收集器：Serial Old、Parallel Old、CMS；<br>
整堆收集器：G1</p>
<ul>
<li>Serial收集器：新生代收集器，使用停止复制算法，使用一个线程进行GC，其它工作线程暂停</li>
<li>ParNew收集器：serial 多线程版本(除Serial外，目前只有它能与CMS收集器配合工作)</li>
<li>Parallel Scavenge:目标新生代,复制算法,多线程,但 CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间,而Parallel Scavenge收集器的目标则是达一个可控制的吞吐量（Throughput:吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间））；</li>
<li>Serial Old :目标老年代,标记整理,单线程</li>
<li>Parallel Old： serial的多线程版</li>
<li>cms：并发标记清理,针对老年代,标记清除(内存碎片);并发收集(使得用户线程可以工作)：浮动垃圾和内存碎片</li>
<li>G1（Garbage-First）<br>
- 能充分利用多CPU、多核环境下的硬件优势；可以并行来缩短&quot;Stop The World&quot;停顿时间；也可以并发让垃圾收集与用户程序同时进行<br>
- 分代收集，收集范围包括新生代和老年代：能独立管理整个GC堆（新生代和老年代），而不需要与其他收集器搭配；<br>
- 结合多种垃圾收集算法，空间整合，不产生碎片：从整体看，是基于标记-整理算法；从局部（两个Region间）看，是基于复制算法；这是一种类似火车算法的实现；<br>
- 可预测的停顿：低停顿的同时实现高吞吐量,可预测的停顿：低停顿的同时实现高吞吐量<br>
- 场景：服务端</li>
</ul>
<p>GC是什么时候触发的（面试最常见的问题之一）<br>
由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Minor GC和Full GC。<br>
采用“分代式垃圾收集”。这种方法会跟Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域：</p>
<ul>
<li>伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。</li>
<li>幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。</li>
<li>终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间</li>
</ul>
<p>Minor GC：<br>
  一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Minor GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。<br>
Full GC ：<br>
对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC：<br>
a) 年老代（Tenured）被写满；<br>
b) 持久代（Perm）被写满；<br>
c) System.gc()被显示调用；<br>
d) 上一次GC之后Heap的各域分配策略动态变化；<br>
面试题：jvm查看gc命令<br>
jstat -gc 12538 5000<br>
即会每5秒一次显示进程号为12538的java进成的GC情况，<br>
面试题：如果频繁老年代回收怎么分析解决(蚂蚁金服面试题)<br>
（个人理解）老年代是存放那些在程序中经历了好几次回收仍然还活着或者特别大的对象（这个大就要看你是否设置了-XX：PretenureSizeThreshold 参数了）。检查程序中是否有比较大的对象，或者这个参数设置是否合理。</p>
<ol start="5">
<li>Java 内存模型（JMM）</li>
</ol>
<blockquote>
<p>Java内存区域:PC+堆+本地方法栈+线程栈+方法区<br>
JMM:线程 和线程私有的工作内存(栈) 通过缓存一致性协议 实现对主内存的读写<br>
<img src="/images/JMM.png" alt="JMM"></p>
</blockquote>
<p>JVM 调优参数<br>
CyclicBarrier的使用<br>
CountDownLatch CyclicBarrier的使用</p>
<blockquote>
<p>多人回合制游戏(赛跑终点结束重新开始)<br>
CyclicBarrier<br>
包含一个可重入锁,该锁的condition,满足条件之后执行的任务(需要在其中设置退出条件不然无法退出),已经等待的人数<br>
方法：dowait:将调用线程 添加进condition的阻塞队列中,执行condition.wait 等待notifyAll(最后一个进入者执行既定任务,并重置一切);reset 重置一切重新使用</p>
</blockquote>
<p>GC 对象复制之后 的forward point<br>
OOpmap Cardtbale</p>
<p>fail-fast fail-safe</p>
<p>讲讲进程fork多个子进程和使用多线程的区别</p>
<ul>
<li>线程内fork进程,只能复制当前的线程</li>
<li>数据共享同步:进程间共享复杂,需要使用IPC,由于数据分离 所以同步简单,不需要加锁</li>
<li>资源(内存CPU)：进程占据资源多,切换复杂,CPU利用率低;</li>
<li>创建销毁：</li>
<li>编译调试复杂度</li>
<li>可靠性：进程之间不会有影响,线程挂了可能影响进程</li>
<li>分布式：进程适应天生支持分布式</li>
</ul>
<p>既然JVM有Full GC，为什么还会出现OutOfMemoryError?</p>
<ul>
<li>gc不了</li>
<li>产生对象太快来不及GC，GC需要安全点</li>
</ul>
<p>虚拟机性能检测工具</p>
<ul>
<li>jstat 虚拟机统计信息监控 -gc</li>
<li>jps：虚拟机进程状况检测</li>
<li>jinfo：java配置工具</li>
<li>jmap：java内存隐射工具</li>
<li>jstack java堆栈追踪工具</li>
<li></li>
</ul>
<p>升级老年代</p>
<ul>
<li>分配担保(允许担保失败的情况下进行mirroGC 可能引发fullgc)</li>
<li>年轻代 过15次GC</li>
<li>survior区的相同年龄的对象大于survior区的一般容量的话,那么大于这个年龄的进入老年代</li>
</ul>
<h2 id="jvm-调优">JVM 调优</h2>
<h2 id="synchronize-vs-lock-object-vs-condition">synchronize VS lock   object VS condition</h2>
<h3 id="synchronize">synchronize</h3>
<p>对象锁,保证只有一个线程能够获得锁,执行方法或者代码块,隐式的获得释放锁,无法感知中断<br>
可重入</p>
<h3 id="lock">lock</h3>
<p>相对于synchronize 更加灵活,需要显示的获得以及释放锁,可感知中断(lockInterruptly)<br>
其实现ReentrantLock 实现了lock接口,提供申请锁释放锁等基本功能<br>
ReentrantReadWriteLock实现了ReadWriteLock接口,读写分离,允许多线程读只允许一个线程写</p>
<h3 id="object-vs-condition">object VS condition</h3>
<p>Object</p>
<ul>
<li>wait:只能由获得锁的线程执行,释放锁并将自己放置在该对象的等待队列</li>
<li>notify:只能由获得锁的线程执行,会从该对象的等待队列中释放出一个线程,并不保证释放锁</li>
</ul>
<h3 id="blockedsynchronize-vs-waittingwait">blocked(synchronize) vs (waitting)wait</h3>
<p><a href="https://www.zhihu.com/question/27654579/answer/254496076" target="_blank" rel="noopener">参考</a><br>
线程新增了waitting 和 time-waitting 状态<br>
synchronize会导致线程陷入blocked状态,调用wait/LockSupport.park方法会导致线程陷入wait状态;notify会导致线程从waitting状态变为blocked状态</p>
<ul>
<li>blocked状态:对锁的等待导致陷入blocked,获得锁则进入ready或者运行态</li>
<li>waitting:调用 wait 或者 t.join 或者 LockSupport.pack 进入waiting态,notify/unpack 进入 block态</li>
<li>timed waitting:waiting方法中的增加了时间,以sleep方法(sleep方法不释放锁,时间过后进入就绪态) 超时或者被唤醒会进入block态</li>
</ul>
<p>thread yeild 将线程从运行态转化为就绪态</p>
<h3 id="objectwait-vs-conditionawait">object.wait  VS condition.await</h3>
<p>后者需要配合 lock使用,在利用CAS操作释放锁之后,执行LockSupport.park操作休眠线程,进入waitting态,等待unpack唤醒,进入阻塞 不需要处理中断异常(lock的lockinterrupt()中对此有相关处理)<br>
前者有系统提供支持,需要处理中断异常</p>
<h3 id="aqs-过程">AQS 过程</h3>
<h4 id="不包含condition">不包含condition</h4>
<p>lock操作尝试获取锁,失败后,将自己封装为head的next节点,只要自己的前继节点一直是head节点,那么死循环尝试获得锁,直到获得锁或者前继节点不是head节点,从而将调用LockSupport.park将自己休眠转化为waitting态<br>
unlock操作: 独占状态下,如果不再占有所,那么CAS更新独占线程标志位为null,并更新state否则仅更新state;根据该节点的waitstatus 决定是否通知后续的节点,如果通知那么会调用LockSupport.unpack 该节点的线程 进入阻塞态</p>
<h4 id="包含condition">包含condition</h4>
<p>condition的操作必然是在获得锁的前提下,进行的,等同object的操作<br>
lock获得锁成功<br>
condition.await():CAS 更新state,放弃锁,并调用LockSupport.park 放弃CPU时间<br>
此时因此而获得锁的线程执行signal操作,会找到该condition的阻塞队列里找到一个满足条件的 node,并调用LockSupport.park释放该node的线程,而线程获得CPU时间后,从LockSupport.park中返回,并尝试重新获得锁,要么获得锁或者陷入对lock的阻塞队列中<br>
如果获得锁,那么执行await后续代码,最后unlock释放锁</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/21/工作求职/DataStructure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/21/工作求职/DataStructure/" class="post-title-link" itemprop="url">DataStructure</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-21 16:07:22" itemprop="dateCreated datePublished" datetime="2020-07-21T16:07:22+08:00">2020-07-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-15 10:57:37" itemprop="dateModified" datetime="2021-01-15T10:57:37+08:00">2021-01-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>算法概述</p>
<h2 id></h2>
<p>递归<br>
动态规划<br>
树</p>
<h3 id="其他">其他</h3>
<p><a href="https://www.cnblogs.com/jason2003/p/9676729.html" target="_blank" rel="noopener">线段树</a></p>
<blockquote>
<p>这个东西感觉挺有意思</p>
</blockquote>
<p>红黑树</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/21/基础知识/Algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/21/基础知识/Algorithm/" class="post-title-link" itemprop="url">Algorithm</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-21 16:07:22" itemprop="dateCreated datePublished" datetime="2020-07-21T16:07:22+08:00">2020-07-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-30 13:21:09" itemprop="dateModified" datetime="2020-08-30T13:21:09+08:00">2020-08-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>算法概述</p>
<h2 id></h2>
<p>递归<br>
动态规划</p>
<p>###并查集<br>
<a href="https://blog.csdn.net/qq_19782019/article/details/78916595" target="_blank" rel="noopener">size数组和rank数组</a><br>
题目:<a href="https://leetcode-cn.com/problems/number-of-islands" target="_blank" rel="noopener">leetcode 200</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/06/工作求职/计算机网络/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/06/工作求职/计算机网络/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-06 09:29:04" itemprop="dateCreated datePublished" datetime="2020-07-06T09:29:04+08:00">2020-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-25 19:37:51" itemprop="dateModified" datetime="2021-02-25T19:37:51+08:00">2021-02-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基础问题">基础问题</h2>
<h3 id="osi-7层">OSI 7层</h3>
<ul>
<li>物理层：电路交换 报文交换 分组交换</li>
<li>数据链路层：组帧,差错控制,流量控制,介质访问(频分时分波分码分复用)</li>
<li>网络层：异构网络互联;路由与转发;拥塞控制
<ul>
<li>ARP：查询IP与MAC地址的映射;DHCP：动态分配IP;ICMP:允许主机以及路由器报告差错情况;TRACEROTE</li>
<li>NAT CIDR(路由聚合)</li>
<li>OSPF RIP</li>
</ul>
</li>
<li>传输层：传输层寻址与端口;无连接服务和有连接服务
<ul>
<li>UDP:无连接不可靠,数据校验(源端口目的端口;udp报文长度;校 验和; 数据)</li>
<li>TCP：连接管理：可靠传输;流量控制和拥塞控制(源目的端口：序号确认号数据偏移;标志位：SYN ACK PUS FIN RST ；校验和 窗口字段)</li>
</ul>
</li>
<li>会话层</li>
<li>表示层(加密)</li>
<li>应用层：CS 模式 P2P模式
<ul>
<li>PING;HTTP:TCP 80</li>
<li>DNS udp 53</li>
<li>FTP TCP 2021</li>
<li>EMAIL:TCP SMTP:25 POP3 110</li>
</ul>
</li>
</ul>
<h2 id="http">HTTP</h2>
<h3 id="http报文格式">HTTP报文格式</h3>
<p>HTTP报文可以分为两类，请求报文和响应报文。<br>
请求报文</p>
<ul>
<li>请求行：方法,url 协议版本 (GET /index.html HTTP/1.1)</li>
<li>请求头部 header 键值对(User-Agent,Accept,Host)</li>
<li>请求数据:GET 中不使用,POST中使用<br>
响应报文</li>
<li>状态行：HTTP-Version Status-Code Reason-Phrase(状态代码的文本描述)</li>
<li>消息报头</li>
<li>响应正文</li>
</ul>
<h3 id="报文参数">报文参数</h3>
<h4 id="方法">方法</h4>
<p>Method</p>
<blockquote>
<p>GET: 获取资源<br>
HEAD: 获取报文头部<br>
POST: 传输实体主体<br>
PUT: 传输文件<br>
DELETE: 删除文件<br>
OPTIONS: 询问支持方法</p>
</blockquote>
<h4 id="状态码">状态码</h4>
<blockquote>
<p>200 （成功） 服务器已成功处理了请求<br>
301 （永久移动） 永久重定向<br>
302 （临时移动）<br>
304 （未修改） 自从上次请求后，请求的网页未修改过。<br>
307 （临时重定向） 服务器目前从不同位置的网页响应请求<br>
401 （未授权） 请求要求身份验证<br>
403 （禁止） 服务器拒绝请求<br>
404 （未找到） 服务器找不到请求的网页<br>
500 （服务器内部错误） 服务器遇到错误，无法完成请求<br>
502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应</p>
</blockquote>
<h3 id="其他">其他</h3>
<h4 id="get-vs-post">GET VS POST</h4>
<ul>
<li>数据位置:GET提交,请求的数据会附在URL之后,POST提交：把提交的数据放置在是HTTP包的body中</li>
<li>数据长度:GET:特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节(2K+35) 而 POST对提交数据的大小有限制</li>
<li>安全性</li>
</ul>
<h3 id="http和https区别">HTTP和HTTPs区别</h3>
<blockquote>
<p>http：超文本传输协议，明文传播<br>
https： TCP 层与 HTTP 层之间加入了 SSL/TLS;http+ssl加密数据；<br>
对称加密，非对称加密（公钥加密，私钥解密，GitHub，ssh，身份签名）</p>
</blockquote>
<p>HTTP vs HTTPS</p>
<blockquote>
<p>https=http+对于数据进行SSL（Secure Sockets Layer）加密<br>
1.https协议需要到ca申请证书，一般免费证书较少<br>
2.http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议<br>
3.http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443<br>
4.http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全</p>
</blockquote>
<h4 id="https-的流程">https 的流程</h4>
<p>CA证书 : 网站将自己的公钥以及其他相关信息提交给CA机构，CA机构利用私钥加密，浏览器利用CA机构提供的公钥解密，获得网站的公钥以及其他相关信息。</p>
<h3 id="http-报文键值对">http 报文键值对</h3>
<blockquote>
<p>host<br>
Content-*<br>
ACCEPT<br>
COOKIE</p>
</blockquote>
<p>http1 VS http1.1</p>
<ul>
<li>http1:增加HTTP头、扩展PUT、POST等方法</li>
<li>HTTP1.1 :长连接、流水线支持，最广泛使用的HTTP传输协议</li>
</ul>
<h2 id="tcp">TCP</h2>
<h3 id="tcp三次握手四次挥手为什么要三次握手">TCP三次握手四次挥手，为什么要三次握手</h3>
<blockquote>
<p>三次握手是为了避免两次握手带来的漏洞（如果两次建立连接，那么假设A-&gt;B，B-&gt;A的请求未到达，B认为链接建立，放数据，A认为链接未建立，不接受数据，B数据超时会再重发，引发锁）<br>
四次挥手：最后一次挥手可能应为网络原因而丢失，故等待2MSL再没收到FIN 则认为对方收到了最后一次挥手<br>
数据传输，所以四次挥手而非3次</p>
</blockquote>
<p>TCP拥塞协议，tcpudp区别</p>
<ul>
<li>是否连接</li>
<li>是否可靠传输,保证有序</li>
<li>一对读通信,udp广播多播</li>
<li>面向报文,面向字节流</li>
<li>首部开销</li>
<li>使用场景：适用于实时场景(视频频电话直播),可靠的传输(文件数据传输)</li>
</ul>
<p>tcp为什么可靠，和udp的区别，序号的作用除了可靠性还有什么？</p>
<ul>
<li>校验</li>
<li>序列号和确认机制</li>
<li>序列号</li>
<li>重传机制</li>
</ul>
<h2 id="udp">UDP</h2>
<h2 id="ip">IP</h2>
<h4 id="ipv4-报文格式">IPV4 报文格式</h4>
<ul>
<li>版本 首部长度 总长度</li>
<li>标识 标志 片偏移(数据报分组之后在元报文的偏移量;数据链路层有最大报文传输单元限制MTU)</li>
<li>生存时间 具体协议(TCP UDP) 首部校验和</li>
<li>源目的地址</li>
<li>可选字段 填充</li>
<li>数据</li>
</ul>
<p>路由算法</p>
<ul>
<li>OSPF</li>
<li>RIP</li>
</ul>
<h2 id="dns">DNS</h2>
<p>13台根服务器 顶级域名服务器  权限域名服务器 本地域名服务器<br>
定义域名 一级域名  二级域名<br>
域名解析服务器分类：</p>
<ul>
<li>主域名服务器：负责维护一个区域所有域名信息，为特定域名的所有信息的权威来源，可以修改信息。</li>
<li>辅助域名服务器：当主域名服务器出现故障，关机或负载过重等情况，辅助域名服务器作为备份服务器来提供域名解析服务，辅助域名服务器是从另一台远程域名服务器下载的所有域名信息，域名信息不具有修改权限</li>
<li>缓存域名服务器：当从远程域名服务器获得域名解析信息后，将其缓存到高速缓存中，当下次需要请求相同的域名解析时，直接从本地缓存中读取，缓存域名信息不具有权威性</li>
<li>转发域名服务器：转发域名服务器用来请求不在本地域名服务器上的信息，当收到域名请求服务时，现在本地缓存中查取，如果查询不到。即依次向指定的域名服务器发出请求，直到查到所需信息返回结果。否则，返回无法映射的信息。<br>
dig :命令主要用来从 DNS 域名服务器查询主机地址信息</li>
</ul>
<h3 id="浏览器访问wwwbaiducom的过程"><a href="https://blog.nowcoder.net/n/a8337baa9c554acdab25b898f7b0970b" target="_blank" rel="noopener">浏览器访问www.baidu.com的过程</a></h3>
<blockquote>
<p>DNS域名解析:从浏览器缓存中获取,从本机/操作系统中尝试查找域名(host文件)</p>
<ul>
<li>如果在局域网,可能在路由器或者在ISP存在缓存</li>
<li>询问本地域名服务器,本地域名没有的话,询问根域名服务器,如果是迭代的话,可能从根域名服务器获得下一步需要去查询的顶级域名服务器,可能获得下一步的授权域名服务器,获得真实的IP,缓存并返回给主机。<br>
获得ip 然后发送TCP连接</li>
</ul>
</blockquote>
<h2 id="其他常见问题">其他常见问题</h2>
<h3 id="close_wait-和-time_wait">close_wait 和 time_wait</h3>
<blockquote>
<p>close_wait 在 被关闭防 接收到fin报文时,发出ack 报文 进入close_wait状态 ,发送完报文,调用close(),close_wait 状态结束<br>
socket 其实就是一个五元组，包括：源IP, 源端口, 目的IP, 目的端口, 类型(TCP or UDP)<br>
TIME_WAIT</p>
<ul>
<li>防止前一个连接上延迟的数据包或者丢失重传的数据包，被后面复用的连接错误的接收</li>
<li>确保连接方能在时间范围内，关闭自己的连接(考虑到丢包的情况)</li>
</ul>
</blockquote>
<p>在高并发短连接的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接,避免有时出现客户端连接不上</p>
<ul>
<li>高并发导致服务器过多使用端口资源(0-65535)</li>
<li>短连接表示“业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间”的连接。<br>
解决：</li>
<li>开启SYN cookie</li>
<li>开启 tcp_tw_reuse 允许TIME_WAIT的socket重用于TCP连接</li>
<li>开启 tcp_tw_recycle,开启TCP连接中TIME-WAIT sockets的快速回收,会丢弃时间戳较小的syn报文(在最新的linux内核中放弃这个参数,可能导致tcp网络极不稳定)</li>
</ul>
<h3 id="time_wait-和-close_wait大量出现">time_wait 和 close_wait大量出现</h3>
<blockquote>
<p>当time_wait(2MSL 60S) 比较多时,客户建立的连接没有有效利用 ,可以考虑tcp长连接复用;<br>
大量close_wait的现象，主要原因是某种情况下对方关闭了socket链接，但是我方忙与读或者写，没有关闭连接</p>
</blockquote>
<h3 id="tcpdump">tcpdump</h3>
<blockquote>
<p>使用tcpdump抓包在卡顿的时候会抓到大量的syn请求</p>
</blockquote>
<h3 id="syn-flood">SYN FLOOD</h3>
<blockquote>
<p>前提:服务端在第二次握手时,就分配相关资源给该tcp连接<br>
synflood利用这一缺陷,大量发送syn request包,耗尽服务端的资源从而使之无法提供正常服务<br>
解决：<br>
限制ip的访问次数<br>
开启syncookie:在第二次握手时,不分配资源而是根据syn包的一些信息以及自己的秘钥经过算法计算出cookie值,下次返回ack 再计算一次,相同才开始分配资源;延迟资源分配到简历真正连接的时候</p>
</blockquote>
<h3 id="粘包问题">粘包问题</h3>
<blockquote>
<p>传输层有两种协议，TCP和UDP。TCP是面向流的，UDP是面向报文的；<br>
应用层需要提取传输层的数据，在使用UDP协议时，可以提取完整的报文，但是使用TCP报文时，无法保证提取完整的报文，需要将收到的报文按照字节序排序完成后提取<br>
由于TCP是可靠的，面向连接的，每次报文传输的代价相对于UDP更大，通常会避免频繁发小报文，按照nagle算法 会积累一定的小报文，集中发送，但是而接收方接到报文后，需要按照预设的分隔标记从中提取多个小报文。<br>
解决方法:<br>
1.在发送数据前，将自己要发送的字节流大小告知接收方。(可能增加传输和等待回应所带来的时间损耗)<br>
2.在TCP报文头的基础上，为字节流增加固定窗长度报文头，增加字节流的实际长度。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/06/工作求职/OS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/06/工作求职/OS/" class="post-title-link" itemprop="url">OS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-06 09:28:41" itemprop="dateCreated datePublished" datetime="2020-07-06T09:28:41+08:00">2020-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-15 10:57:21" itemprop="dateModified" datetime="2021-01-15T10:57:21+08:00">2021-01-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="线程状态及各状态之间的转换">线程状态及各状态之间的转换</h2>
<blockquote>
<p>新建状态、就绪状态、运行状态、阻塞状态及死亡状态</p>
</blockquote>
<h2 id="进程的内存结构">进程的内存结构</h2>
<blockquote>
<p>可执行文件的内容：代码段、数据段、BSS段和其他段<br>
代码段：代码<br>
数据段：存储初始化了的全局静态变量和局部静态变量和只读数据<br>
BSS段（Block Start By Symbol）:未初始化的全部静态变量和局部静态变量，为其预留空间<br>
其他段；保存于程序相关的其他信息，比如编译器信息，调试信息，动态链接信息等</p>
<p>装载可执行文件后，进程的空间大致可分为 代码区、数据区（bss+数据段）、向上的堆和向下的栈<br>
代码段：可读可执行<br>
数据段：可读可写<br>
堆：malloc 等程序员申请空间<br>
栈：系统运行时产生的变量，比如运行系统的信息、方法的参数、方法返回地址、局部变量等</p>
</blockquote>
<h2 id="线程的内存结构">线程的内存结构</h2>
<blockquote>
<p>线程共享进程的代码段，数据段，堆段，但是每个线程都拥有自己的私有栈，存储线程 ID、栈指针、PC、通用目的寄存器和条件码。<br>
Linux的线程栈是在进程的堆空间申请的。<br>
linux线程同步：<a href="https://www.cnblogs.com/yinbiao/p/11190336.html" target="_blank" rel="noopener">https://www.cnblogs.com/yinbiao/p/11190336.html</a><br>
互斥锁（临界区）：特殊全局变量划分临界区<br>
条件变量：等待该变量发生变化的等待队列，线程因特定条件休眠<br>
信号量：互斥锁只允许一个线程进入临界区，而信号量允许多个线程进入临界区<br>
读写锁：可以同时读，但不可以同时写</p>
</blockquote>
<h2 id="fork">fork</h2>
<blockquote>
<p>fork()函数用于从一个已经存在的进程内创建一个新的进程，新的进程称为“子进程”，相应地称创建子进程的进程为“父进程”。使用fork()函数得到的子进程是父进程的复制品，子进程完全复制了父进程的资源，包括进程上下文、代码区、数据区、堆区、栈区、内存信息、打开文件的文件描述符、信号处理函数、进程优先级、进程组号、当前工作目录、根目录、资源限制和控制终端等信息，而子进程与父进程的区别有进程号、资源使用情况和计时器等</p>
<p>由于复制父进程的资源需要大量的操作，十分浪费时间与系统资源，因此Linux内核采取了写时拷贝技术（copy on write）来提高效率<br>
在使用fork()函数创建子进程的时候，在调用fork()函数前是一个进程在执行这段代码，而调用fork()函数后就变成了两个进程在执行这段代码。两个进程所执行的代码完全相同，都会执行接下来的if-else判断语句块。</p>
<p>当子进程从父进程内复制后，父进程与子进程内都有一个&quot;pid&quot;变量：在父进程中，fork()函数会将子进程的PID返回给父进程，即父进程的pid变量内存储的是一个大于0的整数；而在子进程中，fork()函数会返回0，即子进程的pid变量内存储的是0；如果创建进程出现错误，则会返回-1，不会创建子进程。</p>
</blockquote>
<blockquote>
<p>父进程pid和子进程pid的大小关系<br>
如果进程ID最大值没有达到系统进程数的上限,子进程比父进程ID大.<br>
但是如果进程ID达到上限,系统会分配之前分配但是已经退出的进程ID给新进程,这样有可能出现子进程ID比父进程小.</p>
</blockquote>
<p>需要注意的是在一个线程中,调用fork函数,只会复制进程空间内该线程,不会复制其他线程(在当前线程上下文操作,该线程不能感知其他线程)</p>
<h2 id="内存管理">内存管理</h2>
<h3 id="非连续分配管理方式">非连续分配管理方式</h3>
<blockquote>
<p>允许程序分散的装入不相邻的内存分区 配合后面的虚存技术<br>
固定分区会产生内部碎片,动态分配会产生外部碎片<br>
根据分区的大小是否固定又分为 分页存储管理方式(基本分页存储管理方式和请求分页管理方式) 和 分段存储管理方式</p>
</blockquote>
<h4 id="基本分页管理方式">基本分页管理方式</h4>
<p>页的大小一般为4K(大小有页面大小和管理页的开销决定;内存为页帧,外存称之为块)<br>
从而把64位地址空间分为 页号和页内偏移量<br>
页表 为 <code>页号</code> 和 <code>块号</code> 的 对应<br>
系统中存在页表寄存器,包含 <code>页表的起始地址</code> <code>页表长度</code><br>
而每个进程都在进程控制块PCB存储自己的 页表寄存器值,当进程运行时将值放进页表寄存器 将进程内部的地址与之对应,把进程的虚拟地址的页号与之相对应 获取真实的块号(由于每次访存操作都涉及逻辑地址到物理地址的转换所以转换速度必须快,而且在内存中都需要存储页表 =&gt; 页表项即页号不能太大,页不能太小 同时 页太大会导致 内存利用率低加载慢 取折中 4K)</p>
<p>存储一个数据至少需要访问两次内存</p>
<ul>
<li>首先访问页表,获取块号</li>
<li>如果块在内存,就在内存中读取</li>
</ul>
<p>为了降低第一次访存的消耗,引入快表(联想寄存器TLB),即利用时间局部性原理 存储最近的页号和块号的映射</p>
<p>为了避免一层页表导致占据太多进程内存空间,引入多级页表(64位地址分为n级页号-1级页号),使得只需要保持当前使用的页表在内存即可(通过n级页号锁定n级页表)</p>
<h3 id="虚拟内存管理">虚拟内存管理</h3>
<p>处于局部性原理,不需要把进程的数据一次性装入内存;利用虚存技术,可以将内存的数据多次装入内存同时由于局部性原理保证程序的运行正常<br>
虚拟存储器基于局部性原理,给用户提供了远大于内存的空间;</p>
<h4 id="请求分页式">请求分页式</h4>
<p>页表机制+缺页中断机制+地址变换机制<br>
页表项= 页号 + 物理块号 + 状态位(是否在内存) + 访问字段 + 修改位 + 外存地址<br>
访问字段：用于记录页面在一段时间内的访问次数以及多长时间未被访问</p>
<h4 id="请求分段式">请求分段式</h4>
<h4 id="请求段页式">请求段页式</h4>
<h2 id="协程">协程</h2>
<blockquote>
<p>又称微线程，纤程。英文名Coroutine;<br>
可以看做用户态下的线程，协程的切换逻辑由可以在用户态下实现，同时不需要进行上下文的切换，因而相对于线程速度快很多；之所以不需要切换上下文，是因为传统的线程生命周期是一种嵌套形式的，同时只有一个线程有效，且线程无效后切换需要进行上下文的切换，而协程切换后，会向相应东西存放在随时可用的活动栈中(在堆中分配内存)<br>
每个协程都有自己私有栈,同时协程之间存在共享栈,由runnig-&gt;suspend设及私有栈恢复到共享栈,相反运行意味着保存到私有栈<br>
携程的状态从ready 到 running 到 susbpend 到 running 到 dead<br>
协程 VS 线程：不切换上下文;不涉及锁(自己实现协程间调度) 但linux并不支持携程 协程因为线程不会主动释放CPU时间,与机遇优先级抢占式的cpu调度不符</p>
</blockquote>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/94018082" target="_blank" rel="noopener">有栈协程实现原理</a> <a href="https://blog.csdn.net/liushengxi_root/article/details/85114692" target="_blank" rel="noopener">云风协程库保存和恢复协程运行栈原理讲解</a></p>
</blockquote>
<h2 id="作业调度算法">作业调度算法</h2>
<ul>
<li>FCFS：利于长进程，而不利于短进程</li>
<li>短作业优先：利于短进程，而不利于长进程</li>
<li>时间片轮转：时间片轮转调度算法</li>
<li>优先级调度算法</li>
<li>响应比高这优先：响应比= 等待时间+运行时间/运行时间 :既照顾了短进程，又考虑了进程到达的先后次序，也不会使长进程长期得不到服务，因此是一个比较全面考虑的算法，但每次进行调度时，都需要对各个进程计算响应比。所以系统开销很大，比较复杂</li>
<li>多级队列调度算法</li>
</ul>
<h2 id="存储器连续分配方式中分区分配算法">存储器连续分配方式中分区分配算法</h2>
<ul>
<li>首次适应分配算法:总是从第1条记录开始顺序查找空闲分区表，找到第一个能满足作业长度要求的空闲区，分割这个空闲区，一部分分配给作业，另一部分仍为空闲区</li>
<li>循环首次适应算法:每次分配均从上次分配的位置之后开始查</li>
<li>最佳适应分配算法(BF)：是按作业要求从所有的空闲分区中挑选一个能满足作业要求的最小空闲区，这样可保证不去分割一个更大的区域，使装入大作业时比较容易得到满足。为实现这种算法，把空闲区按长度递增次序登记在空闲区表中，分配时，顺序查找。</li>
<li>最坏适应算法(worst fit algorithm)：要求空闲区按其大小递减的顺序组成空闲区可用表或自由链。当用户作业或进程申请一个空闲区时，先检查空闲区可用表或自由链的第一个空闲可用区的大小是否大于或等于所要求的内存长度，若可用表或自由链的第一个项所示空闲区长度小于所要求的，则分配失败，否则从空闲区可用表或自由链中分配相应的存储空间给用户，然后修改和调整空闲区可用表或自由链。</li>
</ul>
<h2 id="页面置换算法">页面置换算法</h2>
<ul>
<li>最佳置换算法（OPT) ：选择以后永不使用或在最长时间内不再被访问的内存页面予以淘汰。</li>
<li>先进先出置换算法（FIFO）：选择最先进入内存的页面予以淘汰。</li>
<li>最近最久未使用算法（LRU）：选择在最近一段时间内最久没有使用过的页，把它淘汰。</li>
<li>最少使用算法（LFU）：选择到当前时间为止被访问次数最少的页转换。</li>
<li>时钟算法/最近未用算法：使用访问位和修改位标记页,优先替换未使用未修改的页,然后替换已修改的页。</li>
</ul>
<h2 id="页面分配策略">页面分配策略</h2>
<p>分页式的虚拟内存系统,对于每个进程如何分配主存空间</p>
<ul>
<li>固定分配局部置换：每个进程固定分配物理块,置换只发生在进程分配的空间</li>
<li>可变分配全局置换：每个进程分配少量物理块,同时维持全局空闲块,进程空间不足时从全局获取</li>
<li>可变分配局部置换：每个进程分配部分物理块,根据每个进程的缺页频率,动态增减进程的空间物理块数</li>
</ul>
<h2 id="磁盘调度">磁盘调度</h2>
<ul>
<li>先来先服务（FCFS）：是按请求访问者的先后次序启动磁盘驱动器，而不考虑它们要访问的物理位置</li>
<li>最短寻道时间优先（SSTF）：让离当前磁道最近的请求访问者启动磁盘驱动器，即是让查找时间最短的那个作业先执行，而不考虑请求访问者到来的先后次序，这样就克服了先来先服务调度算法中磁臂移动过大的问题</li>
<li>扫描算法（SCAN）或电梯调度算法：总是从磁臂当前位置开始，沿磁臂的移动方向去选择离当前磁臂最近的那个柱面的访问者。如果沿磁臂的方向无请求访问时，就改变磁臂的移动方向。在这种调度方法下磁臂的移动类似于电梯的调度，所以它也称为电梯调度算法。</li>
<li>循环扫描算法（CSCAN）：循环扫描调度算法是在扫描算法的基础上改进的。磁臂改为单项移动，由外向里。当前位置开始沿磁臂的移动方向去选择离当前磁臂最近的哪个柱面的访问者。如果沿磁臂的方向无请求访问时，再回到最外，访问柱面号最小的作业请求。</li>
</ul>
<h2 id="高速缓存与主存的三种映射方式">高速缓存与主存的三种映射方式</h2>
<ul>
<li>全相联映射：存中任意一个块都可以映射到cache中任意一个块的方式:利用率高但寻找困难</li>
<li>直接相联映射：内存块数%cache块数的值或者其低位地址决定其映射的cache行;寻找方便但是冲突率高</li>
<li>组相连映射:把cache分为x行一组,共y组,对于组实行直接相连映射,对于组内全相联映射</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/83597838" target="_blank" rel="noopener">参考0</a><br>
<a href="https://www.zhihu.com/question/19732473/answer/241673170" target="_blank" rel="noopener">参考1</a><br>
BIO NIO AIO<br>
同步 VS 异步</p>
<blockquote>
<p>是否需要自己主动去获取结果;<br>
场景：发送完请求,可以不等待请求结果,发送下一个请求,提高效率,保证并发<br>
是否存在异步阻塞IO?既然异步了,由OS负责准备数据到用户空间,由OS和线程/进程争抢总线,完成之后通知结果,进程本身可以轮询,仍然有自己控制,不算阻塞把</p>
</blockquote>
<p>阻塞 VS 非阻塞</p>
<blockquote>
<p>调用者是否被阻塞,或者说丧失自由/放弃CPU时间<br>
传统的IO流都是阻塞式的</p>
<ul>
<li>本地IO:当一个线程调用read()或者write()方法时，该线程将被阻塞，直到有一些数据读读取或者被写入，在此期间，该线程不能执行其他任何任务</li>
<li>网络IO：在完成网络通信进行IO操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量的客户端时，性能急剧下降<br>
非阻塞IO 不阻塞当前线程,可以做其他事情;由于大多时候,IO操作并不频繁,每个通道/外设 不是随时都有,所以可以有少数线程负责很多IO的输入输出的管理(减少上下文切换时间)</li>
</ul>
</blockquote>
<p>IO模型主要分类：</p>
<ul>
<li>同步IO 和 异步IO</li>
<li>阻塞IO 和 非阻塞IO</li>
<li>同步阻塞IO(synchronize block io): BIO</li>
<li>同步非阻塞IO(synchronize noblock io)</li>
<li>IO多路复用JAVA NIO</li>
<li>异步非阻塞IO(asychronous noblock io): AIO/IOCP</li>
</ul>
<p>用户程序进行IO的读写，基本上会用到系统调用read&amp;write，read把数据从内核缓冲区复制到进程缓冲区，write把数据从进程缓冲区复制到内核缓冲区，它们不等价于数据在内核缓冲区和磁盘之间的交换。<br>
BIO</p>
<blockquote>
<p>创建连接的那个线程会阻塞自己到等待数据到达,由内核进程复制数据到用户空间,之后可以运行</p>
</blockquote>
<p>同步非阻塞</p>
<blockquote>
<p>创建连接的线程调用完之后可以得到是否调用成功的结果,然后可以轮询询问是否完成(也可以分批获取缓冲区的数据,不必要一次性获得)<br>
适用于大量网络连接且IO不频繁的状态,避免大量创建线程同时可以从内核缓冲区读取不完整的数据(例如拆包粘包Netty)</p>
</blockquote>
<p>NIO</p>
<blockquote>
<p>创建连接的线程向selector注册一个channel,由其负责处理所有I操作,监控channel,并分发写进buffer,然后自己转做其他事情</p>
</blockquote>
<p>BIO VS NIO</p>
<blockquote>
<p>面向流 面向缓冲区<br>
阻塞   非阻塞<br>
无     selector</p>
</blockquote>
<p>BIO、NIO、AIO适用场景</p>
<blockquote>
<p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择。<br>
NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂。<br>
AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持</p>
</blockquote>
<p>selcet/poll/epoll 都属于 同步IO</p>
<p>Netty</p>
<h3 id="大端存储-小端存储">大端存储 小端存储</h3>
<blockquote>
<p>大端存储与小端存储模式主要指的是数据在计算机中存储的两种字节优先顺序。<br>
小端存储指从内存的低地址开始,先存储数据的低序字节再存高序字节;相反,大端存储指从内存的低地址开始,先存储数据的高序字节再存储数据的低序字节</p>
</blockquote>
<p>用途：</p>
<blockquote>
<p>小端存储:常见于本地主机上(也有部分类型主机为大端存储)<br>
大端存储:常见于网络通信上，网际协议TCP/IP在传输整型数据时一般使用大端存储模式表示,例如TCP/IP中表示端口和IP时，均采用的是大端存储</p>
</blockquote>
<p>如何避免死锁：</p>
<ul>
<li>银行家算法：分配资源前先评估风险，会不会在分配后导致死锁。</li>
<li>顺序加锁，这样能防止死锁现象</li>
</ul>
<p>多线程 VS 多进程</p>
<ul>
<li>线程只是进程的一个执行路径</li>
</ul>
<h3 id="文件描述符">文件描述符</h3>
<p><a href="https://segmentfault.com/a/1190000009724931" target="_blank" rel="noopener">文件描述符（File Descriptor）简介</a><br>
系统为了维护文件描述符,维持了3个层次的表</p>
<ul>
<li>进程层次的文件描述符表
<ul>
<li>文件描述符flag</li>
<li>指向系统级表的指针</li>
</ul>
</li>
<li>系统级的文件描述符表
<ul>
<li>当前文件的偏移</li>
<li>状态标识</li>
<li>文件访问模式:读 写 读写</li>
<li>inode引用</li>
<li>其他:访问权限,文件其他属性等</li>
</ul>
</li>
<li>文件系统的inode表
<ul>
<li>文件类型</li>
<li>文件锁</li>
</ul>
</li>
</ul>
<p>当我们打开一个文件或者建立socket时,会返回一个文件描述符,就是一个数字(0 1 2 分别默认标准输入/输出/错误输出),标识在进程空间内文件描述符表的索引(进程描述符表的长度默认为1024)</p>
<p>socket 连接使用过程</p>
<ul>
<li>create socket :寻找inode文件,创建相关数据结构,并返回文件描述符</li>
<li>bind：把socket与ip port 绑定(客户端无需调用,在connect时会自动分配一个port)</li>
<li>listen：将连接socket转化为监听套接字(更改socket状态为LISTEN)由tcp/ip协议簇完成监听</li>
<li>accept:
<ul>
<li>客户端会通过connect连接服务端,服务端会维持两个连接队列,未完成3次握手的和已完成3次握手的</li>
<li>accept函数默认为阻塞函数,当已完成握手连接队列非空时,会返回队列首的连接文件描述符(一个完整的连接套接字,包含源目的端口ip,这样可以实现socket复用)</li>
</ul>
</li>
<li>send/recv：</li>
<li>select/poll/epoll
<ul>
<li>select 成功返回就绪的文件描述符数量,如果&gt;0,则循环遍历事件,然后确定是哪个并处理</li>
</ul>
</li>
</ul>
<p>socket描述</p>
<blockquote>
<p>accept建立连接之后,返回一个文件描述符,指向socket套接字,包含源ip/端口 目的ip/端口 也就是父进程与fork出的子进程共同监听一个端口,但是由于请求类型不同(建立连接由主进程负责,而已建立的连接由多个子进程竞争锁获得负责) 可以区分<br>
<a href="http://blog.chinaunix.net/uid-23629988-id-285722.html" target="_blank" rel="noopener">kernel如何选择socket接收数据</a> 根据协议选择不同链表,然后遍历选择(源ip端口等信息)最符合的socket</p>
</blockquote>
<p>select</p>
<blockquote>
<p>在内核处理时需要两次循环遍历发现就绪,在外也需要循环遍历发现就绪事件,耗时,且传进去的fd_set位图表示监视的文件描述符,默认限制1024长度<br>
select在调用时使用不同set表示监听不同的事件类型(读写异常);do-select 中会对调用返回对应文件的poll函数,检测是否有时间发生,如果发生返回类型mask,并判断是否是读/写/异常,然后添加进不同的返回列表中;</p>
</blockquote>
<p>poll<br>
<a href="https://blog.51cto.com/10706198/1783610" target="_blank" rel="noopener">使用示例</a></p>
<h4 id="select-解析">select 解析</h4>
<p><a href="http://lxr.linux.no/linux+v3.9/fs/select.c" target="_blank" rel="noopener">select 内核源码</a><br>
<a href="https://blog.csdn.net/weixin_42462202/article/details/95315926" target="_blank" rel="noopener">Linux select内核源码剖析</a><br>
<a href="https://blog.csdn.net/caogenwangbaoqiang/article/details/80949643" target="_blank" rel="noopener">select模型linux内核源码注释总结</a></p>
<p>select函数的参数</p>
<ul>
<li>最大文件描述符+1</li>
<li>读事件监听set</li>
<li>写事件监听set</li>
<li>异常事件监听set</li>
<li>默认等待时间(null:阻塞;0:立刻返回;其他)</li>
</ul>
<p>select -&gt; do_select<br>
在死循环中,</p>
<ul>
<li>遍历文件描述符,并调用其poll函数,将该进程添加进其等待队列 然后陷入睡眠</li>
<li>如果时间到达或者被中断唤醒,会继续循环遍历文件描述符,如果调用poll函数后发现有时间发生,就绪事件记录+1,遍历完成后,如果就绪事件&gt;0或者等待超时,就跳出死循环,否则继续休眠</li>
</ul>
<p>缺点：</p>
<ul>
<li>fd set长度有限制</li>
<li>需要在用户空间和内核空间之间拷贝fdset数据</li>
<li>检查是否发生事件时,是轮询遍历,而且范围内包含不关注的文件描述符;返回结果也需要轮询</li>
</ul>
<h3 id="poll-解析">poll 解析</h3>
<p><a href="https://blog.51cto.com/10706198/1783610" target="_blank" rel="noopener">使用示例</a><br>
<a href="http://gityuan.com/2019/01/05/linux-poll-select/" target="_blank" rel="noopener">源码解析</a><br>
<a href="https://www.cnblogs.com/shuqin/p/11662645.html" target="_blank" rel="noopener">poll(2) 源码分析</a><br>
poll 函数的参数</p>
<ul>
<li>pollfd数组</li>
<li>最大文件描述符</li>
<li>时间</li>
</ul>
<p>poll利用 pollfd 结构体记录 file-description 和 event(POLLINT/POLLOUT/异常) 以及 revents(系统触发的事件)<br>
过程</p>
<ul>
<li>利用 pollfd 数组记录监听的文件描述符对应的连接以及类型;</li>
<li>之后调用poll函数,其内会将数组转化为链表(按页分配内存申请内存,每页存储一个pollfd数组,利用<a href="https://lenzhao.com/topic/5a28f4b52e95f0fd0a9818a8" target="_blank" rel="noopener">copy_from_user</a>把用户空间的pollfd拷贝到核心空间,然后next页,如果分配失败就会free所有节点,然后返回内存错误);</li>
<li>之后根据链表来遍历;大致过程与select类似,但是会将触发的事件类型记录在revents中(首先会过滤掉不感兴趣的事件);并通过copy_to_user 拷贝回用户空间</li>
<li>在poll返回的结果&gt;0则会轮询查询event与revents是否一致</li>
</ul>
<p>相对于select 突破了1024的默认长度限制,只要满足长度小于RLIMIT_NOFILE(进程最大打开文件描述符限制即可;可以设置65535)</p>
<p>缺点：</p>
<ul>
<li>仍需在用户和内核空间拷贝数据,量变得更大</li>
<li>相对于select更精确,但检查事件以及返回时然后需要遍历确认</li>
</ul>
<h3 id="epoll-解析">epoll 解析</h3>
<p><a href="http://lxr.linux.no/linux+v3.9/fs/eventpoll.c" target="_blank" rel="noopener">eventspoll源码</a><br>
<a href="http://lxr.linux.no/linux+v3.9/include/linux/fs.h" target="_blank" rel="noopener">struct file</a><br>
<a href="http://wxgg.cc/blogs/2018/12/libevent-cpp-5-%E5%B0%81%E8%A3%85epoll%E5%8F%8Aepoll%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" target="_blank" rel="noopener">封装epoll及epoll内核实现原理</a><br>
<a href="https://www.iminho.me/wiki/blog-23.html" target="_blank" rel="noopener">IO多路复用原理剖析</a><br>
<a href="http://gityuan.com/2019/01/06/linux-epoll/" target="_blank" rel="noopener">源码解读epoll内核机制</a><br>
<a href="https://www.cnblogs.com/apprentice89/p/3234677.html" target="_blank" rel="noopener">epoll用法回顾</a><br>
<a href="https://icoty.github.io/2019/06/03/epoll-source/" target="_blank" rel="noopener">epoll源码分析(基于linux-5.1.4)</a><br>
<a href="https://zhuanlan.zhihu.com/p/64746509" target="_blank" rel="noopener">如果这篇文章说不清epoll的本质，那就过来掐死我吧</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct eventpoll &#123;</span><br><span class="line">    spinlock_t lock;</span><br><span class="line">    struct mutex mtx;</span><br><span class="line">    //调用epoll_wait过程中陷入阻塞的进程队列</span><br><span class="line">    wait_queue_head_t wq;</span><br><span class="line">    //与文件相关的等待队列,保存了所有等待该文件相关事件的进程(file-&gt;poll()),对于该文件的读写操作会唤醒该队列</span><br><span class="line">    wait_queue_head_t poll_wait;</span><br><span class="line">    //就绪状态的文件描述符的列表</span><br><span class="line">    struct list_head rdllist;</span><br><span class="line">    //存储监控的红黑树</span><br><span class="line">    struct rb_root rbr;</span><br><span class="line">    struct file *file;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>过程：</p>
<ul>
<li>epoll_create:创建file实例,创建eventpoll,赋值给file-&gt;private_date,获得未使用fd与改file绑定,然后返回fd</li>
<li>epoll_ctl:控制监听的事件,增加/删除/修改,实质是通过对之前创建的eventpoll中的红黑树进行操作以insert为例
<ul>
<li>初始化epollitem(fd file)</li>
<li>初始化ep_pqueue,添加到socket文件的等待队列并注册回调函数ep_ptable_queue_proc-&gt;ep_poll_callback(判断是否是感兴趣的事件,添加进epoll的就绪队列,并唤醒epoll在wait阶段的阻塞进程)</li>
<li>在红黑树中插入节点</li>
</ul>
</li>
<li>epoll_wait: 调用 ep_poll ,在死循环中判断:如果就绪队列为空,那么休眠,将自己阻塞在eventpoll的等待队列,等待ep_poll_callback 唤醒 否则跳出循环,拷贝就绪队列的events事件到用户空间</li>
</ul>
<p>其他</p>
<ol>
<li>红黑树中存储需要监听的事件,节点类型是epollitem,比较的方法是首先比较socket对应的file指针地址(没看到重写比较符) 然后比较fd值</li>
<li>ep_poll_callback 函数 会首先将当前触发的操作的添加到eventpoll的就绪队列,然后唤醒该eventpoll的等待队列</li>
</ol>
<p>优点:相对于select/poll 的轮询和数据拷贝操作</p>
<ul>
<li>利用回调函数,在唤醒时将就绪的文件添加到就绪队列,拷贝回用户空间,无需轮询(将之前的wait操作拆分为ctl和wait操作)</li>
<li>利用eventpoll中的红黑树存储关注的文件描述符和事件,无需频繁的拷贝所有数据</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于大量的频发事件,会频繁调用回调函数,效率不高,适合大量低速的连接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct epitem &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        struct rb_node rbn; //RB树节点将此结构链接到eventpoll RB树</span><br><span class="line">        struct rcu_head rcu; //用于释放结构体epitem</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    struct list_head rdllink; //用于将此结构链接到eventpoll就绪列表的列表标头</span><br><span class="line">    struct epitem *next; //配合ovflist一起使用来保持单向链的条目</span><br><span class="line">    struct epoll_filefd ffd; //此条目引用的文件描述符信息</span><br><span class="line">    int nwait; //附加到poll轮询中的活跃等待队列数</span><br><span class="line"></span><br><span class="line">    struct list_head pwqlist;</span><br><span class="line">    struct eventpoll *ep;  //epi所属的ep</span><br><span class="line">    struct list_head fllink; //链接到file条目列表的列表头</span><br><span class="line">    struct wakeup_source __rcu *ws; //设置EPOLLWAKEUP时使用的wakeup_source</span><br><span class="line">    struct epoll_event event; //监控的事件和文件描述符</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="et-lt">ET LT</h3>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/05/Blog/blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/05/Blog/blog/" class="post-title-link" itemprop="url">blog 产生记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-05 22:52:19" itemprop="dateCreated datePublished" datetime="2020-07-05T22:52:19+08:00">2020-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-09 16:00:31" itemprop="dateModified" datetime="2020-12-09T16:00:31+08:00">2020-12-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/05/Blog/个人网站/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/05/Blog/个人网站/" class="post-title-link" itemprop="url">个人网站搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-05 22:52:19" itemprop="dateCreated datePublished" datetime="2020-07-05T22:52:19+08:00">2020-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-10 10:20:17" itemprop="dateModified" datetime="2020-12-10T10:20:17+08:00">2020-12-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="域名">域名</h1>
<h2 id="域名购买">域名购买</h2>
<p>国内域名</p>
<h2 id="域名解析">域名解析</h2>
<p>godaddy<br>
国内解析<br>
cloudflare</p>
<h1 id="审核">审核</h1>
<h2 id="阿里云-初审">阿里云 初审</h2>
<p>主要是网站名称的问题，发现不能使用成语。</p>
<h2 id="管局审核">管局审核</h2>
<p>在hexo相应处增加该信息</p>
<h2 id="公安局审核">公安局审核</h2>
<p>公安联网备案申请,并在hexo相应处增加该信息</p>
<h1 id="部署">部署</h1>
<h2 id="服务器部署hexo">服务器部署hexo</h2>
<h3 id="安装必要软件">安装必要软件</h3>
<p>git nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get-install nodejs npm</span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h3 id="配置服务器文件夹接受本地hexo传输文件">配置服务器文件夹接受本地hexo传输文件</h3>
<p>参考<a href="https://www.cnblogs.com/luoshuitianyi/p/10333928.html" target="_blank" rel="noopener">Hexo搭建(VPS)</a></p>
<ol>
<li>创建裸仓库，用于接受文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir hexo.git</span><br><span class="line">cd hexo.git</span><br><span class="line">git init --bare # 裸仓库只存储历史和元数据信息，不维护工作目录</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建文件夹(中转目录和nginx根目录)以及git hook</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/hexo  #中转目录</span><br><span class="line">mkdir /var/www/hexo #nginx 根目录</span><br></pre></td></tr></table></figure>
<p>编辑 hooks/post-receive 文件,指定 ~/hexo.git/目录下的仓库更新后的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">GIT_REPO=~/hexo.git                      # 触发 hook</span><br><span class="line">TMP_GIT_CLONE=/tmp/hexo                  # 存在 /tmp 下</span><br><span class="line">PUBLIC_WWW=/var/www/hexo                 # 展示网站的目录</span><br><span class="line">rm -rf $&#123;TMP_GIT_CLONE&#125;                  # 删除之前内容</span><br><span class="line">git clone $GIT_REPO $TMP_GIT_CLONE       # 将 Git 仓库上传的内容复制到/tmp</span><br><span class="line">rm -rf $&#123;PUBLIC_WWW&#125;/*                   # 删除展示网站的目录的全部内容</span><br><span class="line">cp -rf $&#123;TMP_GIT_CLONE&#125;/* $&#123;PUBLIC_WWW&#125;  # 将/tmp所有内容复制到网站目录</span><br></pre></td></tr></table></figure>
<p>使得post-receive 可执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x hexo/hexo.git/hooks/post-receiv</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>配置https<br>
从阿里云申请免费证书，下载证书，放置在相关位置，并修改nginx配置文件</li>
</ol>
<figure class="highlight plain"><figcaption><span>of Hexo</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        listen [::]:80;</span><br><span class="line">        server_name _;</span><br><span class="line">        rewrite ^/(.*)$ https://www.whetstone.life:443/$1 permanent;</span><br><span class="line">&#125;</span><br><span class="line">#Config of https</span><br><span class="line">server &#123;</span><br><span class="line">        listen 443;</span><br><span class="line">        listen [::]:443;</span><br><span class="line">        server_name _;</span><br><span class="line">        ssl on;</span><br><span class="line">        ssl_certificate /etc/nginx/ssl/www.whetstone.life.pem;</span><br><span class="line">        ssl_certificate_key /etc/nginx/ssl/www.whetstone.life.key;</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        server_name _;</span><br><span class="line">        location / &#123;</span><br><span class="line">                root /var/www/hexo;</span><br><span class="line">                index index.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改防火墙,在阿里云ECS实例中修改安全组规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 443 -j ACCEPT</span><br></pre></td></tr></table></figure>
<h2 id="配置-ssh-互信">配置 ssh 互信</h2>
<p>只需要服务器信任本地host即可,方便从本地传输文件到服务器无需输入密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp ./.ssh/id_rsa.pub root@ip:/root</span><br><span class="line">cat id_rsa.pub &gt; .ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<h2 id="本地hexo配置deploy">本地hexo配置deploy</h2>
<p>配置多个deploy对象，参考 <a href="https://hexo.io/zh-cn/docs/one-command-deployment" target="_blank" rel="noopener">hexo deploy配置</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: git</span><br><span class="line">  repository: git@github.com: ***/***.github.io.git </span><br><span class="line">  branch: master </span><br><span class="line">- type: git</span><br><span class="line">  repository: root@ip:/path/to/push</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/05/基础知识/Clousim/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/05/基础知识/Clousim/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-05 16:40:45" itemprop="dateCreated datePublished" datetime="2020-07-05T16:40:45+08:00">2020-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-30 13:25:00" itemprop="dateModified" datetime="2020-08-30T13:25:00+08:00">2020-08-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="http://www.trojx.me/2019/12/30/cloudsim-plus-faq/" target="_blank" rel="noopener">云计算仿真工具CloudSim Plus常见问题总结</a><br>
<a href="https://veviz.github.io/2016/05/17/CloudSim/" target="_blank" rel="noopener">CloudSim Introduction</a><br>
<a href="https://blog.csdn.net/wjh1313677/article/details/45625999" target="_blank" rel="noopener">CloudSim源码分析-DatacenterBroker创建</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/30/工作求职/Java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/30/工作求职/Java/" class="post-title-link" itemprop="url">java 语言学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-30 15:42:16" itemprop="dateCreated datePublished" datetime="2020-06-30T15:42:16+08:00">2020-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-15 10:57:35" itemprop="dateModified" datetime="2021-01-15T10:57:35+08:00">2021-01-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="多线程">多线程</h1>
<h2 id="线程创建方法">线程创建方法</h2>
<blockquote>
<p>1.继承Thread类，重写run()线程执行程序，创建线程<br>
2.实现Runnable接口，重写run()方法，作为参数构造thread，创建线程<br>
3.使用Callable和Future创建线程<br>
4.使用线程池例如用Executor框架</p>
</blockquote>
<ul>
<li>Executor 的参数</li>
</ul>
<blockquote>
<p>实现Runnable接口比继承Thread类所具有的优势：<br>
1)可以避免java中的单继承的限制；可以继承多个接口<br>
2)Thread 实现了Runnable 接口, 提供了更多的可用方法和成员而已</p>
</blockquote>
<h2 id="多线程">多线程</h2>
<p>synchronize作为多线程关键字，是一种同步锁，它可以修饰以下几种对象：</p>
<ul>
<li>代码块：被修饰的代码块称为同步语句块，其作用的范围是大括号{ }里的代码，作用的对象是调用这个代码块的对象；</li>
<li>方法：被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象</li>
<li>静态方法：作用的范围是整个静态方法，作用的对象是这个类的所有对象</li>
<li>类：作用的范围是synchronize后面括号里的部分，作用的对象是这个类的所有对象</li>
</ul>
<p>锁：线程争夺对于锁，获取锁，然后运行代码</p>
<ul>
<li>对象锁 this 对象,其他对象</li>
<li>类锁</li>
</ul>
<blockquote>
<p>线程开始<br>
线程停止：正常执行完run；interrupt使得线程异常，执行完run<br>
其他：</p>
<blockquote>
<p>设置线程优先级(特性：继承性(线程A启动线程B，B继承A的优先级) ; 随机性(线程的调度顺序不一定根据优先级,具有随机性))<br>
yield方法，释放CPU资源，通常它会让当前运行线程回到可运行性状态，使得有相同优先级的线程有机会执行。<br>
sleep方法，使当前线程睡眠至少时间<br>
join()方法：保证当前线程停止执行，直到该线程所加入的线程完成为止。然而，如果它加入的线程没有存活，则当前线程不需要停止（基于wait方法和notify方法）</p>
</blockquote>
</blockquote>
<h1 id="gc">GC</h1>
<h2 id="背景">背景</h2>
<blockquote>
<p>内存空间是有限的，如果高效利用有限的空间，可以通过释放不适用的对象所占用的内存(Java虚拟机所管理的内存区域分为如下部分：方法区、堆内存、虚拟机栈、本地方法栈、PC寄存器)</p>
</blockquote>
<h2 id="gc对象">GC对象</h2>
<blockquote>
<p>程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理；内存垃圾回收主要集中于 java 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的</p>
</blockquote>
<h3 id="判定方法">判定方法</h3>
<blockquote>
<p>如何判断对象不再存活：引用计数（每个对象有一个引用计数属性，计数为0时可以回收，但无法解决对象相互循环引用的问题）和可达分析（通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连，则证明此对象是不可用的）</p>
</blockquote>
<h3 id="触发gc的条件">触发GC的条件</h3>
<blockquote>
<p>1.程序主动调用System.gc<br>
2.内存不足被动触发(年轻代升级空间不够,或者永久代空间不足)</p>
</blockquote>
<h2 id="gc-roots">GC ROOTS</h2>
<blockquote>
<p>虚拟机栈、方法区和本地方法栈；方法区中类静态属性引用的对象；常量<br>
1.系统类加载器锁加载的类<br>
2.阻塞线程以及运行线程涉及的对象；本地方法栈涉及的对象<br>
3.全局对象，上锁对象<br>
4.针对younggc来说，gcroot的对象包括所有年老带对象</p>
</blockquote>
<h2 id="为对象分配内存的方法">为对象分配内存的方法</h2>
<ul>
<li>规整内存/指针碰撞:将内存分为已使用和未使用的两部分,使用指针将两者隔开,然后指针右移需要的空间即可(建立在压缩空闲空间的基础上,耗时)</li>
<li>空闲列表法:把空间的空间的大小范围列表排序,然后选择(有首次适应,循环适应,最有适应,最坏适应)</li>
</ul>
<p>卡表(cardTable)</p>
<blockquote>
<p>JVM 把每512字节表示为一个卡页,<br>
为了提高重新标记的效率，并发标记阶段会把这些发生变化的对象所在的Card标识为Dirty，这样后续阶段就只需要扫描这些Dirty Card的对象，从而避免扫描整个老年代</p>
</blockquote>
<h2 id="gc常用算法">GC常用算法</h2>
<blockquote>
<p>1.标记-清除算法：标记对象的存活或者死亡;清除对象会导致大量碎片<br>
2.复制算法：内存分为两部分，只使用其中一部分，这部分内存用完后，将其中存活的对象移动至另一部分，其他删除；没有碎片，但内存利用率低<br>
3.标记-压缩算法：在上种算法的基础上，将存活的对象整理到一起；如果存活对象过多会导致，复制次数过多，效率下降<br>
4.分代收集算法（JVM Hotspot在使用）：根据对象的生存周期，将堆分为新生代(Young)和老年代(Tenure)。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。</p>
</blockquote>
<h3 id="cms">CMS</h3>
<blockquote>
<p>基于标记-清除算法<br>
堆被划分为新生代和老年代，新生代又被进一步划分为Eden和Survivor区，而Survivor由FromSpace和ToSpace组成。<br>
<br>新生代：新创建的对象都是用新生代分配内存，Eden空间不足时，触发Minor GC，这时会把存活的对象转移进Survivor区。<br>
<br>老年代：老年代用于存放经过多次Minor GC之后依然存活的对象，老年代内存不足时触发，Major GC</p>
</blockquote>
<h3 id="zgc">ZGC</h3>
<blockquote>
<p>todo</p>
</blockquote>
<h3 id="cms-vs-g1"><a href="https://www.cnblogs.com/heyonggang/p/11718170.html" target="_blank" rel="noopener">CMS VS G1</a></h3>
<blockquote>
<p>CMS：Concurrent Mark Sweep，基于标记-清楚算法，作用于老年代，以并发获取最短回收停顿时间为目标的</p>
<blockquote>
<p>初始标记（标记root直接关联的对象）、并发标记（root  trace）、重新标记（并发标记中涉及的对象）、并发清除（CMS concurrent sweep）<br>
优点：并发收集、低停顿<br>
缺点：</p>
<blockquote>
<p>CMS收集器对CPU资源非常敏感，频繁GC，CPU资源不足。<br>
CMS收集器无法处理浮动垃圾（Floating Garbage），并发清除阶段，运行产生的垃圾无法在本次回收。<br>
CMS收集器是基于标记-清除算法，导致碎片。<br>
安全点：程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停，安全点的初始目的是找到一个稳定的执行状态。在这个执行状态下，Java虚拟机的堆栈不会发生变化；长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等<br></p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<p>G1：Garbadge First Collector；基于标记-整理算法；G1重新定义了堆空间，将堆划分为一个个区域；来进行垃圾回收，不必在全堆范围内收集，可以预测停顿时间</p>
<blockquote>
<p>与CMS的步骤类似，只是第4步时，他根据region排序价值和预测时间去清除，最后然后拷贝存活对象至新的region<br>
卡表：？？？与老年代引用年轻代<br>
相对于CMS优势：可预测的停顿模型；避免了CMS的垃圾碎片；超大堆的表现更出色</p>
</blockquote>
</blockquote>
<h1 id="设计模式">设计模式</h1>
<h2 id="单例模式">单例模式</h2>
<blockquote>
<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象</p>
</blockquote>
<blockquote>
<blockquote>
<ol>
<li>懒汉模式：实例在使用到的时候才创建,当多线程并发调用 getInstance(),如果方法不加synchronize 关键字修饰,会导致线程不安全</li>
</ol>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class LHan &#123;</span><br><span class="line">    private static LHan instance;</span><br><span class="line">    private LHan()&#123;&#125;</span><br><span class="line">    public static LHan getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            instance = new LHan();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<ol start="2">
<li>饿汉模式,实例在最初已经初始化,getInstance()方法线程安全，但浪费内存空间</li>
</ol>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class EHan &#123;</span><br><span class="line">    private static EHan instance = new EHan();</span><br><span class="line">    private EHan()&#123;&#125;</span><br><span class="line">    public static EHan getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<ol start="3">
<li>双检锁,双重校验锁,在synchronize 关键字内外都加上一层if判断,即避免内存浪费,又保证了线程安全,同时 比直接上锁提高了执行效率</li>
</ol>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class DoubleCheck &#123;</span><br><span class="line">    private static DoubleCheck instance;</span><br><span class="line">    private DoubleCheck()&#123;&#125;</span><br><span class="line">    public static DoubleCheck getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            synchronize(DoubleCheck.class)&#123;</span><br><span class="line">                if(instance == null)&#123;</span><br><span class="line">                    instance = new DoubleCheck();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<ol start="4">
<li>静态内部类(内部类是外部类的一个成员,分为静态内部类和非静态内部类：静态内部类可以直接调用外部类的静态成员(静态成员变量和静态方法)，但是不能直接调用外部类的非静态成员；而非静态内部类可以直接调用外部类的其他成员)</li>
</ol>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class SingleTon &#123;</span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static final SingleTon INSTANCE = new SingleTon();</span><br><span class="line">    &#125;</span><br><span class="line">    private SingleTon()&#123;&#125;</span><br><span class="line">    public static final SingleTon getInstance()&#123;</span><br><span class="line">        return SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<ol start="5">
<li>枚举</li>
</ol>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum SingleTonn &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public void AnyMethod()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id></h1>
<h1 id="其他常见问题">其他常见问题</h1>
<h2 id="hashmap-hashtable-concurrenthashmap">HashMap HashTable ConcurrentHashMap</h2>
<blockquote>
<p>都是 数组+单链表 实现<br>
<a href="https://blog.csdn.net/mbshqqb/article/details/79799009" target="_blank" rel="noopener">参考1</a><br>
HashMap基于hashing原理，我们通过put()和get()法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用LinkedList来解决碰撞问题，当发生碰撞了，对象将会储存在LinkedList的下一个节点中。 HashMap在每个LinkedList节点中储存键值对对象。<br>
　　当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的LinkedList（链表只让挂7个元素，超过七个就会转成一个红黑树进行处理，当红黑树下挂的节点小于等于6的时候，系统会把红黑树转成链表）中。键对象的equals()方法用来找到键值对<br>
String, Interger这样的类，作为HashMap的键是再适合不过了，因为String对象是不可变的，计算hashCode()，就要防止键值改变</p>
</blockquote>
<blockquote>
<p>HashTable：无论key还是value都不能为null，线程安全，实现线程安全的方式是在修改数据时锁住整个HashTable；<br>
HashMap：无论key还是value都能为null，线程不安全（在多个线程并发扩容时，会在执行transfer()方法转移键值对时，造成链表成环，导致程序在执行get操作时形成死循环 <a href="https://www.cnblogs.com/lonelyJay/p/9726187.html" target="_blank" rel="noopener">参考1</a> <a href="https://www.sohu.com/a/341902281_100123073" target="_blank" rel="noopener">参考2</a> ;单链表复制是是插入排序，因为时刻知道链表头在哪）</p>
</blockquote>
<blockquote>
<p>但是 HashMap线程不安全，而HashTable安全但是效率低，出现了ConcurrentHashMap使用分段锁<br>
cocurrent 将hashmap的数据分为若干个子数组,每个子数组包装为segment对其加锁;<br>
抛开 HashMap，hash 冲突有那些解决办法？开放定址法、链地址法、再哈希法<br>
<a href="https://www.cnblogs.com/cosmos-wong/p/11845934.html" target="_blank" rel="noopener">java stack不推荐使用</a>,建议使用dequeue代替</p>
</blockquote>
<p>HashMap 扩容时机</p>
<ul>
<li>hashmap首次插入元素时会resize初始化table</li>
<li>hashmap中元素总数量达到阈值threshold(阈值初始化时等于)</li>
<li>如果某个链表的长度&gt;=8-1,则转化为红黑树(小于等于6时转换回来);在转化时,首先判断数组长度是否小于64那么就扩容,否则才转化</li>
</ul>
<h2 id="linkedhashmap-treemap">LinkedHashMap TreeMap</h2>
<blockquote>
<p>LinkedHashMap保存了记录的插入顺序,在用Iterator遍历LinkedHashMap时,先得到的记录肯定是先插入的,也可以在构造时用带参数,按照应用次数排序.<br>
在遍历的时候会比HashMap慢,不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关<br>
TreeMap实现SortMap接口,能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。插入查询的效率都是O(logN)</p>
</blockquote>
<h2 id="arraylist-vs-linkedlist">Arraylist VS LinkedList</h2>
<blockquote>
<p>LinkedList与ArrayList一样实现List接口，只是ArrayList是List接口的大小可变数组的实现，LinkedList是List接口链表的实现。基于链表实现的方式使得LinkedList在插入和删除时更优于ArrayList，而随机访问则比ArrayList逊色些。<br>
LinkedList实现所有可选的列表操作，并允许所有的元素包括null。<br>
除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。<br>
此类实现 Deque 接口，为 add、poll 提供先进先出队列操作，以及其他堆栈和双端队列操作</p>
</blockquote>
<h2 id="volatile和synchronized特点">volatile和synchronized特点：</h2>
<blockquote>
<p>执行控制（执行顺序，并发）和内存可见（读写经过内存）<br>
volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别(class对象的锁)的<br>
volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞<br>
volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</p>
</blockquote>
<h2 id="java两种数据类型">Java两种数据类型</h2>
<blockquote>
<p>分为基本数据类型（boolean、byte、int、char、long、short、double、float）和引用数据类型（数组、类、接口）<br>
Java为每 一个基本数据类型都引入了对应的包装类型（Boolean，Character，Byte，Short，Integer，Long，Float，Double），可以使用自动装箱/拆箱进行替换（装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型）<br>
例如：int与Integer的基本使用对比</p>
<ul>
<li>Integer是int的包装类，Integer变量必须实例化后才能使用；Integer的默认值是null;int是基本数据类型，int变量不需要初始化，int的默认值是0。</li>
<li>在使用时，Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；</li>
</ul>
</blockquote>
<h2 id="设计模式">设计模式</h2>
<blockquote>
<p><a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/design-pattern-tutorial.html</a><br>
工厂模式:定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行<br>
优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p>
<p>控制反转（Inversion of Control，缩写为IoC）；依赖注入<br>
缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事<br>
使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。2、设计一个连接服务器的框架，需要三个协议，“POP3”、“IMAP”、“HTTP”。</p>
<p>单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br>
主要解决：一个全局使用的类频繁地使用，实现共享，锁,static<br>
优点：1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。2、避免对资源的多重占用（比如写文件操作）。<br>
缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<p>装饰器模式:动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活<br>
主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。<br>
优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能.<br>
缺点：多层装饰比较复杂。</p>
<p>组合模式：是用于把一组相似的对象当作一个单一的对象</p>
<p>外观模式：隐藏系统的复杂性，客户端请求的简化方法和对现有系统类方法的委托调用（列类似于自动化脚本的概念）。<br>
优点： 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。<br>
缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</p>
<p>代理模式：其他对象提供一种代理以控制对这个对象的访问<br>
主要解决：远程调用，RPC；直接调用带来的危险，添加控制，火车站<br>
静态代理：添加日志</p>
</blockquote>
<h2 id="堆栈">堆栈</h2>
<blockquote>
<p>都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。<br>
堆：一棵树的数组对象（大顶堆，小顶堆），一般程序员申请    ；栈：先入后出，有一半程序员申请 队列：先入先出</p>
</blockquote>
<h2 id="bean">bean</h2>
<blockquote>
<p><a href="https://www.awaimai.com/2596.html" target="_blank" rel="noopener">https://www.awaimai.com/2596.html</a><br>
bean是一个由Spring IoC容器实例化、组装和管理的对象。<br>
类的实例化、依赖的实例化、依赖的传入都交由 Spring Bean 容器控制而不是new</p>
</blockquote>
<h2 id="malloc-vs-new">malloc VS new</h2>
<h2 id="4种io模式">4种IO模式</h2>
<blockquote>
<ul>
<li>同步阻塞IO（Blocking IO）</li>
<li>同步非阻塞IO（Non-blocking IO）</li>
<li>IO多路复用（IO Multiplexing）</li>
<li>异步IO（Asynchronous IO）<br>
<a href="https://blog.csdn.net/qq_34802511/article/details/81543817" target="_blank" rel="noopener">https://blog.csdn.net/qq_34802511/article/details/81543817</a><br>
同步io操作导致请求进程阻塞，直到i/o操作完成；异步io操作不导致请求进程阻塞<br>
以read IO为例子，大致分为2步 1）等待数据准备(数据从磁盘拷贝到内核内存) 2）将数据从内核拷贝到进程中<br>
同步阻塞在两个阶段都会阻塞；而同步非阻塞IO只会在第二个阶段阻塞，进程在第一步受阻后，会返回，然后反复询问是否内核准备好数据；<br>
IO多路复用：在同步非阻塞的基础上，可以使用一个进程监视多个输入（select，poll，epoll）<br>
而异步IO中，两步都不会造成阻塞，知道数据已经复制到进程内存区，会通知进程</li>
</ul>
</blockquote>
<h2 id="nio">NIO</h2>
<blockquote></blockquote>
<p><a href="https://juejin.im/post/6844903729435508750" target="_blank" rel="noopener">Java ClassLoader 再不理解就老了</a></p>
<h2 id="类的加载">类的加载</h2>
<p>在类的加载之前需要首先基于javac命令将java源文件编译成class文件,然后在运行中加载.<br>
我们借助类加载器完成类的加载,类的加载共分为三个阶段:加载 链接(验证 准备 解析)  初始化</p>
<ul>
<li>加载：根据类的全限定名来找到相应的class文件,并加载到内存</li>
<li>链接
<ul>
<li>验证：验证class字节流文件中的信息符合虚拟机的要求,不会危害自身安全</li>
<li>准备：给类变量分配内存并初始化为默认值,初始化常量(final)</li>
<li>解析：将常量池(在编译期即被确定的一些常量)中符号引用转化为直接引用
<ul>
<li>举例：对于类而言就是将全限定名转化为该类在内存中的地址</li>
<li>对于类引用的解析,是在初始化之前加载还是在初始化之后使用前加载,可以由加载器自己决定实现</li>
</ul>
</li>
</ul>
</li>
<li>初始化：给类的静态变量赋给定的初始值,这些操作和静态代码块会统一放置在类构造器<clinit>方法中,该方法只会执行一次.</clinit></li>
<li>使用：在实例构造器<init>方法中包含了代码分别为 父类的初始化方法-普通常量的初始化赋值-普通代码块-构造函数
<ul>
<li>主动使用-触发初始化:new 创建类的实例;访问类的静态变量或类方法;反射;初始化子类导致初始化父类</li>
<li>被动使用- 不会触发初始化:主动使用的一些例外
<ul>
<li>子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化</li>
<li>通过数组定义来引用类，不会触发此类的初始化,例如MyObject[] b = new MyObject[10];</li>
<li>常量字段编译期不确定：UUID.random().toString()</li>
<li>父类接口：一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中运行期才确定的常量）才会初始化</li>
</ul>
</li>
</ul>
</init></li>
<li>卸载：当MySample类被加载，连接和初始化后，它的生命周期就开始了。当代表MySample类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，MySample类在方法区内的数据也会被卸载，从而结束MySample类的生命周期。一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期</li>
</ul>
<blockquote>
<p>由Java虚拟机自带的加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。Java虚拟机自带的类加器包括根类加载器，扩展类加载器和系统类加载器。Java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始引用它们所加载的类的Class对象，因此这Class对象终是可及的。由用户自定义的类加载器所加载的类是可以被卸载的。</p>
</blockquote>
<p>父子类的执行顺序</p>
<ul>
<li>父类<clinit> 子类 <clinit> 虚拟机会保证 子类初始化之前 父类已经初始化defineClass</clinit></clinit></li>
<li>父类<init> 子类<init></init></init></li>
<li><init>:父类<init>+普通成员变量赋值+代码块+构造函数</init></init></li>
</ul>
<h2 id="类加载的委派机制">类加载的委派机制</h2>
<p>通常情况下有4种类加载器:</p>
<ul>
<li>Bootstrap classLoader 特定目录下,JavaHome/lib</li>
<li>Extension classLoader 特定目录下,JavaHome/lib/ext</li>
<li>Application classLoader ClassHome 下 以及 外部依赖</li>
<li>自定义类加载器</li>
</ul>
<p>ClassLoader.defineClass</p>
<blockquote>
<p>将字节流转化为class对象</p>
</blockquote>
<p>ClassLoader.loadClass</p>
<ul>
<li>首先调用findLoadedClass:寻找是否已经加载过该类,如果有则返回</li>
<li>如果无,那么存在父类加载器,则尝试调用父类加载器的loadClass ,那么调用bootstrap 加载器</li>
<li>如果还是找不到,会调用findClass(默认抛出classNotfiound异常,被继承后需要重写逻辑;UrlClassLoader中会根据全限定类名找到路径去加载)</li>
</ul>
<p>如果想违背父类机制</p>
<blockquote>
<p>那么重写loadClass方法,首先调用findLoadedClass  然后直接调用findClass</p>
</blockquote>
<h3 id="相同类的加载">相同类的加载</h3>
<p>利用不同的自定义类加载器实例 实现加载,通过实现不同的findClass方法实现加载,由于JVM 中通过类加载器和全限定类名来确保一个类的唯一性,所以类名字一致但不会重合</p>
<h3 id="钻石依赖">钻石依赖</h3>
<p>项目管理上有一个著名的概念叫着「钻石依赖」，是指软件依赖导致同一个软件包的两个版本需要共存而不能冲突。<br>
MAVEN</p>
<blockquote>
<p>maven 是这样解决钻石依赖的，它会从多个冲突的版本中选择一个来使用，如果不同的版本之间兼容性很糟糕，那么程序将无法正常编译运行。Maven 这种形式叫「扁平化」依赖管理。</p>
</blockquote>
<p>JVM</p>
<blockquote>
<p>使用 ClassLoader 可以解决钻石依赖问题。不同版本的软件包使用不同的 ClassLoader 来加载，位于不同 ClassLoader 中名称一样的类实际上是不同的类。</p>
</blockquote>
<h3 id="threadcontextclassloader">Thread.contextClassLoader</h3>
<p>首先 contextClassLoader 是那种需要显示使用的类加载器，如果你没有显示使用它，也就永远不会在任何地方用到它<br>
其次线程的 contextClassLoader 默认是从父线程那里继承过来的，所谓父线程就是创建了当前线程的线程。程序启动时的 main 线程的 contextClassLoader 就是 AppClassLoader。这意味着如果没有人工去设置，那么所有的线程的 contextClassLoader 都是 AppClassLoader。</p>
<p>用处</p>
<blockquote>
<p>如果不同的线程使用不同的 contextClassLoader，那么不同的线程使用的类就可以隔离开来。<br>
如果我们对业务进行划分，不同的业务使用不同的线程池，线程池内部共享同一个 contextClassLoader，线程池之间使用不同的 contextClassLoader，就可以很好的起到隔离保护的作用，避免类版本冲突。</p>
</blockquote>
<h3 id="类的运行时寻找机制">类的运行时寻找机制</h3>
<ul>
<li>java.lang.File 编译器会自动导入java.lang包</li>
<li>其他import 的包<br>
如果出现多个同名的类,编译器会报错</li>
</ul>
<h3 id="classloader-的传递性">classLoader 的传递性</h3>
<p>当程序在运行中遇到一个未知的类时,虚拟机会使用调用者的class对象的classLoader(class有该字段记录加载器)来加载当前类,通常情况下为系统加载器即AppClassLoader</p>
<h2 id="final-vs-static-vs-finally">final vs static vs finally</h2>
<blockquote>
<p>final 标识常量，创建或者初始化后不可更改，可以修饰 属性，方法（不可被重写），类（不可被继承），局部变量<br>
static 标识唯一性，可以修饰 变量，方法（与类的具体实例），代码段 （仅仅在类被初次加载的时候被调用一次，之后再调用不会再加载；如有父类先进行父类的初始化），不可修饰局部变量<br>
finally 是异常处理里的内容，try catch finally<br>
static final=final static：修饰的属性表示一旦给值，就不可修改，并且可以通过类名访问，也可以修饰方法，表示该方法不能重写</p>
</blockquote>
<h2 id="throws和throw">throws和throw</h2>
<blockquote>
<p>throws出现在方法函数头，可以跟多个异常类名，用逗号隔开，表示出现异常的一种可能性，并不一定会发生这些异常，由调用方去处理，当然也可以不处理，当产生异常，系统会报；<br>
而throw出现在函数体，是抛出了异常，执行throw则一定抛出了某种异常对象。<br>
两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</p>
</blockquote>
<h1 id="异常体系throwable">异常体系(throwable)</h1>
<blockquote>
<p><a href="https://blog.csdn.net/junlixxu/article/details/6096266" target="_blank" rel="noopener">java异常体系</a><br>
Java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类<br>
在Java API中已经定义了许多异常类，这些异常类分为两大类，错误Error和异常Exception</p>
</blockquote>
<h2 id="error">error</h2>
<blockquote>
<p>程序无法处理的错误,多与内存线程相关，比如OutOfMemoryErrorThreadDeath等。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</p>
</blockquote>
<h2 id="exception">Exception</h2>
<blockquote>
<p>Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常</p>
</blockquote>
<h3 id="运行时异常非受检异常">运行时异常(非受检异常)</h3>
<blockquote>
<p>个人理解 运行时才可能出现的异常,比如NullPointerException，IndexOutOfBoundsException，IllegalArgumentException,RuntimeException,InputMismatchException等,可以不处理，系统会统一处理，打出日志</p>
</blockquote>
<h3 id="非运行时异常受检异常checkexception">非运行时异常(受检异常:checkException)</h3>
<blockquote>
<p>系统在预编译检查时发现的错误,必须在编译前解决，否则无法编译成功，比如IOException、SQLException等以及用户自定义的Exception<br>
通过throws 要求调用者必须处理或者向上排除</p>
</blockquote>
<h2 id="异常处理">异常处理</h2>
<ul>
<li>try catch finally</li>
<li>throws 可能的Exception 有调用者处理</li>
<li>异常链的处理,避免异常覆盖：Throwable 里面有 cause同类型字段,可以保存构造异常时传递的根异常参数,实现异常链条</li>
</ul>
<h1 id="出现异常的处理方法">出现异常的处理方法</h1>
<p>top<br>
ps -ef<br>
gc<br>
iostat  查TCP 连接</p>
<h1 id="java-多线程-java多线程面试题">Java 多线程 <a href="https://blog.csdn.net/qq_36387471/article/details/105479238" target="_blank" rel="noopener">Java多线程面试题</a></h1>
<h1 id="java-spi机制是什么">Java SPI机制是什么？</h1>
<blockquote>
<p>SPI(service Provider  interface)是一种服务发现机制，提供服务接口，且为该接口寻找服务的实现<br>
约定：</p>
</blockquote>
<ul>
<li>当服务提供者提供了接口的一种具体实现后，在jar包的META-INF/services目录下创建一个以“接口全限定名”为命名的文件，内容为实现类的全限定名；</li>
<li>接口实现类所在的jar包放在主程序的classpath中；</li>
<li>主程序通过java.util.ServiceLoder动态装载实现模块，它通过扫描META-INF/services目录下的配置文件找到实现类的全限定名，把类加载到JVM；</li>
<li>SPI的实现类必须携带一个不带参数的构造方法；</li>
</ul>
<p>加载过程</p>
<ul>
<li>ServiceLoader 初始化</li>
<li>应用程序通过迭代器接口获取对象实例：首先判断是否有缓存实例对象,如果没有就通过反射加载对象并实例化,并把实例化对象缓存到provider,返回对象</li>
</ul>
<p>加载-&gt;验证-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载</p>
<p><a href="https://juejin.im/post/6844903633574690824" target="_blank" rel="noopener">JVM 类加载机制及双亲委派模型</a></p>
<h1 id="双亲委派模式">双亲委派模式</h1>
<p>类加载器</p>
<ul>
<li>启动（Bootstrap）类加载器：负责将 Java_Home/lib下面的类库加载到内存中（比如rt.jar）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作</li>
<li>标准扩展（Extension）类加载器：基于java是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将Java_Home /lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。</li>
<li>应用程序（Application）类加载器：基于java是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般称为系统（System）加载器。</li>
<li>自定义加载器<br>
该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，而这种父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）</li>
</ul>
<p>需要注意的是 对于任意一个类，都需要由加载它的类加载器和这个类本身共同确立其在Java虚拟机中的唯一性</p>
<p>双亲委派模型：</p>
<blockquote>
<p>某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。<br>
这样可以防止他人写的类替换掉系统的默认类</p>
</blockquote>
<p><a href="https://juejin.im/post/6844903806757502984" target="_blank" rel="noopener">java 循环依赖</a></p>
<p><a href="https://baijiahao.baidu.com/s?id=1667840029586081215" target="_blank" rel="noopener">内存屏障</a><br>
指令重排序</p>
<blockquote>
<p>对于单线程的指令,可能对指令重排序减少对于寄存器的反复读写操作,可以减少执行时间,而多线程下的指令重排序可能导致意外的错误,比如使用未初始化的变量</p>
</blockquote>
<p>内存一致性问题</p>
<blockquote>
<p>内存模型：对于多核CPU,每个核都使用高速缓存加快数据的读取(而不是每次都到主存存取),但是每个CPU的高速缓存必然是互相隔离的,可能出现共享变量副本不一致的情况<br>
一般有两种解决方案：</p>
</blockquote>
<ul>
<li>在总线上加锁的方式:在总线上发送busy信号,阻塞其他CPU对 与其他部件的访问 比如 内存,但是效率低下</li>
<li>缓存一致性协议：比如说inter的MESI 协议保证了每个缓存中使用的变量副本一致</li>
</ul>
<p>内存屏障分为两种</p>
<ul>
<li>load barrier：读屏障</li>
<li>Store barrier：写屏障</li>
</ul>
<p>内存屏障的作用</p>
<ul>
<li>阻止屏障两侧的指令重排序</li>
<li>写的时候,强制把缓冲区/高速缓存的数据写会内存,并让缓冲区的数据失效,读的时候需要从主存读取</li>
</ul>
<p>常见的内存屏障组合有4种</p>
<ul>
<li>LoadLoad屏障:保证屏障后的语句读取数据之前完成之前语句的读操作</li>
<li>StoreStore屏障：保证屏障后的写入操作执行之前,之前的写入操作的对其他处理器可见(获取最新结果)</li>
<li>LoadStore 屏障：保证屏障之后的写操作被执行完之前,之前读操作的结果必须完成</li>
<li>StoreLoad 屏障：保证之后的读操作执行之前,屏障之前的写操作的结果对其他处理器可见<br>
其中StoreLoad是核心 ,因为只有先写后读的操作顺序颠倒才会导致比较严重的后果</li>
</ul>
<p>volatile 与 内存屏障</p>
<ul>
<li>在每个volatile写操作之前插入StoreStore屏障,在其之后 插入StoreLoad屏障</li>
<li>在每个volatile读操作之前插入LoadLoad屏障,在其之后插入LoadStore屏障<br>
从而禁止了指令的重排序和内存的可见性</li>
</ul>
<p>提前担保机制</p>
<p>static synchronize VS synchronize</p>
<p>ZGC</p>
<p><a href="https://www.pianshen.com/article/38291243907/" target="_blank" rel="noopener">JVM里的记忆集合</a><br>
GC两个关键难点</p>
<ul>
<li>跨代引用：分带收集将对象分为老年代和年轻代,年轻代朝生夕死,YGC频繁发生,但是可能存在老年代引用新生代导致错误清除新生代对象</li>
<li>并发标记：stop-word方式的标记对系统影响大,且没有利用多核资源,故而采用并发标记,但是并发标记过程中存在对象的变化没有被感知的风险</li>
</ul>
<p>为了解决跨代引用,最简单的方法就是遍历所有的老年代对象,但是实际上只有少部分老年代对象对于年轻代对象有引用,这样效率很低：从而引入了&quot;记忆集&quot;的思想<br>
记忆集：记录非GC收集区域指向收集区域的抽象数据结构,具体而言就是记录内存空间是否存在记老年代对于新生代的引用状况,根据记录精度分为3种</p>
<ul>
<li>字长精度：每个记录精确到一个机器字长,该字中包含跨代指针</li>
<li>对象精度：每个记录精确到一个对象,该对象包含跨代指针字段</li>
<li>卡精度：每个记录精确到一块内存区域,该区域中包含跨代指针<br>
CMS 和 G1 中使用的是cardTable基于卡精度;卡表是个字节数组，每个字节对应堆空间老生代中的512个字节（这512个字节叫做卡页）是否有跨代引用</li>
</ul>
<p><a href="https://blog.csdn.net/MACRosshaha/article/details/108433196" target="_blank" rel="noopener">GC</a><br>
并发标记的可达性分析:<br>
三色标记：</p>
<ul>
<li>白色：尚未被垃圾收集器访问</li>
<li>黑色：已被访问,且该对象的所有引用已被扫描</li>
<li>灰色：已被访问,且至少存在一个对象未被扫描</li>
</ul>
<p>并发标记可能出现浮动垃圾和对象消失问题</p>
<blockquote>
<p>浮动垃圾:黑色对象的引用白色对象不再应用<br>
对象消失：新增白色对象被黑色对象引用,但没有拉入统计而被回收<br>
浮动垃圾的问题并不严重,数量不大而且可以下次回收;而对象消失可能干扰 系统的运行导致严重后果</p>
</blockquote>
<p>对象消失必然有两个前提：</p>
<ul>
<li>增加了黑色对象到该白色对象的引用</li>
<li>删除后了所有灰色对象对于到该白色对象的直接或者间接引用<br>
解决方法：</li>
<li>增量更新：记录新增的黑色对白色的引用,并发结束后,重新扫描</li>
<li>原始快照：在开始GC之前,对对对象之间的关系快照,涉及删除灰色到白色引用时备份引用,后面再扫描确认(此间产生的对象默认存活)<br>
两种方法 都通过写屏障 来实现记录的操作(并非内存屏障)<br>
<a href="https://cloud.tencent.com/developer/article/1599225" target="_blank" rel="noopener">G1回收器：我怎么知道你是什么时候的垃圾 垃圾回收详细过程</a></li>
</ul>
<p>高并发下 写屏障可能导致虚共享问题<br>
<a href="https://www.cnblogs.com/cyfonly/p/5800758.html" target="_blank" rel="noopener">false sharing</a> 并发杀手<br>
CPU 和 3级cache<br>
其中速度 L1&gt;L2&gt;L3; 空间L3&gt;L2&gt;L1<br>
每个cpu核有自己的L1 L2缓存,共享L3级缓存<br>
缓存中以缓存行(cache Line)作为单位存储,通常是64字节,一次性读取连续的64字节的数据,他有效隐射内存的一块地址<br>
当多线程所私有的变量处于同一个cache行时,会出现多线程轮番争用拥有权,并发变串行,同时该cache行的更改会将其他核高级cache行设置为失效,强制要求读取内存,即伪共享(可以通过<a href="http://ifeve.com/disruptor-cacheline-padding/" target="_blank" rel="noopener">缓存行填充</a>,使得自己的变量成为占满缓存行)<br>
而在G1通过配置要求判断是否已经为脏位,是脏位就无须再写,同时java中支持配置注解填充缓存行</p>
<p>java  泛型和 重写 继承的关系和缺陷<br>
<a href="https://www.cnblogs.com/wuqinglong/p/9456193.html" target="_blank" rel="noopener">Java泛型类型擦除以及类型擦除带来的问题</a><br>
<a href="http://blog.sina.com.cn/s/blog_7ffb8dd501012ku9.html" target="_blank" rel="noopener">泛型与类型擦除</a></p>
<blockquote>
<p>在代码阶段的重载检查和在JVM 阶段的检查<br>
如何实现泛型的多态</p>
</blockquote>
<p>Java 基础，集合类有哪些，全部说一遍</p>
<blockquote>
<p>四大类吧，分别是List、Queue、Set、Map</p>
</blockquote>
<ul>
<li>List：常见的有 ArrayList、LinkedList、Vector、CopyOnWriteArrayList</li>
<li>Queue：常见的有 ArrayDeque、PriorityQueue、ArrayBlockingQueue、LinkedBlockingQueue、DelayBlockingQueue等等</li>
<li>Map：HashMap、LinkedHashMap、TreeMap、ConcurrentHashMap等等</li>
<li>Set：HashSet、LinkedHashSet、TreeSet等</li>
</ul>
<p>JAVA的final字段</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="夸父"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">夸父</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">107</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">59</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/walkdeadtobe" title="GitHub → https://github.com/walkdeadtobe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">京ICP备2020045262号 </a>
      <img src="/images/gongan.png" style="display: inline-block;"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010802033764" rel="noopener" target="_blank">京公网安备 11010802033764 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chengr</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
