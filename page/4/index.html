<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">

<link rel="canonical" href="http://yoursite.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/30/工作求职/Java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/30/工作求职/Java/" class="post-title-link" itemprop="url">java 语言学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-30 15:42:16" itemprop="dateCreated datePublished" datetime="2020-06-30T15:42:16+08:00">2020-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-15 15:37:28" itemprop="dateModified" datetime="2020-10-15T15:37:28+08:00">2020-10-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="多线程">多线程</h1>
<h2 id="线程创建方法">线程创建方法</h2>
<blockquote>
<p>1.继承Thread类，重写run()线程执行程序，创建线程<br>
2.实现Runnable接口，重写run()方法，作为参数构造thread，创建线程<br>
3.使用Callable和Future创建线程<br>
4.使用线程池例如用Executor框架</p>
</blockquote>
<ul>
<li>Executor 的参数</li>
</ul>
<blockquote>
<p>实现Runnable接口比继承Thread类所具有的优势：<br>
1)可以避免java中的单继承的限制；可以继承多个接口<br>
2)Thread 实现了Runnable 接口, 提供了更多的可用方法和成员而已</p>
</blockquote>
<h2 id="多线程">多线程</h2>
<p>synchronize作为多线程关键字，是一种同步锁，它可以修饰以下几种对象：</p>
<ul>
<li>代码块：被修饰的代码块称为同步语句块，其作用的范围是大括号{ }里的代码，作用的对象是调用这个代码块的对象；</li>
<li>方法：被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象</li>
<li>静态方法：作用的范围是整个静态方法，作用的对象是这个类的所有对象</li>
<li>类：作用的范围是synchronize后面括号里的部分，作用的对象是这个类的所有对象</li>
</ul>
<p>锁：线程争夺对于锁，获取锁，然后运行代码</p>
<ul>
<li>对象锁 this 对象,其他对象</li>
<li>类锁</li>
</ul>
<blockquote>
<p>线程开始<br>
线程停止：正常执行完run；interrupt使得线程异常，执行完run<br>
其他：</p>
<blockquote>
<p>设置线程优先级(特性：继承性(线程A启动线程B，B继承A的优先级) ; 随机性(线程的调度顺序不一定根据优先级,具有随机性))<br>
yield方法，释放CPU资源，通常它会让当前运行线程回到可运行性状态，使得有相同优先级的线程有机会执行。<br>
sleep方法，使当前线程睡眠至少时间<br>
join()方法：保证当前线程停止执行，直到该线程所加入的线程完成为止。然而，如果它加入的线程没有存活，则当前线程不需要停止（基于wait方法和notify方法）</p>
</blockquote>
</blockquote>
<h1 id="gc">GC</h1>
<h2 id="背景">背景</h2>
<blockquote>
<p>内存空间是有限的，如果高效利用有限的空间，可以通过释放不适用的对象所占用的内存(Java虚拟机所管理的内存区域分为如下部分：方法区、堆内存、虚拟机栈、本地方法栈、PC寄存器)</p>
</blockquote>
<h2 id="gc对象">GC对象</h2>
<blockquote>
<p>程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理；内存垃圾回收主要集中于 java 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的</p>
</blockquote>
<h3 id="判定方法">判定方法</h3>
<blockquote>
<p>如何判断对象不再存活：引用计数（每个对象有一个引用计数属性，计数为0时可以回收，但无法解决对象相互循环引用的问题）和可达分析（通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连，则证明此对象是不可用的）</p>
</blockquote>
<h3 id="触发gc的条件">触发GC的条件</h3>
<blockquote>
<p>1.程序主动调用System.gc<br>
2.内存不足被动触发(年轻代升级空间不够,或者永久代空间不足)</p>
</blockquote>
<h2 id="gc-roots">GC ROOTS</h2>
<blockquote>
<p>虚拟机栈、方法区和本地方法栈；方法区中类静态属性引用的对象；常量<br>
1.系统类加载器锁加载的类<br>
2.阻塞线程以及运行线程涉及的对象；本地方法栈涉及的对象<br>
3.全局对象，上锁对象<br>
4.针对younggc来说，gcroot的对象包括所有年老带对象</p>
</blockquote>
<h2 id="为对象分配内存的方法">为对象分配内存的方法</h2>
<ul>
<li>规整内存/指针碰撞:将内存分为已使用和未使用的两部分,使用指针将两者隔开,然后指针右移需要的空间即可(建立在压缩空闲空间的基础上,耗时)</li>
<li>空闲列表法:把空间的空间的大小范围列表排序,然后选择(有首次适应,循环适应,最有适应,最坏适应)</li>
</ul>
<p>卡表(cardTable)</p>
<blockquote>
<p>JVM 把每512字节表示为一个卡页,<br>
为了提高重新标记的效率，并发标记阶段会把这些发生变化的对象所在的Card标识为Dirty，这样后续阶段就只需要扫描这些Dirty Card的对象，从而避免扫描整个老年代</p>
</blockquote>
<h2 id="gc常用算法">GC常用算法</h2>
<blockquote>
<p>1.标记-清除算法：标记对象的存活或者死亡;清除对象会导致大量碎片<br>
2.复制算法：内存分为两部分，只使用其中一部分，这部分内存用完后，将其中存活的对象移动至另一部分，其他删除；没有碎片，但内存利用率低<br>
3.标记-压缩算法：在上种算法的基础上，将存活的对象整理到一起；如果存活对象过多会导致，复制次数过多，效率下降<br>
4.分代收集算法（JVM Hotspot在使用）：根据对象的生存周期，将堆分为新生代(Young)和老年代(Tenure)。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。</p>
</blockquote>
<h3 id="cms">CMS</h3>
<blockquote>
<p>基于标记-清除算法<br>
堆被划分为新生代和老年代，新生代又被进一步划分为Eden和Survivor区，而Survivor由FromSpace和ToSpace组成。<br>
<br>新生代：新创建的对象都是用新生代分配内存，Eden空间不足时，触发Minor GC，这时会把存活的对象转移进Survivor区。<br>
<br>老年代：老年代用于存放经过多次Minor GC之后依然存活的对象，老年代内存不足时触发，Major GC</p>
</blockquote>
<h3 id="zgc">ZGC</h3>
<blockquote>
<p>todo</p>
</blockquote>
<h3 id="cms-vs-g1"><a href="https://www.cnblogs.com/heyonggang/p/11718170.html" target="_blank" rel="noopener">CMS VS G1</a></h3>
<blockquote>
<p>CMS：Concurrent Mark Sweep，基于标记-清楚算法，作用于老年代，以并发获取最短回收停顿时间为目标的</p>
<blockquote>
<p>初始标记（标记root直接关联的对象）、并发标记（root  trace）、重新标记（并发标记中涉及的对象）、并发清除（CMS concurrent sweep）<br>
优点：并发收集、低停顿<br>
缺点：</p>
<blockquote>
<p>CMS收集器对CPU资源非常敏感，频繁GC，CPU资源不足。<br>
CMS收集器无法处理浮动垃圾（Floating Garbage），并发清除阶段，运行产生的垃圾无法在本次回收。<br>
CMS收集器是基于标记-清除算法，导致碎片。<br>
安全点：程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停，安全点的初始目的是找到一个稳定的执行状态。在这个执行状态下，Java虚拟机的堆栈不会发生变化；长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等<br></p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<p>G1：Garbadge First Collector；基于标记-整理算法；G1重新定义了堆空间，将堆划分为一个个区域；来进行垃圾回收，不必在全堆范围内收集，可以预测停顿时间</p>
<blockquote>
<p>与CMS的步骤类似，只是第4步时，他根据region排序价值和预测时间去清除，最后然后拷贝存活对象至新的region<br>
卡表：？？？与老年代引用年轻代<br>
相对于CMS优势：可预测的停顿模型；避免了CMS的垃圾碎片；超大堆的表现更出色</p>
</blockquote>
</blockquote>
<h1 id="设计模式">设计模式</h1>
<h2 id="单例模式">单例模式</h2>
<blockquote>
<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象</p>
</blockquote>
<blockquote>
<blockquote>
<ol>
<li>懒汉模式：实例在使用到的时候才创建,当多线程并发调用 getInstance(),如果方法不加synchronize 关键字修饰,会导致线程不安全</li>
</ol>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class LHan &#123;</span><br><span class="line">    private static LHan instance;</span><br><span class="line">    private LHan()&#123;&#125;</span><br><span class="line">    public static LHan getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            instance = new LHan();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<ol start="2">
<li>饿汉模式,实例在最初已经初始化,getInstance()方法线程安全，但浪费内存空间</li>
</ol>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class EHan &#123;</span><br><span class="line">    private static EHan instance = new EHan();</span><br><span class="line">    private EHan()&#123;&#125;</span><br><span class="line">    public static EHan getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<ol start="3">
<li>双检锁,双重校验锁,在synchronize 关键字内外都加上一层if判断,即避免内存浪费,又保证了线程安全,同时 比直接上锁提高了执行效率</li>
</ol>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class DoubleCheck &#123;</span><br><span class="line">    private static DoubleCheck instance;</span><br><span class="line">    private DoubleCheck()&#123;&#125;</span><br><span class="line">    public static DoubleCheck getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            synchronize(DoubleCheck.class)&#123;</span><br><span class="line">                if(instance == null)&#123;</span><br><span class="line">                    instance = new DoubleCheck();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<ol start="4">
<li>静态内部类(内部类是外部类的一个成员,分为静态内部类和非静态内部类：静态内部类可以直接调用外部类的静态成员(静态成员变量和静态方法)，但是不能直接调用外部类的非静态成员；而非静态内部类可以直接调用外部类的其他成员)</li>
</ol>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class SingleTon &#123;</span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static final SingleTon INSTANCE = new SingleTon();</span><br><span class="line">    &#125;</span><br><span class="line">    private SingleTon()&#123;&#125;</span><br><span class="line">    public static final SingleTon getInstance()&#123;</span><br><span class="line">        return SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<ol start="5">
<li>枚举</li>
</ol>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum SingleTonn &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public void AnyMethod()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id></h1>
<h1 id="其他常见问题">其他常见问题</h1>
<h2 id="hashmap-hashtable-concurrenthashmap">HashMap HashTable ConcurrentHashMap</h2>
<blockquote>
<p>都是 数组+单链表 实现<br>
<a href="https://blog.csdn.net/mbshqqb/article/details/79799009" target="_blank" rel="noopener">参考1</a><br>
HashMap基于hashing原理，我们通过put()和get()法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用LinkedList来解决碰撞问题，当发生碰撞了，对象将会储存在LinkedList的下一个节点中。 HashMap在每个LinkedList节点中储存键值对对象。<br>
　　当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的LinkedList（链表只让挂7个元素，超过七个就会转成一个红黑树进行处理，当红黑树下挂的节点小于等于6的时候，系统会把红黑树转成链表）中。键对象的equals()方法用来找到键值对<br>
String, Interger这样的类，作为HashMap的键是再适合不过了，因为String对象是不可变的，计算hashCode()，就要防止键值改变</p>
</blockquote>
<blockquote>
<p>HashTable：无论key还是value都不能为null，线程安全，实现线程安全的方式是在修改数据时锁住整个HashTable；<br>
HashMap：无论key还是value都能为null，线程不安全（在多个线程并发扩容时，会在执行transfer()方法转移键值对时，造成链表成环，导致程序在执行get操作时形成死循环 <a href="https://www.cnblogs.com/lonelyJay/p/9726187.html" target="_blank" rel="noopener">参考1</a> <a href="https://www.sohu.com/a/341902281_100123073" target="_blank" rel="noopener">参考2</a> ;单链表复制是是插入排序，因为时刻知道链表头在哪）</p>
</blockquote>
<blockquote>
<p>但是 HashMap线程不安全，而HashTable安全但是效率低，出现了ConcurrentHashMap使用分段锁<br>
cocurrent 将hashmap的数据分为若干个子数组,每个子数组包装为segment对其加锁;<br>
抛开 HashMap，hash 冲突有那些解决办法？开放定址法、链地址法、再哈希法<br>
<a href="https://www.cnblogs.com/cosmos-wong/p/11845934.html" target="_blank" rel="noopener">java stack不推荐使用</a>,建议使用dequeue代替</p>
</blockquote>
<p>HashMap 扩容时机</p>
<ul>
<li>hashmap首次插入元素时会resize初始化table</li>
<li>hashmap中元素总数量达到阈值threshold(阈值初始化时等于)</li>
<li>如果某个链表的长度&gt;=8-1,则转化为红黑树(小于等于6时转换回来);在转化时,首先判断数组长度是否小于64那么就扩容,否则才转化</li>
</ul>
<h2 id="linkedhashmap-treemap">LinkedHashMap TreeMap</h2>
<blockquote>
<p>LinkedHashMap保存了记录的插入顺序,在用Iterator遍历LinkedHashMap时,先得到的记录肯定是先插入的,也可以在构造时用带参数,按照应用次数排序.<br>
在遍历的时候会比HashMap慢,不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关<br>
TreeMap实现SortMap接口,能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。插入查询的效率都是O(logN)</p>
</blockquote>
<h2 id="arraylist-vs-linkedlist">Arraylist VS LinkedList</h2>
<blockquote>
<p>LinkedList与ArrayList一样实现List接口，只是ArrayList是List接口的大小可变数组的实现，LinkedList是List接口链表的实现。基于链表实现的方式使得LinkedList在插入和删除时更优于ArrayList，而随机访问则比ArrayList逊色些。<br>
LinkedList实现所有可选的列表操作，并允许所有的元素包括null。<br>
除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。<br>
此类实现 Deque 接口，为 add、poll 提供先进先出队列操作，以及其他堆栈和双端队列操作</p>
</blockquote>
<h2 id="volatile和synchronized特点">volatile和synchronized特点：</h2>
<blockquote>
<p>执行控制（执行顺序，并发）和内存可见（读写经过内存）<br>
volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别(class对象的锁)的<br>
volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞<br>
volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</p>
</blockquote>
<h2 id="java两种数据类型">Java两种数据类型</h2>
<blockquote>
<p>分为基本数据类型（boolean、byte、int、char、long、short、double、float）和引用数据类型（数组、类、接口）<br>
Java为每 一个基本数据类型都引入了对应的包装类型（Boolean，Character，Byte，Short，Integer，Long，Float，Double），可以使用自动装箱/拆箱进行替换（装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型）<br>
例如：int与Integer的基本使用对比</p>
<ul>
<li>Integer是int的包装类，Integer变量必须实例化后才能使用；Integer的默认值是null;int是基本数据类型，int变量不需要初始化，int的默认值是0。</li>
<li>在使用时，Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；</li>
</ul>
</blockquote>
<h2 id="设计模式">设计模式</h2>
<blockquote>
<p><a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/design-pattern-tutorial.html</a><br>
工厂模式:定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行<br>
优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p>
<p>控制反转（Inversion of Control，缩写为IoC）；依赖注入<br>
缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事<br>
使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。2、设计一个连接服务器的框架，需要三个协议，“POP3”、“IMAP”、“HTTP”。</p>
<p>单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br>
主要解决：一个全局使用的类频繁地使用，实现共享，锁,static<br>
优点：1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。2、避免对资源的多重占用（比如写文件操作）。<br>
缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<p>装饰器模式:动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活<br>
主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。<br>
优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能.<br>
缺点：多层装饰比较复杂。</p>
<p>组合模式：是用于把一组相似的对象当作一个单一的对象</p>
<p>外观模式：隐藏系统的复杂性，客户端请求的简化方法和对现有系统类方法的委托调用（列类似于自动化脚本的概念）。<br>
优点： 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。<br>
缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</p>
<p>代理模式：其他对象提供一种代理以控制对这个对象的访问<br>
主要解决：远程调用，RPC；直接调用带来的危险，添加控制，火车站<br>
静态代理：添加日志</p>
</blockquote>
<h2 id="堆栈">堆栈</h2>
<blockquote>
<p>都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。<br>
堆：一棵树的数组对象（大顶堆，小顶堆），一般程序员申请    ；栈：先入后出，有一半程序员申请 队列：先入先出</p>
</blockquote>
<h2 id="bean">bean</h2>
<blockquote>
<p><a href="https://www.awaimai.com/2596.html" target="_blank" rel="noopener">https://www.awaimai.com/2596.html</a><br>
bean是一个由Spring IoC容器实例化、组装和管理的对象。<br>
类的实例化、依赖的实例化、依赖的传入都交由 Spring Bean 容器控制而不是new</p>
</blockquote>
<h2 id="malloc-vs-new">malloc VS new</h2>
<h2 id="4种io模式">4种IO模式</h2>
<blockquote>
<ul>
<li>同步阻塞IO（Blocking IO）</li>
<li>同步非阻塞IO（Non-blocking IO）</li>
<li>IO多路复用（IO Multiplexing）</li>
<li>异步IO（Asynchronous IO）<br>
<a href="https://blog.csdn.net/qq_34802511/article/details/81543817" target="_blank" rel="noopener">https://blog.csdn.net/qq_34802511/article/details/81543817</a><br>
同步io操作导致请求进程阻塞，直到i/o操作完成；异步io操作不导致请求进程阻塞<br>
以read IO为例子，大致分为2步 1）等待数据准备(数据从磁盘拷贝到内核内存) 2）将数据从内核拷贝到进程中<br>
同步阻塞在两个阶段都会阻塞；而同步非阻塞IO只会在第二个阶段阻塞，进程在第一步受阻后，会返回，然后反复询问是否内核准备好数据；<br>
IO多路复用：在同步非阻塞的基础上，可以使用一个进程监视多个输入（select，poll，epoll）<br>
而异步IO中，两步都不会造成阻塞，知道数据已经复制到进程内存区，会通知进程</li>
</ul>
</blockquote>
<h2 id="nio">NIO</h2>
<blockquote></blockquote>
<p><a href="https://juejin.im/post/6844903729435508750" target="_blank" rel="noopener">Java ClassLoader 再不理解就老了</a></p>
<h2 id="类的加载">类的加载</h2>
<p>在类的加载之前需要首先基于javac命令将java源文件编译成class文件,然后在运行中加载.<br>
我们借助类加载器完成类的加载,类的加载共分为三个阶段:加载 链接(验证 准备 解析)  初始化</p>
<ul>
<li>加载：根据类的全限定名来找到相应的class文件,并加载到内存</li>
<li>链接
<ul>
<li>验证：验证class字节流文件中的信息符合虚拟机的要求,不会危害自身安全</li>
<li>准备：给类变量分配内存并初始化为默认值,初始化常量(final)</li>
<li>解析：将常量池(在编译期即被确定的一些常量)中符号引用转化为直接引用
<ul>
<li>举例：对于类而言就是将全限定名转化为该类在内存中的地址</li>
<li>对于类引用的解析,是在初始化之前加载还是在初始化之后使用前加载,可以由加载器自己决定实现</li>
</ul>
</li>
</ul>
</li>
<li>初始化：给类的静态变量赋给定的初始值,这些操作和静态代码块会统一放置在类构造器<clinit>方法中,该方法只会执行一次.</clinit></li>
<li>使用：在实例构造器<init>方法中包含了代码分别为 父类的初始化方法-普通常量的初始化赋值-普通代码块-构造函数
<ul>
<li>主动使用-触发初始化:new 创建类的实例;访问类的静态变量或类方法;反射;初始化子类导致初始化父类</li>
<li>被动使用- 不会触发初始化:主动使用的一些例外
<ul>
<li>子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化</li>
<li>通过数组定义来引用类，不会触发此类的初始化,例如MyObject[] b = new MyObject[10];</li>
<li>常量字段编译期不确定：UUID.random().toString()</li>
<li>父类接口：一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中运行期才确定的常量）才会初始化</li>
</ul>
</li>
</ul>
</init></li>
<li>卸载：当MySample类被加载，连接和初始化后，它的生命周期就开始了。当代表MySample类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，MySample类在方法区内的数据也会被卸载，从而结束MySample类的生命周期。一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期</li>
</ul>
<blockquote>
<p>由Java虚拟机自带的加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。Java虚拟机自带的类加器包括根类加载器，扩展类加载器和系统类加载器。Java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始引用它们所加载的类的Class对象，因此这Class对象终是可及的。由用户自定义的类加载器所加载的类是可以被卸载的。</p>
</blockquote>
<p>父子类的执行顺序</p>
<ul>
<li>父类<clinit> 子类 <clinit> 虚拟机会保证 子类初始化之前 父类已经初始化defineClass</clinit></clinit></li>
<li>父类<init> 子类<init></init></init></li>
<li><init>:父类<init>+普通成员变量赋值+代码块+构造函数</init></init></li>
</ul>
<h2 id="类加载的委派机制">类加载的委派机制</h2>
<p>通常情况下有4种类加载器:</p>
<ul>
<li>Bootstrap classLoader 特定目录下,JavaHome/lib</li>
<li>Extension classLoader 特定目录下,JavaHome/lib/ext</li>
<li>Application classLoader ClassHome 下 以及 外部依赖</li>
<li>自定义类加载器</li>
</ul>
<p>ClassLoader.defineClass</p>
<blockquote>
<p>将字节流转化为class对象</p>
</blockquote>
<p>ClassLoader.loadClass</p>
<ul>
<li>首先调用findLoadedClass:寻找是否已经加载过该类,如果有则返回</li>
<li>如果无,那么存在父类加载器,则尝试调用父类加载器的loadClass ,那么调用bootstrap 加载器</li>
<li>如果还是找不到,会调用findClass(默认抛出classNotfiound异常,被继承后需要重写逻辑;UrlClassLoader中会根据全限定类名找到路径去加载)</li>
</ul>
<p>如果想违背父类机制</p>
<blockquote>
<p>那么重写loadClass方法,首先调用findLoadedClass  然后直接调用findClass</p>
</blockquote>
<h3 id="相同类的加载">相同类的加载</h3>
<p>利用不同的自定义类加载器实例 实现加载,通过实现不同的findClass方法实现加载,由于JVM 中通过类加载器和全限定类名来确保一个类的唯一性,所以类名字一致但不会重合</p>
<h3 id="钻石依赖">钻石依赖</h3>
<p>项目管理上有一个著名的概念叫着「钻石依赖」，是指软件依赖导致同一个软件包的两个版本需要共存而不能冲突。<br>
MAVEN</p>
<blockquote>
<p>maven 是这样解决钻石依赖的，它会从多个冲突的版本中选择一个来使用，如果不同的版本之间兼容性很糟糕，那么程序将无法正常编译运行。Maven 这种形式叫「扁平化」依赖管理。</p>
</blockquote>
<p>JVM</p>
<blockquote>
<p>使用 ClassLoader 可以解决钻石依赖问题。不同版本的软件包使用不同的 ClassLoader 来加载，位于不同 ClassLoader 中名称一样的类实际上是不同的类。</p>
</blockquote>
<h3 id="threadcontextclassloader">Thread.contextClassLoader</h3>
<p>首先 contextClassLoader 是那种需要显示使用的类加载器，如果你没有显示使用它，也就永远不会在任何地方用到它<br>
其次线程的 contextClassLoader 默认是从父线程那里继承过来的，所谓父线程就是创建了当前线程的线程。程序启动时的 main 线程的 contextClassLoader 就是 AppClassLoader。这意味着如果没有人工去设置，那么所有的线程的 contextClassLoader 都是 AppClassLoader。</p>
<p>用处</p>
<blockquote>
<p>如果不同的线程使用不同的 contextClassLoader，那么不同的线程使用的类就可以隔离开来。<br>
如果我们对业务进行划分，不同的业务使用不同的线程池，线程池内部共享同一个 contextClassLoader，线程池之间使用不同的 contextClassLoader，就可以很好的起到隔离保护的作用，避免类版本冲突。</p>
</blockquote>
<h3 id="类的运行时寻找机制">类的运行时寻找机制</h3>
<ul>
<li>java.lang.File 编译器会自动导入java.lang包</li>
<li>其他import 的包<br>
如果出现多个同名的类,编译器会报错</li>
</ul>
<h3 id="classloader-的传递性">classLoader 的传递性</h3>
<p>当程序在运行中遇到一个未知的类时,虚拟机会使用调用者的class对象的classLoader(class有该字段记录加载器)来加载当前类,通常情况下为系统加载器即AppClassLoader</p>
<h2 id="final-vs-static-vs-finally">final vs static vs finally</h2>
<blockquote>
<p>final 标识常量，创建或者初始化后不可更改，可以修饰 属性，方法（不可被重写），类（不可被继承），局部变量<br>
static 标识唯一性，可以修饰 变量，方法（与类的具体实例），代码段 （仅仅在类被初次加载的时候被调用一次，之后再调用不会再加载；如有父类先进行父类的初始化），不可修饰局部变量<br>
finally 是异常处理里的内容，try catch finally<br>
static final=final static：修饰的属性表示一旦给值，就不可修改，并且可以通过类名访问，也可以修饰方法，表示该方法不能重写</p>
</blockquote>
<h2 id="throws和throw">throws和throw</h2>
<blockquote>
<p>throws出现在方法函数头，可以跟多个异常类名，用逗号隔开，表示出现异常的一种可能性，并不一定会发生这些异常，由调用方去处理，当然也可以不处理，当产生异常，系统会报；<br>
而throw出现在函数体，是抛出了异常，执行throw则一定抛出了某种异常对象。<br>
两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</p>
</blockquote>
<h1 id="异常体系throwable">异常体系(throwable)</h1>
<blockquote>
<p><a href="https://blog.csdn.net/junlixxu/article/details/6096266" target="_blank" rel="noopener">java异常体系</a><br>
Java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类<br>
在Java API中已经定义了许多异常类，这些异常类分为两大类，错误Error和异常Exception</p>
</blockquote>
<h2 id="error">error</h2>
<blockquote>
<p>程序无法处理的错误,多与内存线程相关，比如OutOfMemoryErrorThreadDeath等。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</p>
</blockquote>
<h2 id="exception">Exception</h2>
<blockquote>
<p>Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常</p>
</blockquote>
<h3 id="运行时异常非受检异常">运行时异常(非受检异常)</h3>
<blockquote>
<p>个人理解 运行时才可能出现的异常,比如NullPointerException，IndexOutOfBoundsException，IllegalArgumentException,RuntimeException,InputMismatchException等,可以不处理，系统会统一处理，打出日志</p>
</blockquote>
<h3 id="非运行时异常受检异常checkexception">非运行时异常(受检异常:checkException)</h3>
<blockquote>
<p>系统在预编译检查时发现的错误,必须在编译前解决，否则无法编译成功，比如IOException、SQLException等以及用户自定义的Exception<br>
通过throws 要求调用者必须处理或者向上排除</p>
</blockquote>
<h2 id="异常处理">异常处理</h2>
<ul>
<li>try catch finally</li>
<li>throws 可能的Exception 有调用者处理</li>
<li>异常链的处理,避免异常覆盖：Throwable 里面有 cause同类型字段,可以保存构造异常时传递的根异常参数,实现异常链条</li>
</ul>
<h1 id="出现异常的处理方法">出现异常的处理方法</h1>
<p>top<br>
ps -ef<br>
gc<br>
iostat  查TCP 连接</p>
<h1 id="java-多线程-java多线程面试题">Java 多线程 <a href="https://blog.csdn.net/qq_36387471/article/details/105479238" target="_blank" rel="noopener">Java多线程面试题</a></h1>
<h1 id="java-spi机制是什么">Java SPI机制是什么？</h1>
<blockquote>
<p>SPI(service Provider  interface)是一种服务发现机制，提供服务接口，且为该接口寻找服务的实现<br>
约定：</p>
</blockquote>
<ul>
<li>当服务提供者提供了接口的一种具体实现后，在jar包的META-INF/services目录下创建一个以“接口全限定名”为命名的文件，内容为实现类的全限定名；</li>
<li>接口实现类所在的jar包放在主程序的classpath中；</li>
<li>主程序通过java.util.ServiceLoder动态装载实现模块，它通过扫描META-INF/services目录下的配置文件找到实现类的全限定名，把类加载到JVM；</li>
<li>SPI的实现类必须携带一个不带参数的构造方法；</li>
</ul>
<p>加载过程</p>
<ul>
<li>ServiceLoader 初始化</li>
<li>应用程序通过迭代器接口获取对象实例：首先判断是否有缓存实例对象,如果没有就通过反射加载对象并实例化,并把实例化对象缓存到provider,返回对象</li>
</ul>
<p>加载-&gt;验证-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载</p>
<p><a href="https://juejin.im/post/6844903633574690824" target="_blank" rel="noopener">JVM 类加载机制及双亲委派模型</a></p>
<h1 id="双亲委派模式">双亲委派模式</h1>
<p>类加载器</p>
<ul>
<li>启动（Bootstrap）类加载器：负责将 Java_Home/lib下面的类库加载到内存中（比如rt.jar）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作</li>
<li>标准扩展（Extension）类加载器：基于java是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将Java_Home /lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。</li>
<li>应用程序（Application）类加载器：基于java是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般称为系统（System）加载器。</li>
<li>自定义加载器<br>
该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，而这种父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）</li>
</ul>
<p>需要注意的是 对于任意一个类，都需要由加载它的类加载器和这个类本身共同确立其在Java虚拟机中的唯一性</p>
<p>双亲委派模型：</p>
<blockquote>
<p>某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。<br>
这样可以防止他人写的类替换掉系统的默认类</p>
</blockquote>
<p><a href="https://juejin.im/post/6844903806757502984" target="_blank" rel="noopener">java 循环依赖</a></p>
<p><a href="https://baijiahao.baidu.com/s?id=1667840029586081215" target="_blank" rel="noopener">内存屏障</a><br>
指令重排序</p>
<blockquote>
<p>对于单线程的指令,可能对指令重排序减少对于寄存器的反复读写操作,可以减少执行时间,而多线程下的指令重排序可能导致意外的错误,比如使用未初始化的变量</p>
</blockquote>
<p>内存一致性问题</p>
<blockquote>
<p>内存模型：对于多核CPU,每个核都使用高速缓存加快数据的读取(而不是每次都到主存存取),但是每个CPU的高速缓存必然是互相隔离的,可能出现共享变量副本不一致的情况<br>
一般有两种解决方案：</p>
</blockquote>
<ul>
<li>在总线上加锁的方式:在总线上发送busy信号,阻塞其他CPU对 与其他部件的访问 比如 内存,但是效率低下</li>
<li>缓存一致性协议：比如说inter的MESI 协议保证了每个缓存中使用的变量副本一致</li>
</ul>
<p>内存屏障分为两种</p>
<ul>
<li>load barrier：读屏障</li>
<li>Store barrier：写屏障</li>
</ul>
<p>内存屏障的作用</p>
<ul>
<li>阻止屏障两侧的指令重排序</li>
<li>写的时候,强制把缓冲区/高速缓存的数据写会内存,并让缓冲区的数据失效,读的时候需要从主存读取</li>
</ul>
<p>常见的内存屏障组合有4种</p>
<ul>
<li>LoadLoad屏障:保证屏障后的语句读取数据之前完成之前语句的读操作</li>
<li>StoreStore屏障：保证屏障后的写入操作执行之前,之前的写入操作的对其他处理器可见(获取最新结果)</li>
<li>LoadStore 屏障：保证屏障之后的写操作被执行完之前,之前读操作的结果必须完成</li>
<li>StoreLoad 屏障：保证之后的读操作执行之前,屏障之前的写操作的结果对其他处理器可见<br>
其中StoreLoad是核心 ,因为只有先写后读的操作顺序颠倒才会导致比较严重的后果</li>
</ul>
<p>volatile 与 内存屏障</p>
<ul>
<li>在每个volatile写操作之前插入StoreStore屏障,在其之后 插入StoreLoad屏障</li>
<li>在每个volatile读操作之前插入LoadLoad屏障,在其之后插入LoadStore屏障<br>
从而禁止了指令的重排序和内存的可见性</li>
</ul>
<p>提前担保机制</p>
<p>static synchronize VS synchronize</p>
<p>ZGC</p>
<p><a href="https://www.pianshen.com/article/38291243907/" target="_blank" rel="noopener">JVM里的记忆集合</a><br>
GC两个关键难点</p>
<ul>
<li>跨代引用：分带收集将对象分为老年代和年轻代,年轻代朝生夕死,YGC频繁发生,但是可能存在老年代引用新生代导致错误清除新生代对象</li>
<li>并发标记：stop-word方式的标记对系统影响大,且没有利用多核资源,故而采用并发标记,但是并发标记过程中存在对象的变化没有被感知的风险</li>
</ul>
<p>为了解决跨代引用,最简单的方法就是遍历所有的老年代对象,但是实际上只有少部分老年代对象对于年轻代对象有引用,这样效率很低：从而引入了&quot;记忆集&quot;的思想<br>
记忆集：记录非GC收集区域指向收集区域的抽象数据结构,具体而言就是记录内存空间是否存在记老年代对于新生代的引用状况,根据记录精度分为3种</p>
<ul>
<li>字长精度：每个记录精确到一个机器字长,该字中包含跨代指针</li>
<li>对象精度：每个记录精确到一个对象,该对象包含跨代指针字段</li>
<li>卡精度：每个记录精确到一块内存区域,该区域中包含跨代指针<br>
CMS 和 G1 中使用的是cardTable基于卡精度;卡表是个字节数组，每个字节对应堆空间老生代中的512个字节（这512个字节叫做卡页）是否有跨代引用</li>
</ul>
<p><a href="https://blog.csdn.net/MACRosshaha/article/details/108433196" target="_blank" rel="noopener">GC</a><br>
并发标记的可达性分析:<br>
三色标记：</p>
<ul>
<li>白色：尚未被垃圾收集器访问</li>
<li>黑色：已被访问,且该对象的所有引用已被扫描</li>
<li>灰色：已被访问,且至少存在一个对象未被扫描</li>
</ul>
<p>并发标记可能出现浮动垃圾和对象消失问题</p>
<blockquote>
<p>浮动垃圾:黑色对象的引用白色对象不再应用<br>
对象消失：新增白色对象被黑色对象引用,但没有拉入统计而被回收<br>
浮动垃圾的问题并不严重,数量不大而且可以下次回收;而对象消失可能干扰 系统的运行导致严重后果</p>
</blockquote>
<p>对象消失必然有两个前提：</p>
<ul>
<li>增加了黑色对象到该白色对象的引用</li>
<li>删除后了所有灰色对象对于到该白色对象的直接或者间接引用<br>
解决方法：</li>
<li>增量更新：记录新增的黑色对白色的引用,并发结束后,重新扫描</li>
<li>原始快照：在开始GC之前,对对对象之间的关系快照,涉及删除灰色到白色引用时备份引用,后面再扫描确认(此间产生的对象默认存活)<br>
两种方法 都通过写屏障 来实现记录的操作(并非内存屏障)<br>
<a href="https://cloud.tencent.com/developer/article/1599225" target="_blank" rel="noopener">G1回收器：我怎么知道你是什么时候的垃圾 垃圾回收详细过程</a></li>
</ul>
<p>高并发下 写屏障可能导致虚共享问题<br>
<a href="https://www.cnblogs.com/cyfonly/p/5800758.html" target="_blank" rel="noopener">false sharing</a> 并发杀手<br>
CPU 和 3级cache<br>
其中速度 L1&gt;L2&gt;L3; 空间L3&gt;L2&gt;L1<br>
每个cpu核有自己的L1 L2缓存,共享L3级缓存<br>
缓存中以缓存行(cache Line)作为单位存储,通常是64字节,一次性读取连续的64字节的数据,他有效隐射内存的一块地址<br>
当多线程所私有的变量处于同一个cache行时,会出现多线程轮番争用拥有权,并发变串行,同时该cache行的更改会将其他核高级cache行设置为失效,强制要求读取内存,即伪共享(可以通过<a href="http://ifeve.com/disruptor-cacheline-padding/" target="_blank" rel="noopener">缓存行填充</a>,使得自己的变量成为占满缓存行)<br>
而在G1通过配置要求判断是否已经为脏位,是脏位就无须再写,同时java中支持配置注解填充缓存行</p>
<p>java  泛型和 重写 继承的关系和缺陷<br>
<a href="https://www.cnblogs.com/wuqinglong/p/9456193.html" target="_blank" rel="noopener">Java泛型类型擦除以及类型擦除带来的问题</a><br>
<a href="http://blog.sina.com.cn/s/blog_7ffb8dd501012ku9.html" target="_blank" rel="noopener">泛型与类型擦除</a></p>
<blockquote>
<p>在代码阶段的重载检查和在JVM 阶段的检查<br>
如何实现泛型的多态</p>
</blockquote>
<p>Java 基础，集合类有哪些，全部说一遍</p>
<blockquote>
<p>四大类吧，分别是List、Queue、Set、Map</p>
</blockquote>
<ul>
<li>List：常见的有 ArrayList、LinkedList、Vector、CopyOnWriteArrayList</li>
<li>Queue：常见的有 ArrayDeque、PriorityQueue、ArrayBlockingQueue、LinkedBlockingQueue、DelayBlockingQueue等等</li>
<li>Map：HashMap、LinkedHashMap、TreeMap、ConcurrentHashMap等等</li>
<li>Set：HashSet、LinkedHashSet、TreeSet等</li>
</ul>
<p>JAVA的final字段</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/14/基础知识/论文阅读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/基础知识/论文阅读/" class="post-title-link" itemprop="url">论文阅读</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-14 19:12:45" itemprop="dateCreated datePublished" datetime="2020-06-14T19:12:45+08:00">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-30 13:25:24" itemprop="dateModified" datetime="2020-08-30T13:25:24+08:00">2020-08-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="大多是data-center-资源集中">大多是Data Center ,资源集中</h4>
<h4 id="cooperative-game-based-virtual-machine-resource-allocation-algorithms-in-cloud-data-centershindawi">Cooperative Game-Based Virtual Machine Resource Allocation Algorithms in Cloud Data Centers(hindawi)</h4>
<ol>
<li>Cloud Data Center(CDC)资源利用率低</li>
<li>思路：对不同资源使用不同的基于 value 的博弈论解决方法;
<ul>
<li>CPU: Shaply value(SV), payoff by number contribution</li>
<li>memory: weighted Shaply value(WSV),payoff by coliation ;and  members’s payoff about positive effort of coliation</li>
<li>storage: proportional Shaply value(PSV)</li>
<li>bandwith: weigthed-egalitarian Shaply value(WESV) payoff by member contribution and  heterogeneity between members</li>
</ul>
</li>
<li>不足：
<ul>
<li>task 生成分为四类,每类的资源要求固定(task 不具有 变动性)</li>
<li>数据未公开</li>
<li>未解释 四类资源某些不足时的处理???</li>
</ul>
</li>
</ol>
<h4 id="game-theoretic-resource-allocation-in-cloud-computing">Game theoretic resource allocation in cloud computing</h4>
<ol>
<li>介绍：同名书中的相干章节，基于Min-Max Game
<ul>
<li>输入：request的信息，resource的信息</li>
<li>输出：分配矩阵</li>
</ul>
</li>
<li>思路：实现最大化资源的 utility(效用) 的目标；</li>
<li>utility 的公式构成(又分为单类资源utility和全局资源utility) ?? 不同资源,CPU
<ul>
<li>budget</li>
<li>cost per sencod</li>
<li>request 量</li>
<li>request time 消耗时间</li>
<li>budget和time的factor因子</li>
</ul>
</li>
<li>算法：
<ul>
<li>挑选出可以进行博弈的request</li>
<li>依次对每一种资源选择全局最大化utility时的分配，iteration</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/11/工具/毕设/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/11/工具/毕设/" class="post-title-link" itemprop="url">毕设实验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-11 19:12:45" itemprop="dateCreated datePublished" datetime="2020-06-11T19:12:45+08:00">2020-06-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-30 13:26:47" itemprop="dateModified" datetime="2020-08-30T13:26:47+08:00">2020-08-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>##实验分类：</p>
<ol>
<li>小规模 系统搭建(请求链条不需要长)</li>
<li>大规模仿真模拟(可以模拟长请求链和大规模，大流量)</li>
</ol>
<p>###小规模系统构成：</p>
<ol>
<li>请求发送者(微服务的benchmark 附带流量)</li>
<li>微服务benchmark/请求处理
<ul>
<li>服务链确定</li>
<li>流量监控(istio)</li>
</ul>
</li>
<li>决策中心(初次放置,调整): 博弈论均衡
<ul>
<li>思路：
<ul>
<li>分类</li>
<li>加权 集中</li>
</ul>
</li>
<li>放置：资源充足时, 参数 服务链(整体时延) &gt; 资源使用集中程度(避免资源过度集中于某些machine,也避免过度分散)</li>
<li>缩容：谨慎，按照kubeneats自带策略/长期监控流量,然后决策调整</li>
<li>扩容：存在多服务链扩容,博弈论
<ul>
<li>资源不冲突，分配</li>
<li>资源冲突，考虑优先级, 其他参数 资源利用率,资源集中程度<br>
###大规模仿真模拟</li>
</ul>
</li>
</ul>
</li>
<li>工具：CloudSim(docker)</li>
<li>微服务的指标细化(QOS,基本资源需求,基本处理能力)</li>
<li>流量构造(常规多样流量；突发大规模流量)</li>
</ol>
<p>###目标：</p>
<ol>
<li>满足已存在的QOS 要求(根据流量调整实例的部署，扩缩容)</li>
<li>资源利用率</li>
<li>性能表现(latency,稳定性)</li>
</ol>
<p>###问题：</p>
<ol>
<li>利用博弈论简化问题，
<ul>
<li>只考虑了部署实例的问题，没有考虑具体资源的供给(如何量化的问题),</li>
<li>暂时没有考虑后续的伸缩</li>
<li>未考虑 资源不集中</li>
</ul>
</li>
<li>平衡不是目标，平衡是为了降低干扰，我的目标是提高QOS，稳定性，提高资源利用率，降低资源占有率</li>
<li>长请求链的实际存在依据(实际运行中的每个环节都是请求链的一环)：更多例子</li>
<li>微服务benchmark的自带流量测试比较简单/不够复杂和波动，需要重新构造设计</li>
</ol>
<p>已完成：</p>
<ol>
<li>benchmark:<br>
1.1 已部署 <a href="https://github.com/microservices-demo/microservices-demo" target="_blank" rel="noopener">Sock-Shop</a> <a href="https://github.com/GoogleCloudPlatform/microservices-demo" target="_blank" rel="noopener">Hipster</a> <a href="https://github.com/FudanSELab/train-ticket/wiki" target="_blank" rel="noopener">Train-Ticket</a> <a href="https://github.com/delimitrou/DeathStarBench" target="_blank" rel="noopener">DeahStarBench</a></li>
</ol>
<p>1.2 待部署 <a href="https://github.com/dream-lab/riot-bench" target="_blank" rel="noopener">Riot</a></p>
<ol start="2">
<li>决策中心<br>
2.1 熟悉了解 <a href="https://www.coursera.org/learn/game-theory-1/" target="_blank" rel="noopener">博弈论理论</a><br>
2.2 算法实现，需要想清楚问题</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/14/基础知识/源码阅读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/14/基础知识/源码阅读/" class="post-title-link" itemprop="url">源码阅读</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-14 21:16:59" itemprop="dateCreated datePublished" datetime="2020-04-14T21:16:59+08:00">2020-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-30 13:18:55" itemprop="dateModified" datetime="2020-08-30T13:18:55+08:00">2020-08-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>docker</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/zyDGaT6SGFUVU60r9L7S3Q?" target="_blank" rel="noopener">参考博客1</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/31/基础知识/云计算模拟/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/31/基础知识/云计算模拟/" class="post-title-link" itemprop="url">云计算模拟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-31 19:47:06" itemprop="dateCreated datePublished" datetime="2020-03-31T19:47:06+08:00">2020-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-30 13:18:55" itemprop="dateModified" datetime="2020-08-30T13:18:55+08:00">2020-08-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>毕业设计需要对于大型云计算环境进行模拟，经过调研，决定使用<a href="http://www.cloudbus.org/cloudsim/" target="_blank" rel="noopener">CloudSim</a> <a href="https://github.com/Cloudslab/cloudsim" target="_blank" rel="noopener">Github</a></p>
<p>CloudSim是在离散事件模拟包SimJava上开发的函数库,可以直接当做Java工程使用，即导入IDEA<br>
<a href="https://www.cnblogs.com/sddai/p/6036893.html" target="_blank" rel="noopener">国内比较全的关于CloudSim的介绍</a><br>
<a href="https://www.cnblogs.com/xxfna/articles/9563068.html" target="_blank" rel="noopener">如何将CloudSim导入IDEA</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/13/基础知识/linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/13/基础知识/linux/" class="post-title-link" itemprop="url">linux</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-13 10:57:57" itemprop="dateCreated datePublished" datetime="2020-01-13T10:57:57+08:00">2020-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-30 13:19:27" itemprop="dateModified" datetime="2020-08-30T13:19:27+08:00">2020-08-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本问用于记录linux常用的命令</p>
<p>ssh</p>
<p>scp</p>
<blockquote>
<p>在两个服务器之间传输文件<br>
rz<br>
传输本地文件到服务器<br>
sz [filename]<br>
传输服务器文件到本地</p>
</blockquote>
<p>find [PATH] [option]</p>
<blockquote>
<p>在指定目录下查找相关文件<br>
example : find . -name “name”</p>
</blockquote>
<p>tail [file] [option]</p>
<blockquote>
<p>从后开始查询文件，默认查询最后十行<br>
tail -n 100 nohup.log</p>
</blockquote>
<p>cat/touch<br>
netstat<br>
telnet<br>
chown/chmod/chgrp<br>
useradd</p>
<p>配置 <a href="https://wiki.archlinux.org/index.php/Readline" target="_blank" rel="noopener">命令自动补全</a></p>
<blockquote>
<p>配置 ~/.inputrc 文件</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/12/基础知识/shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/12/基础知识/shell/" class="post-title-link" itemprop="url">shell</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-12 23:13:41" itemprop="dateCreated datePublished" datetime="2020-01-12T23:13:41+08:00">2020-01-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-30 13:23:03" itemprop="dateModified" datetime="2020-08-30T13:23:03+08:00">2020-08-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>shell 是UNIX系统的用户与操作系统之间的一种接口;</p>
<p><a href="https://blog.csdn.net/Jiaach/article/details/83788984" target="_blank" rel="noopener">注意事项</a><br>
在 单引号 以及 反单引号 里使用 ${AVAILABLE}引用变量</p>
<p>PATH 变量 谨慎使用</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/12/基础知识/frp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/12/基础知识/frp/" class="post-title-link" itemprop="url">frp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-12 15:41:34" itemprop="dateCreated datePublished" datetime="2020-01-12T15:41:34+08:00">2020-01-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-30 13:24:59" itemprop="dateModified" datetime="2020-08-30T13:24:59+08:00">2020-08-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>云服务器　<a href="https://promotion.aliyun.com/ntms/act/campus2018.html" target="_blank" rel="noopener">阿里云ECS</a><br>
关于端口限制(connect timeout) <a href="https://blog.csdn.net/cao0507/article/details/82758288" target="_blank" rel="noopener">https://blog.csdn.net/cao0507/article/details/82758288</a></p>
<p>crontab</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">PROCESS_NUM=`ps -ef | grep &quot;frpc -c &quot; | grep -v &quot;grep&quot; | wc -l`</span><br><span class="line">FRP_PATH=&apos;/home/sun/fpr/frp_0.31.1_linux_amd64&apos;</span><br><span class="line">if [ $PROCESS_NUM -lt 1 ];</span><br><span class="line">then</span><br><span class="line">    `nohup $&#123;FRP_PATH&#125;/frpc -c $&#123;FRP_PATH&#125;/frpc.ini &gt; $&#123;FRP_PATH&#125;/nohup.out 2&gt;&amp;1 &amp;`</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/womenrendeme/article/details/89053746" target="_blank" rel="noopener">多客户端</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/基础知识/docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/基础知识/docker/" class="post-title-link" itemprop="url">docker</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-09 00:42:40" itemprop="dateCreated datePublished" datetime="2020-01-09T00:42:40+08:00">2020-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-30 13:25:00" itemprop="dateModified" datetime="2020-08-30T13:25:00+08:00">2020-08-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>##Install<br>
<a href="https://docs.docker.com/install/linux/linux-postinstall/" target="_blank" rel="noopener">官方教程</a></p>
<p>##Usage<br>
docker</p>
<blockquote>
<p>docker ps -a<br>
docker images<br>
dokcer stop/restart/rm CONTAINER_ID<br>
docker rmi IAMGE_ID<br>
docker logs CONTAINER_ID --tail NUMBER<br>
docker inspect</p>
</blockquote>
<p>dokcer java 应用启动慢　尝试解决</p>
<blockquote>
<p>1.非阻塞熵池策略 优化　<a href="http://hongjiang.info/tomcat-startup-slowly-in-docker/" target="_blank" rel="noopener">Docker中apache-tomcat启动慢的问题</a>　<a href="https://www.cnblogs.com/a1304908180/p/10745284.html" target="_blank" rel="noopener">为什么阿里云服务器的docker启动tomcat这么慢？</a> -Djava.security.egd=file:/dev/urandom　－＞　-Djava.security.egd=file:/dev/./urandom<br>
2.JVM 容量优化，即增加参数值 -Xms256m -Xmx512m -XX:PermSize=64m -XX:MaxPermSize=128m</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/基础知识/kubernets/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/基础知识/kubernets/" class="post-title-link" itemprop="url">kubernets</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-09 00:24:40" itemprop="dateCreated datePublished" datetime="2020-01-09T00:24:40+08:00">2020-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-30 13:19:28" itemprop="dateModified" datetime="2020-08-30T13:19:28+08:00">2020-08-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="install">Install</h2>
<p>我安装的是 minikube <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl-on-linux" target="_blank" rel="noopener">K8S官方教程</a><br>
注意点:</p>
<ul>
<li>
<p>网络问题：</p>
<ul>
<li><a href="https://coding.imooc.com/learn/questiondetail/81560.html" target="_blank" rel="noopener">更改镜像源</a></li>
<li>更改 k8s image 源
<blockquote>
<p>kubeadm init --image-repository <a href="http://registry.aliyuncs.com/google_containers" target="_blank" rel="noopener">registry.aliyuncs.com/google_containers</a><br>
kubeadm init --image-repository <a href="http://index.docker.io/mirrorgooglecontainers" target="_blank" rel="noopener">index.docker.io/mirrorgooglecontainers</a></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>启动选项:</p>
<ul>
<li>选择 vm drive(in local linux environment use local docker)</li>
</ul>
<blockquote>
<p>minikube start --vm-driver=none</p>
</blockquote>
<ul>
<li>更改 kubeadm 配置</li>
</ul>
<blockquote>
<p>导出　kubeadm 原本配置　old.yaml，然后更改为 new.yaml<br>
kubeadm config migrate --old-config old.yaml --new-config new.yaml</p>
</blockquote>
</li>
<li>
<p>最终:</p>
</li>
</ul>
<blockquote>
<p>minikube start --vm-driver=none --image-repository=<a href="http://registry.aliyuncs.com/google_containers" target="_blank" rel="noopener">registry.aliyuncs.com/google_containers</a></p>
</blockquote>
<h2 id="kubernetsminikube-相关操作">Kubernets/minikube 相关操作</h2>
<p><a href="http://docs.kubernetes.org.cn/664.html" target="_blank" rel="noopener">k8s中文文档</a><br>
minikube</p>
<blockquote>
<p>minikube stop/delete</p>
</blockquote>
<p>port</p>
<blockquote>
<p>containerPort,targetPort,nodePort,port 之间的区别<br>
在deployment 文件中　containerPort相当于映射到容器外的端口 == docker run IMAGE_ID -P OUTSIDE_PORT:INSIDE_PORT<br>
docker exec -it  --privileged   ab56f4a5d15c  /bin/sh  携带权限进入 docker，避免进入docker内需要某些权限的操作</p>
</blockquote>
<p>kubectl</p>
<blockquote>
<p>kubectl describe pod/orders-5dbffdd8ff-zqp2c --namespace=‘sock-shop’<br>
kubectl get pods --namespace=‘sock-shop’<br>
kubectl edit deploy/shipping  --namespace=‘sock-shop’</p>
</blockquote>
<h2 id="相关概念">相关概念</h2>
<ol>
<li>pod vs container</li>
<li>containerPort vs targetPort vs nodePort vs port</li>
<li>service</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">chengr</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">97</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">京ICP备2020045262号 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chengr</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
