<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":250,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="知行合一">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="知行合一">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="知行合一">

<link rel="canonical" href="http://yoursite.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>知行合一</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">知行合一</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/06/工作求职/OS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/06/工作求职/OS/" class="post-title-link" itemprop="url">OS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-06 09:28:41" itemprop="dateCreated datePublished" datetime="2020-07-06T09:28:41+08:00">2020-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-07 12:45:13" itemprop="dateModified" datetime="2020-10-07T12:45:13+08:00">2020-10-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="线程状态及各状态之间的转换">线程状态及各状态之间的转换</h2>
<blockquote>
<p>新建状态、就绪状态、运行状态、阻塞状态及死亡状态</p>
</blockquote>
<h2 id="进程的内存结构">进程的内存结构</h2>
<blockquote>
<p>可执行文件的内容：代码段、数据段、BSS段和其他段<br>
代码段：代码<br>
数据段：存储初始化了的全局静态变量和局部静态变量和只读数据<br>
BSS段（Block Start By Symbol）:未初始化的全部静态变量和局部静态变量，为其预留空间<br>
其他段；保存于程序相关的其他信息，比如编译器信息，调试信息，动态链接信息等</p>
<p>装载可执行文件后，进程的空间大致可分为 代码区、数据区（bss+数据段）、向上的堆和向下的栈<br>
代码段：可读可执行<br>
数据段：可读可写<br>
堆：malloc 等程序员申请空间<br>
栈：系统运行时产生的变量，比如运行系统的信息、方法的参数、方法返回地址、局部变量等</p>
</blockquote>
<h2 id="线程的内存结构">线程的内存结构</h2>
<blockquote>
<p>线程共享进程的代码段，数据段，堆段，但是每个线程都拥有自己的私有栈，存储线程 ID、栈指针、PC、通用目的寄存器和条件码。<br>
Linux的线程栈是在进程的堆空间申请的。<br>
linux线程同步：<a href="https://www.cnblogs.com/yinbiao/p/11190336.html" target="_blank" rel="noopener">https://www.cnblogs.com/yinbiao/p/11190336.html</a><br>
互斥锁（临界区）：特殊全局变量划分临界区<br>
条件变量：等待该变量发生变化的等待队列，线程因特定条件休眠<br>
信号量：互斥锁只允许一个线程进入临界区，而信号量允许多个线程进入临界区<br>
读写锁：可以同时读，但不可以同时写</p>
</blockquote>
<h2 id="fork">fork</h2>
<blockquote>
<p>fork()函数用于从一个已经存在的进程内创建一个新的进程，新的进程称为“子进程”，相应地称创建子进程的进程为“父进程”。使用fork()函数得到的子进程是父进程的复制品，子进程完全复制了父进程的资源，包括进程上下文、代码区、数据区、堆区、栈区、内存信息、打开文件的文件描述符、信号处理函数、进程优先级、进程组号、当前工作目录、根目录、资源限制和控制终端等信息，而子进程与父进程的区别有进程号、资源使用情况和计时器等</p>
<p>由于复制父进程的资源需要大量的操作，十分浪费时间与系统资源，因此Linux内核采取了写时拷贝技术（copy on write）来提高效率<br>
在使用fork()函数创建子进程的时候，在调用fork()函数前是一个进程在执行这段代码，而调用fork()函数后就变成了两个进程在执行这段代码。两个进程所执行的代码完全相同，都会执行接下来的if-else判断语句块。</p>
<p>当子进程从父进程内复制后，父进程与子进程内都有一个&quot;pid&quot;变量：在父进程中，fork()函数会将子进程的PID返回给父进程，即父进程的pid变量内存储的是一个大于0的整数；而在子进程中，fork()函数会返回0，即子进程的pid变量内存储的是0；如果创建进程出现错误，则会返回-1，不会创建子进程。</p>
</blockquote>
<blockquote>
<p>父进程pid和子进程pid的大小关系<br>
如果进程ID最大值没有达到系统进程数的上限,子进程比父进程ID大.<br>
但是如果进程ID达到上限,系统会分配之前分配但是已经退出的进程ID给新进程,这样有可能出现子进程ID比父进程小.</p>
</blockquote>
<p>需要注意的是在一个线程中,调用fork函数,只会复制进程空间内该线程,不会复制其他线程(在当前线程上下文操作,该线程不能感知其他线程)</p>
<h2 id="内存管理">内存管理</h2>
<h3 id="非连续分配管理方式">非连续分配管理方式</h3>
<blockquote>
<p>允许程序分散的装入不相邻的内存分区 配合后面的虚存技术<br>
固定分区会产生内部碎片,动态分配会产生外部碎片<br>
根据分区的大小是否固定又分为 分页存储管理方式(基本分页存储管理方式和请求分页管理方式) 和 分段存储管理方式</p>
</blockquote>
<h4 id="基本分页管理方式">基本分页管理方式</h4>
<p>页的大小一般为4K(大小有页面大小和管理页的开销决定;内存为页帧,外存称之为块)<br>
从而把64位地址空间分为 页号和页内偏移量<br>
页表 为 <code>页号</code> 和 <code>块号</code> 的 对应<br>
系统中存在页表寄存器,包含 <code>页表的起始地址</code> <code>页表长度</code><br>
而每个进程都在进程控制块PCB存储自己的 页表寄存器值,当进程运行时将值放进页表寄存器 将进程内部的地址与之对应,把进程的虚拟地址的页号与之相对应 获取真实的块号(由于每次访存操作都涉及逻辑地址到物理地址的转换所以转换速度必须快,而且在内存中都需要存储页表 =&gt; 页表项即页号不能太大,页不能太小 同时 页太大会导致 内存利用率低加载慢 取折中 4K)</p>
<p>存储一个数据至少需要访问两次内存</p>
<ul>
<li>首先访问页表,获取块号</li>
<li>如果块在内存,就在内存中读取</li>
</ul>
<p>为了降低第一次访存的消耗,引入快表(联想寄存器TLB),即利用时间局部性原理 存储最近的页号和块号的映射</p>
<p>为了避免一层页表导致占据太多进程内存空间,引入多级页表(64位地址分为n级页号-1级页号),使得只需要保持当前使用的页表在内存即可(通过n级页号锁定n级页表)</p>
<h3 id="虚拟内存管理">虚拟内存管理</h3>
<p>处于局部性原理,不需要把进程的数据一次性装入内存;利用虚存技术,可以将内存的数据多次装入内存同时由于局部性原理保证程序的运行正常<br>
虚拟存储器基于局部性原理,给用户提供了远大于内存的空间;</p>
<h4 id="请求分页式">请求分页式</h4>
<p>页表机制+缺页中断机制+地址变换机制<br>
页表项= 页号 + 物理块号 + 状态位(是否在内存) + 访问字段 + 修改位 + 外存地址<br>
访问字段：用于记录页面在一段时间内的访问次数以及多长时间未被访问</p>
<h4 id="请求分段式">请求分段式</h4>
<h4 id="请求段页式">请求段页式</h4>
<h2 id="协程">协程</h2>
<blockquote>
<p>又称微线程，纤程。英文名Coroutine;<br>
可以看做用户态下的线程，协程的切换逻辑由可以在用户态下实现，同时不需要进行上下文的切换，因而相对于线程速度快很多；之所以不需要切换上下文，是因为传统的线程生命周期是一种嵌套形式的，同时只有一个线程有效，且线程无效后切换需要进行上下文的切换，而协程切换后，会向相应东西存放在随时可用的活动栈中(在堆中分配内存)<br>
每个协程都有自己私有栈,同时协程之间存在共享栈,由runnig-&gt;suspend设及私有栈恢复到共享栈,相反运行意味着保存到私有栈<br>
携程的状态从ready 到 running 到 susbpend 到 running 到 dead<br>
协程 VS 线程：不切换上下文;不涉及锁(自己实现协程间调度) 但linux并不支持携程 协程因为线程不会主动释放CPU时间,与机遇优先级抢占式的cpu调度不符</p>
</blockquote>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/94018082" target="_blank" rel="noopener">有栈协程实现原理</a> <a href="https://blog.csdn.net/liushengxi_root/article/details/85114692" target="_blank" rel="noopener">云风协程库保存和恢复协程运行栈原理讲解</a></p>
</blockquote>
<h2 id="作业调度算法">作业调度算法</h2>
<ul>
<li>FCFS：利于长进程，而不利于短进程</li>
<li>短作业优先：利于短进程，而不利于长进程</li>
<li>时间片轮转：时间片轮转调度算法</li>
<li>优先级调度算法</li>
<li>响应比高这优先：响应比= 等待时间+运行时间/运行时间 :既照顾了短进程，又考虑了进程到达的先后次序，也不会使长进程长期得不到服务，因此是一个比较全面考虑的算法，但每次进行调度时，都需要对各个进程计算响应比。所以系统开销很大，比较复杂</li>
<li>多级队列调度算法</li>
</ul>
<h2 id="存储器连续分配方式中分区分配算法">存储器连续分配方式中分区分配算法</h2>
<ul>
<li>首次适应分配算法:总是从第1条记录开始顺序查找空闲分区表，找到第一个能满足作业长度要求的空闲区，分割这个空闲区，一部分分配给作业，另一部分仍为空闲区</li>
<li>循环首次适应算法:每次分配均从上次分配的位置之后开始查</li>
<li>最佳适应分配算法(BF)：是按作业要求从所有的空闲分区中挑选一个能满足作业要求的最小空闲区，这样可保证不去分割一个更大的区域，使装入大作业时比较容易得到满足。为实现这种算法，把空闲区按长度递增次序登记在空闲区表中，分配时，顺序查找。</li>
<li>最坏适应算法(worst fit algorithm)：要求空闲区按其大小递减的顺序组成空闲区可用表或自由链。当用户作业或进程申请一个空闲区时，先检查空闲区可用表或自由链的第一个空闲可用区的大小是否大于或等于所要求的内存长度，若可用表或自由链的第一个项所示空闲区长度小于所要求的，则分配失败，否则从空闲区可用表或自由链中分配相应的存储空间给用户，然后修改和调整空闲区可用表或自由链。</li>
</ul>
<h2 id="页面置换算法">页面置换算法</h2>
<ul>
<li>最佳置换算法（OPT) ：选择以后永不使用或在最长时间内不再被访问的内存页面予以淘汰。</li>
<li>先进先出置换算法（FIFO）：选择最先进入内存的页面予以淘汰。</li>
<li>最近最久未使用算法（LRU）：选择在最近一段时间内最久没有使用过的页，把它淘汰。</li>
<li>最少使用算法（LFU）：选择到当前时间为止被访问次数最少的页转换。</li>
<li>时钟算法/最近未用算法：使用访问位和修改位标记页,优先替换未使用未修改的页,然后替换已修改的页。</li>
</ul>
<h2 id="页面分配策略">页面分配策略</h2>
<p>分页式的虚拟内存系统,对于每个进程如何分配主存空间</p>
<ul>
<li>固定分配局部置换：每个进程固定分配物理块,置换只发生在进程分配的空间</li>
<li>可变分配全局置换：每个进程分配少量物理块,同时维持全局空闲块,进程空间不足时从全局获取</li>
<li>可变分配局部置换：每个进程分配部分物理块,根据每个进程的缺页频率,动态增减进程的空间物理块数</li>
</ul>
<h2 id="磁盘调度">磁盘调度</h2>
<ul>
<li>先来先服务（FCFS）：是按请求访问者的先后次序启动磁盘驱动器，而不考虑它们要访问的物理位置</li>
<li>最短寻道时间优先（SSTF）：让离当前磁道最近的请求访问者启动磁盘驱动器，即是让查找时间最短的那个作业先执行，而不考虑请求访问者到来的先后次序，这样就克服了先来先服务调度算法中磁臂移动过大的问题</li>
<li>扫描算法（SCAN）或电梯调度算法：总是从磁臂当前位置开始，沿磁臂的移动方向去选择离当前磁臂最近的那个柱面的访问者。如果沿磁臂的方向无请求访问时，就改变磁臂的移动方向。在这种调度方法下磁臂的移动类似于电梯的调度，所以它也称为电梯调度算法。</li>
<li>循环扫描算法（CSCAN）：循环扫描调度算法是在扫描算法的基础上改进的。磁臂改为单项移动，由外向里。当前位置开始沿磁臂的移动方向去选择离当前磁臂最近的哪个柱面的访问者。如果沿磁臂的方向无请求访问时，再回到最外，访问柱面号最小的作业请求。</li>
</ul>
<h2 id="高速缓存与主存的三种映射方式">高速缓存与主存的三种映射方式</h2>
<ul>
<li>全相联映射：存中任意一个块都可以映射到cache中任意一个块的方式:利用率高但寻找困难</li>
<li>直接相联映射：内存块数%cache块数的值或者其低位地址决定其映射的cache行;寻找方便但是冲突率高</li>
<li>组相连映射:把cache分为x行一组,共y组,对于组实行直接相连映射,对于组内全相联映射</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/83597838" target="_blank" rel="noopener">参考0</a><br>
<a href="https://www.zhihu.com/question/19732473/answer/241673170" target="_blank" rel="noopener">参考1</a><br>
BIO NIO AIO<br>
同步 VS 异步</p>
<blockquote>
<p>是否需要自己主动去获取结果;<br>
场景：发送完请求,可以不等待请求结果,发送下一个请求,提高效率,保证并发<br>
是否存在异步阻塞IO?既然异步了,由OS负责准备数据到用户空间,由OS和线程/进程争抢总线,完成之后通知结果,进程本身可以轮询,仍然有自己控制,不算阻塞把</p>
</blockquote>
<p>阻塞 VS 非阻塞</p>
<blockquote>
<p>调用者是否被阻塞,或者说丧失自由/放弃CPU时间<br>
传统的IO流都是阻塞式的</p>
<ul>
<li>本地IO:当一个线程调用read()或者write()方法时，该线程将被阻塞，直到有一些数据读读取或者被写入，在此期间，该线程不能执行其他任何任务</li>
<li>网络IO：在完成网络通信进行IO操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量的客户端时，性能急剧下降<br>
非阻塞IO 不阻塞当前线程,可以做其他事情;由于大多时候,IO操作并不频繁,每个通道/外设 不是随时都有,所以可以有少数线程负责很多IO的输入输出的管理(减少上下文切换时间)</li>
</ul>
</blockquote>
<p>IO模型主要分类：</p>
<ul>
<li>同步IO 和 异步IO</li>
<li>阻塞IO 和 非阻塞IO</li>
<li>同步阻塞IO(synchronize block io): BIO</li>
<li>同步非阻塞IO(synchronize noblock io)</li>
<li>IO多路复用JAVA NIO</li>
<li>异步非阻塞IO(asychronous noblock io): AIO/IOCP</li>
</ul>
<p>用户程序进行IO的读写，基本上会用到系统调用read&amp;write，read把数据从内核缓冲区复制到进程缓冲区，write把数据从进程缓冲区复制到内核缓冲区，它们不等价于数据在内核缓冲区和磁盘之间的交换。<br>
BIO</p>
<blockquote>
<p>创建连接的那个线程会阻塞自己到等待数据到达,由内核进程复制数据到用户空间,之后可以运行</p>
</blockquote>
<p>同步非阻塞</p>
<blockquote>
<p>创建连接的线程调用完之后可以得到是否调用成功的结果,然后可以轮询询问是否完成(也可以分批获取缓冲区的数据,不必要一次性获得)<br>
适用于大量网络连接且IO不频繁的状态,避免大量创建线程同时可以从内核缓冲区读取不完整的数据(例如拆包粘包Netty)</p>
</blockquote>
<p>NIO</p>
<blockquote>
<p>创建连接的线程向selector注册一个channel,由其负责处理所有I操作,监控channel,并分发写进buffer,然后自己转做其他事情</p>
</blockquote>
<p>BIO VS NIO</p>
<blockquote>
<p>面向流 面向缓冲区<br>
阻塞   非阻塞<br>
无     selector</p>
</blockquote>
<p>BIO、NIO、AIO适用场景</p>
<blockquote>
<p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择。<br>
NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂。<br>
AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持</p>
</blockquote>
<p>selcet/poll/epoll 都属于 同步IO</p>
<p>Netty</p>
<h3 id="大端存储-小端存储">大端存储 小端存储</h3>
<blockquote>
<p>大端存储与小端存储模式主要指的是数据在计算机中存储的两种字节优先顺序。<br>
小端存储指从内存的低地址开始,先存储数据的低序字节再存高序字节;相反,大端存储指从内存的低地址开始,先存储数据的高序字节再存储数据的低序字节</p>
</blockquote>
<p>用途：</p>
<blockquote>
<p>小端存储:常见于本地主机上(也有部分类型主机为大端存储)<br>
大端存储:常见于网络通信上，网际协议TCP/IP在传输整型数据时一般使用大端存储模式表示,例如TCP/IP中表示端口和IP时，均采用的是大端存储</p>
</blockquote>
<p>如何避免死锁：</p>
<ul>
<li>银行家算法：分配资源前先评估风险，会不会在分配后导致死锁。</li>
<li>顺序加锁，这样能防止死锁现象</li>
</ul>
<p>多线程 VS 多进程</p>
<ul>
<li>线程只是进程的一个执行路径</li>
</ul>
<h3 id="文件描述符">文件描述符</h3>
<p><a href="https://segmentfault.com/a/1190000009724931" target="_blank" rel="noopener">文件描述符（File Descriptor）简介</a><br>
系统为了维护文件描述符,维持了3个层次的表</p>
<ul>
<li>进程层次的文件描述符表
<ul>
<li>文件描述符flag</li>
<li>指向系统级表的指针</li>
</ul>
</li>
<li>系统级的文件描述符表
<ul>
<li>当前文件的偏移</li>
<li>状态标识</li>
<li>文件访问模式:读 写 读写</li>
<li>inode引用</li>
<li>其他:访问权限,文件其他属性等</li>
</ul>
</li>
<li>文件系统的inode表
<ul>
<li>文件类型</li>
<li>文件锁</li>
</ul>
</li>
</ul>
<p>当我们打开一个文件或者建立socket时,会返回一个文件描述符,就是一个数字(0 1 2 分别默认标准输入/输出/错误输出),标识在进程空间内文件描述符表的索引(进程描述符表的长度默认为1024)</p>
<p>socket 连接使用过程</p>
<ul>
<li>create socket :寻找inode文件,创建相关数据结构,并返回文件描述符</li>
<li>bind：把socket与ip port 绑定(客户端无需调用,在connect时会自动分配一个port)</li>
<li>listen：将连接socket转化为监听套接字(更改socket状态为LISTEN)由tcp/ip协议簇完成监听</li>
<li>accept:
<ul>
<li>客户端会通过connect连接服务端,服务端会维持两个连接队列,未完成3次握手的和已完成3次握手的</li>
<li>accept函数默认为阻塞函数,当已完成握手连接队列非空时,会返回队列首的连接文件描述符(一个完整的连接套接字,包含源目的端口ip,这样可以实现socket复用)</li>
</ul>
</li>
<li>send/recv：</li>
<li>select/poll/epoll
<ul>
<li>select 成功返回就绪的文件描述符数量,如果&gt;0,则循环遍历事件,然后确定是哪个并处理</li>
</ul>
</li>
</ul>
<p>socket描述</p>
<blockquote>
<p>accept建立连接之后,返回一个文件描述符,指向socket套接字,包含源ip/端口 目的ip/端口 也就是父进程与fork出的子进程共同监听一个端口,但是由于请求类型不同(建立连接由主进程负责,而已建立的连接由多个子进程竞争锁获得负责) 可以区分<br>
<a href="http://blog.chinaunix.net/uid-23629988-id-285722.html" target="_blank" rel="noopener">kernel如何选择socket接收数据</a> 根据协议选择不同链表,然后遍历选择(源ip端口等信息)最符合的socket</p>
</blockquote>
<p>select</p>
<blockquote>
<p>在内核处理时需要两次循环遍历发现就绪,在外也需要循环遍历发现就绪事件,耗时,且传进去的fd_set位图表示监视的文件描述符,默认限制1024长度<br>
select在调用时使用不同set表示监听不同的事件类型(读写异常);do-select 中会对调用返回对应文件的poll函数,检测是否有时间发生,如果发生返回类型mask,并判断是否是读/写/异常,然后添加进不同的返回列表中;</p>
</blockquote>
<p>poll<br>
<a href="https://blog.51cto.com/10706198/1783610" target="_blank" rel="noopener">使用示例</a></p>
<h4 id="select-解析">select 解析</h4>
<p><a href="http://lxr.linux.no/linux+v3.9/fs/select.c" target="_blank" rel="noopener">select 内核源码</a><br>
<a href="https://blog.csdn.net/weixin_42462202/article/details/95315926" target="_blank" rel="noopener">Linux select内核源码剖析</a><br>
<a href="https://blog.csdn.net/caogenwangbaoqiang/article/details/80949643" target="_blank" rel="noopener">select模型linux内核源码注释总结</a></p>
<p>select函数的参数</p>
<ul>
<li>最大文件描述符+1</li>
<li>读事件监听set</li>
<li>写事件监听set</li>
<li>异常事件监听set</li>
<li>默认等待时间(null:阻塞;0:立刻返回;其他)</li>
</ul>
<p>select -&gt; do_select<br>
在死循环中,</p>
<ul>
<li>遍历文件描述符,并调用其poll函数,将该进程添加进其等待队列 然后陷入睡眠</li>
<li>如果时间到达或者被中断唤醒,会继续循环遍历文件描述符,如果调用poll函数后发现有时间发生,就绪事件记录+1,遍历完成后,如果就绪事件&gt;0或者等待超时,就跳出死循环,否则继续休眠</li>
</ul>
<p>缺点：</p>
<ul>
<li>fd set长度有限制</li>
<li>需要在用户空间和内核空间之间拷贝fdset数据</li>
<li>检查是否发生事件时,是轮询遍历,而且范围内包含不关注的文件描述符;返回结果也需要轮询</li>
</ul>
<h3 id="poll-解析">poll 解析</h3>
<p><a href="https://blog.51cto.com/10706198/1783610" target="_blank" rel="noopener">使用示例</a><br>
<a href="http://gityuan.com/2019/01/05/linux-poll-select/" target="_blank" rel="noopener">源码解析</a><br>
<a href="https://www.cnblogs.com/shuqin/p/11662645.html" target="_blank" rel="noopener">poll(2) 源码分析</a><br>
poll 函数的参数</p>
<ul>
<li>pollfd数组</li>
<li>最大文件描述符</li>
<li>时间</li>
</ul>
<p>poll利用 pollfd 结构体记录 file-description 和 event(POLLINT/POLLOUT/异常) 以及 revents(系统触发的事件)<br>
过程</p>
<ul>
<li>利用 pollfd 数组记录监听的文件描述符对应的连接以及类型;</li>
<li>之后调用poll函数,其内会将数组转化为链表(按页分配内存申请内存,每页存储一个pollfd数组,利用<a href="https://lenzhao.com/topic/5a28f4b52e95f0fd0a9818a8" target="_blank" rel="noopener">copy_from_user</a>把用户空间的pollfd拷贝到核心空间,然后next页,如果分配失败就会free所有节点,然后返回内存错误);</li>
<li>之后根据链表来遍历;大致过程与select类似,但是会将触发的事件类型记录在revents中(首先会过滤掉不感兴趣的事件);并通过copy_to_user 拷贝回用户空间</li>
<li>在poll返回的结果&gt;0则会轮询查询event与revents是否一致</li>
</ul>
<p>相对于select 突破了1024的默认长度限制,只要满足长度小于RLIMIT_NOFILE(进程最大打开文件描述符限制即可;可以设置65535)</p>
<p>缺点：</p>
<ul>
<li>仍需在用户和内核空间拷贝数据,量变得更大</li>
<li>相对于select更精确,但检查事件以及返回时然后需要遍历确认</li>
</ul>
<h3 id="epoll-解析">epoll 解析</h3>
<p><a href="http://lxr.linux.no/linux+v3.9/fs/eventpoll.c" target="_blank" rel="noopener">eventspoll源码</a><br>
<a href="http://lxr.linux.no/linux+v3.9/include/linux/fs.h" target="_blank" rel="noopener">struct file</a><br>
<a href="http://wxgg.cc/blogs/2018/12/libevent-cpp-5-%E5%B0%81%E8%A3%85epoll%E5%8F%8Aepoll%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" target="_blank" rel="noopener">封装epoll及epoll内核实现原理</a><br>
<a href="https://www.iminho.me/wiki/blog-23.html" target="_blank" rel="noopener">IO多路复用原理剖析</a><br>
<a href="http://gityuan.com/2019/01/06/linux-epoll/" target="_blank" rel="noopener">源码解读epoll内核机制</a><br>
<a href="https://www.cnblogs.com/apprentice89/p/3234677.html" target="_blank" rel="noopener">epoll用法回顾</a><br>
<a href="https://icoty.github.io/2019/06/03/epoll-source/" target="_blank" rel="noopener">epoll源码分析(基于linux-5.1.4)</a><br>
<a href="https://zhuanlan.zhihu.com/p/64746509" target="_blank" rel="noopener">如果这篇文章说不清epoll的本质，那就过来掐死我吧</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct eventpoll &#123;</span><br><span class="line">    spinlock_t lock;</span><br><span class="line">    struct mutex mtx;</span><br><span class="line">    //调用epoll_wait过程中陷入阻塞的进程队列</span><br><span class="line">    wait_queue_head_t wq;</span><br><span class="line">    //与文件相关的等待队列,保存了所有等待该文件相关事件的进程(file-&gt;poll()),对于该文件的读写操作会唤醒该队列</span><br><span class="line">    wait_queue_head_t poll_wait;</span><br><span class="line">    //就绪状态的文件描述符的列表</span><br><span class="line">    struct list_head rdllist;</span><br><span class="line">    //存储监控的红黑树</span><br><span class="line">    struct rb_root rbr;</span><br><span class="line">    struct file *file;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>过程：</p>
<ul>
<li>epoll_create:创建file实例,创建eventpoll,赋值给file-&gt;private_date,获得未使用fd与改file绑定,然后返回fd</li>
<li>epoll_ctl:控制监听的事件,增加/删除/修改,实质是通过对之前创建的eventpoll中的红黑树进行操作以insert为例
<ul>
<li>初始化epollitem(fd file)</li>
<li>初始化ep_pqueue,添加到socket文件的等待队列并注册回调函数ep_ptable_queue_proc-&gt;ep_poll_callback(判断是否是感兴趣的事件,添加进epoll的就绪队列,并唤醒epoll在wait阶段的阻塞进程)</li>
<li>在红黑树中插入节点</li>
</ul>
</li>
<li>epoll_wait: 调用 ep_poll ,在死循环中判断:如果就绪队列为空,那么休眠,将自己阻塞在eventpoll的等待队列,等待ep_poll_callback 唤醒 否则跳出循环,拷贝就绪队列的events事件到用户空间</li>
</ul>
<p>其他</p>
<ol>
<li>红黑树中存储需要监听的事件,节点类型是epollitem,比较的方法是首先比较socket对应的file指针地址(没看到重写比较符) 然后比较fd值</li>
<li>ep_poll_callback 函数 会首先将当前触发的操作的添加到eventpoll的就绪队列,然后唤醒该eventpoll的等待队列</li>
</ol>
<p>优点:相对于select/poll 的轮询和数据拷贝操作</p>
<ul>
<li>利用回调函数,在唤醒时将就绪的文件添加到就绪队列,拷贝回用户空间,无需轮询(将之前的wait操作拆分为ctl和wait操作)</li>
<li>利用eventpoll中的红黑树存储关注的文件描述符和事件,无需频繁的拷贝所有数据</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于大量的频发事件,会频繁调用回调函数,效率不高,适合大量低速的连接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct epitem &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        struct rb_node rbn; //RB树节点将此结构链接到eventpoll RB树</span><br><span class="line">        struct rcu_head rcu; //用于释放结构体epitem</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    struct list_head rdllink; //用于将此结构链接到eventpoll就绪列表的列表标头</span><br><span class="line">    struct epitem *next; //配合ovflist一起使用来保持单向链的条目</span><br><span class="line">    struct epoll_filefd ffd; //此条目引用的文件描述符信息</span><br><span class="line">    int nwait; //附加到poll轮询中的活跃等待队列数</span><br><span class="line"></span><br><span class="line">    struct list_head pwqlist;</span><br><span class="line">    struct eventpoll *ep;  //epi所属的ep</span><br><span class="line">    struct list_head fllink; //链接到file条目列表的列表头</span><br><span class="line">    struct wakeup_source __rcu *ws; //设置EPOLLWAKEUP时使用的wakeup_source</span><br><span class="line">    struct epoll_event event; //监控的事件和文件描述符</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="et-lt">ET LT</h3>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/05/Blog/blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/05/Blog/blog/" class="post-title-link" itemprop="url">blog 产生记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-05 22:52:19" itemprop="dateCreated datePublished" datetime="2020-07-05T22:52:19+08:00">2020-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-09 16:00:31" itemprop="dateModified" datetime="2020-12-09T16:00:31+08:00">2020-12-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/05/Blog/个人网站/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/05/Blog/个人网站/" class="post-title-link" itemprop="url">个人网站搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-05 22:52:19" itemprop="dateCreated datePublished" datetime="2020-07-05T22:52:19+08:00">2020-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-10 10:20:17" itemprop="dateModified" datetime="2020-12-10T10:20:17+08:00">2020-12-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="域名">域名</h1>
<h2 id="域名购买">域名购买</h2>
<p>国内域名</p>
<h2 id="域名解析">域名解析</h2>
<p>godaddy<br>
国内解析<br>
cloudflare</p>
<h1 id="审核">审核</h1>
<h2 id="阿里云-初审">阿里云 初审</h2>
<p>主要是网站名称的问题，发现不能使用成语。</p>
<h2 id="管局审核">管局审核</h2>
<p>在hexo相应处增加该信息</p>
<h2 id="公安局审核">公安局审核</h2>
<p>公安联网备案申请,并在hexo相应处增加该信息</p>
<h1 id="部署">部署</h1>
<h2 id="服务器部署hexo">服务器部署hexo</h2>
<h3 id="安装必要软件">安装必要软件</h3>
<p>git nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get-install nodejs npm</span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h3 id="配置服务器文件夹接受本地hexo传输文件">配置服务器文件夹接受本地hexo传输文件</h3>
<p>参考<a href="https://www.cnblogs.com/luoshuitianyi/p/10333928.html" target="_blank" rel="noopener">Hexo搭建(VPS)</a></p>
<ol>
<li>创建裸仓库，用于接受文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir hexo.git</span><br><span class="line">cd hexo.git</span><br><span class="line">git init --bare # 裸仓库只存储历史和元数据信息，不维护工作目录</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建文件夹(中转目录和nginx根目录)以及git hook</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/hexo  #中转目录</span><br><span class="line">mkdir /var/www/hexo #nginx 根目录</span><br></pre></td></tr></table></figure>
<p>编辑 hooks/post-receive 文件,指定 ~/hexo.git/目录下的仓库更新后的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">GIT_REPO=~/hexo.git                      # 触发 hook</span><br><span class="line">TMP_GIT_CLONE=/tmp/hexo                  # 存在 /tmp 下</span><br><span class="line">PUBLIC_WWW=/var/www/hexo                 # 展示网站的目录</span><br><span class="line">rm -rf $&#123;TMP_GIT_CLONE&#125;                  # 删除之前内容</span><br><span class="line">git clone $GIT_REPO $TMP_GIT_CLONE       # 将 Git 仓库上传的内容复制到/tmp</span><br><span class="line">rm -rf $&#123;PUBLIC_WWW&#125;/*                   # 删除展示网站的目录的全部内容</span><br><span class="line">cp -rf $&#123;TMP_GIT_CLONE&#125;/* $&#123;PUBLIC_WWW&#125;  # 将/tmp所有内容复制到网站目录</span><br></pre></td></tr></table></figure>
<p>使得post-receive 可执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x hexo/hexo.git/hooks/post-receiv</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>配置https<br>
从阿里云申请免费证书，下载证书，放置在相关位置，并修改nginx配置文件</li>
</ol>
<figure class="highlight plain"><figcaption><span>of Hexo</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        listen [::]:80;</span><br><span class="line">        server_name _;</span><br><span class="line">        rewrite ^/(.*)$ https://www.whetstone.life:443/$1 permanent;</span><br><span class="line">&#125;</span><br><span class="line">#Config of https</span><br><span class="line">server &#123;</span><br><span class="line">        listen 443;</span><br><span class="line">        listen [::]:443;</span><br><span class="line">        server_name _;</span><br><span class="line">        ssl on;</span><br><span class="line">        ssl_certificate /etc/nginx/ssl/www.whetstone.life.pem;</span><br><span class="line">        ssl_certificate_key /etc/nginx/ssl/www.whetstone.life.key;</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        server_name _;</span><br><span class="line">        location / &#123;</span><br><span class="line">                root /var/www/hexo;</span><br><span class="line">                index index.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改防火墙,在阿里云ECS实例中修改安全组规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 443 -j ACCEPT</span><br></pre></td></tr></table></figure>
<h2 id="配置-ssh-互信">配置 ssh 互信</h2>
<p>只需要服务器信任本地host即可,方便从本地传输文件到服务器无需输入密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp ./.ssh/id_rsa.pub root@ip:/root</span><br><span class="line">cat id_rsa.pub &gt; .ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<h2 id="本地hexo配置deploy">本地hexo配置deploy</h2>
<p>配置多个deploy对象，参考 <a href="https://hexo.io/zh-cn/docs/one-command-deployment" target="_blank" rel="noopener">hexo deploy配置</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: git</span><br><span class="line">  repository: git@github.com: ***/***.github.io.git </span><br><span class="line">  branch: master </span><br><span class="line">- type: git</span><br><span class="line">  repository: root@ip:/path/to/push</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/05/基础知识/Clousim/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/05/基础知识/Clousim/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-05 16:40:45" itemprop="dateCreated datePublished" datetime="2020-07-05T16:40:45+08:00">2020-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-30 13:25:00" itemprop="dateModified" datetime="2020-08-30T13:25:00+08:00">2020-08-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="http://www.trojx.me/2019/12/30/cloudsim-plus-faq/" target="_blank" rel="noopener">云计算仿真工具CloudSim Plus常见问题总结</a><br>
<a href="https://veviz.github.io/2016/05/17/CloudSim/" target="_blank" rel="noopener">CloudSim Introduction</a><br>
<a href="https://blog.csdn.net/wjh1313677/article/details/45625999" target="_blank" rel="noopener">CloudSim源码分析-DatacenterBroker创建</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/30/工作求职/Java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/30/工作求职/Java/" class="post-title-link" itemprop="url">java 语言学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-30 15:42:16" itemprop="dateCreated datePublished" datetime="2020-06-30T15:42:16+08:00">2020-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-15 15:37:28" itemprop="dateModified" datetime="2020-10-15T15:37:28+08:00">2020-10-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="多线程">多线程</h1>
<h2 id="线程创建方法">线程创建方法</h2>
<blockquote>
<p>1.继承Thread类，重写run()线程执行程序，创建线程<br>
2.实现Runnable接口，重写run()方法，作为参数构造thread，创建线程<br>
3.使用Callable和Future创建线程<br>
4.使用线程池例如用Executor框架</p>
</blockquote>
<ul>
<li>Executor 的参数</li>
</ul>
<blockquote>
<p>实现Runnable接口比继承Thread类所具有的优势：<br>
1)可以避免java中的单继承的限制；可以继承多个接口<br>
2)Thread 实现了Runnable 接口, 提供了更多的可用方法和成员而已</p>
</blockquote>
<h2 id="多线程">多线程</h2>
<p>synchronize作为多线程关键字，是一种同步锁，它可以修饰以下几种对象：</p>
<ul>
<li>代码块：被修饰的代码块称为同步语句块，其作用的范围是大括号{ }里的代码，作用的对象是调用这个代码块的对象；</li>
<li>方法：被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象</li>
<li>静态方法：作用的范围是整个静态方法，作用的对象是这个类的所有对象</li>
<li>类：作用的范围是synchronize后面括号里的部分，作用的对象是这个类的所有对象</li>
</ul>
<p>锁：线程争夺对于锁，获取锁，然后运行代码</p>
<ul>
<li>对象锁 this 对象,其他对象</li>
<li>类锁</li>
</ul>
<blockquote>
<p>线程开始<br>
线程停止：正常执行完run；interrupt使得线程异常，执行完run<br>
其他：</p>
<blockquote>
<p>设置线程优先级(特性：继承性(线程A启动线程B，B继承A的优先级) ; 随机性(线程的调度顺序不一定根据优先级,具有随机性))<br>
yield方法，释放CPU资源，通常它会让当前运行线程回到可运行性状态，使得有相同优先级的线程有机会执行。<br>
sleep方法，使当前线程睡眠至少时间<br>
join()方法：保证当前线程停止执行，直到该线程所加入的线程完成为止。然而，如果它加入的线程没有存活，则当前线程不需要停止（基于wait方法和notify方法）</p>
</blockquote>
</blockquote>
<h1 id="gc">GC</h1>
<h2 id="背景">背景</h2>
<blockquote>
<p>内存空间是有限的，如果高效利用有限的空间，可以通过释放不适用的对象所占用的内存(Java虚拟机所管理的内存区域分为如下部分：方法区、堆内存、虚拟机栈、本地方法栈、PC寄存器)</p>
</blockquote>
<h2 id="gc对象">GC对象</h2>
<blockquote>
<p>程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理；内存垃圾回收主要集中于 java 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的</p>
</blockquote>
<h3 id="判定方法">判定方法</h3>
<blockquote>
<p>如何判断对象不再存活：引用计数（每个对象有一个引用计数属性，计数为0时可以回收，但无法解决对象相互循环引用的问题）和可达分析（通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连，则证明此对象是不可用的）</p>
</blockquote>
<h3 id="触发gc的条件">触发GC的条件</h3>
<blockquote>
<p>1.程序主动调用System.gc<br>
2.内存不足被动触发(年轻代升级空间不够,或者永久代空间不足)</p>
</blockquote>
<h2 id="gc-roots">GC ROOTS</h2>
<blockquote>
<p>虚拟机栈、方法区和本地方法栈；方法区中类静态属性引用的对象；常量<br>
1.系统类加载器锁加载的类<br>
2.阻塞线程以及运行线程涉及的对象；本地方法栈涉及的对象<br>
3.全局对象，上锁对象<br>
4.针对younggc来说，gcroot的对象包括所有年老带对象</p>
</blockquote>
<h2 id="为对象分配内存的方法">为对象分配内存的方法</h2>
<ul>
<li>规整内存/指针碰撞:将内存分为已使用和未使用的两部分,使用指针将两者隔开,然后指针右移需要的空间即可(建立在压缩空闲空间的基础上,耗时)</li>
<li>空闲列表法:把空间的空间的大小范围列表排序,然后选择(有首次适应,循环适应,最有适应,最坏适应)</li>
</ul>
<p>卡表(cardTable)</p>
<blockquote>
<p>JVM 把每512字节表示为一个卡页,<br>
为了提高重新标记的效率，并发标记阶段会把这些发生变化的对象所在的Card标识为Dirty，这样后续阶段就只需要扫描这些Dirty Card的对象，从而避免扫描整个老年代</p>
</blockquote>
<h2 id="gc常用算法">GC常用算法</h2>
<blockquote>
<p>1.标记-清除算法：标记对象的存活或者死亡;清除对象会导致大量碎片<br>
2.复制算法：内存分为两部分，只使用其中一部分，这部分内存用完后，将其中存活的对象移动至另一部分，其他删除；没有碎片，但内存利用率低<br>
3.标记-压缩算法：在上种算法的基础上，将存活的对象整理到一起；如果存活对象过多会导致，复制次数过多，效率下降<br>
4.分代收集算法（JVM Hotspot在使用）：根据对象的生存周期，将堆分为新生代(Young)和老年代(Tenure)。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。</p>
</blockquote>
<h3 id="cms">CMS</h3>
<blockquote>
<p>基于标记-清除算法<br>
堆被划分为新生代和老年代，新生代又被进一步划分为Eden和Survivor区，而Survivor由FromSpace和ToSpace组成。<br>
<br>新生代：新创建的对象都是用新生代分配内存，Eden空间不足时，触发Minor GC，这时会把存活的对象转移进Survivor区。<br>
<br>老年代：老年代用于存放经过多次Minor GC之后依然存活的对象，老年代内存不足时触发，Major GC</p>
</blockquote>
<h3 id="zgc">ZGC</h3>
<blockquote>
<p>todo</p>
</blockquote>
<h3 id="cms-vs-g1"><a href="https://www.cnblogs.com/heyonggang/p/11718170.html" target="_blank" rel="noopener">CMS VS G1</a></h3>
<blockquote>
<p>CMS：Concurrent Mark Sweep，基于标记-清楚算法，作用于老年代，以并发获取最短回收停顿时间为目标的</p>
<blockquote>
<p>初始标记（标记root直接关联的对象）、并发标记（root  trace）、重新标记（并发标记中涉及的对象）、并发清除（CMS concurrent sweep）<br>
优点：并发收集、低停顿<br>
缺点：</p>
<blockquote>
<p>CMS收集器对CPU资源非常敏感，频繁GC，CPU资源不足。<br>
CMS收集器无法处理浮动垃圾（Floating Garbage），并发清除阶段，运行产生的垃圾无法在本次回收。<br>
CMS收集器是基于标记-清除算法，导致碎片。<br>
安全点：程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停，安全点的初始目的是找到一个稳定的执行状态。在这个执行状态下，Java虚拟机的堆栈不会发生变化；长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等<br></p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<p>G1：Garbadge First Collector；基于标记-整理算法；G1重新定义了堆空间，将堆划分为一个个区域；来进行垃圾回收，不必在全堆范围内收集，可以预测停顿时间</p>
<blockquote>
<p>与CMS的步骤类似，只是第4步时，他根据region排序价值和预测时间去清除，最后然后拷贝存活对象至新的region<br>
卡表：？？？与老年代引用年轻代<br>
相对于CMS优势：可预测的停顿模型；避免了CMS的垃圾碎片；超大堆的表现更出色</p>
</blockquote>
</blockquote>
<h1 id="设计模式">设计模式</h1>
<h2 id="单例模式">单例模式</h2>
<blockquote>
<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象</p>
</blockquote>
<blockquote>
<blockquote>
<ol>
<li>懒汉模式：实例在使用到的时候才创建,当多线程并发调用 getInstance(),如果方法不加synchronize 关键字修饰,会导致线程不安全</li>
</ol>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class LHan &#123;</span><br><span class="line">    private static LHan instance;</span><br><span class="line">    private LHan()&#123;&#125;</span><br><span class="line">    public static LHan getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            instance = new LHan();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<ol start="2">
<li>饿汉模式,实例在最初已经初始化,getInstance()方法线程安全，但浪费内存空间</li>
</ol>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class EHan &#123;</span><br><span class="line">    private static EHan instance = new EHan();</span><br><span class="line">    private EHan()&#123;&#125;</span><br><span class="line">    public static EHan getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<ol start="3">
<li>双检锁,双重校验锁,在synchronize 关键字内外都加上一层if判断,即避免内存浪费,又保证了线程安全,同时 比直接上锁提高了执行效率</li>
</ol>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class DoubleCheck &#123;</span><br><span class="line">    private static DoubleCheck instance;</span><br><span class="line">    private DoubleCheck()&#123;&#125;</span><br><span class="line">    public static DoubleCheck getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            synchronize(DoubleCheck.class)&#123;</span><br><span class="line">                if(instance == null)&#123;</span><br><span class="line">                    instance = new DoubleCheck();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<ol start="4">
<li>静态内部类(内部类是外部类的一个成员,分为静态内部类和非静态内部类：静态内部类可以直接调用外部类的静态成员(静态成员变量和静态方法)，但是不能直接调用外部类的非静态成员；而非静态内部类可以直接调用外部类的其他成员)</li>
</ol>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class SingleTon &#123;</span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static final SingleTon INSTANCE = new SingleTon();</span><br><span class="line">    &#125;</span><br><span class="line">    private SingleTon()&#123;&#125;</span><br><span class="line">    public static final SingleTon getInstance()&#123;</span><br><span class="line">        return SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<ol start="5">
<li>枚举</li>
</ol>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum SingleTonn &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public void AnyMethod()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id></h1>
<h1 id="其他常见问题">其他常见问题</h1>
<h2 id="hashmap-hashtable-concurrenthashmap">HashMap HashTable ConcurrentHashMap</h2>
<blockquote>
<p>都是 数组+单链表 实现<br>
<a href="https://blog.csdn.net/mbshqqb/article/details/79799009" target="_blank" rel="noopener">参考1</a><br>
HashMap基于hashing原理，我们通过put()和get()法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用LinkedList来解决碰撞问题，当发生碰撞了，对象将会储存在LinkedList的下一个节点中。 HashMap在每个LinkedList节点中储存键值对对象。<br>
　　当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的LinkedList（链表只让挂7个元素，超过七个就会转成一个红黑树进行处理，当红黑树下挂的节点小于等于6的时候，系统会把红黑树转成链表）中。键对象的equals()方法用来找到键值对<br>
String, Interger这样的类，作为HashMap的键是再适合不过了，因为String对象是不可变的，计算hashCode()，就要防止键值改变</p>
</blockquote>
<blockquote>
<p>HashTable：无论key还是value都不能为null，线程安全，实现线程安全的方式是在修改数据时锁住整个HashTable；<br>
HashMap：无论key还是value都能为null，线程不安全（在多个线程并发扩容时，会在执行transfer()方法转移键值对时，造成链表成环，导致程序在执行get操作时形成死循环 <a href="https://www.cnblogs.com/lonelyJay/p/9726187.html" target="_blank" rel="noopener">参考1</a> <a href="https://www.sohu.com/a/341902281_100123073" target="_blank" rel="noopener">参考2</a> ;单链表复制是是插入排序，因为时刻知道链表头在哪）</p>
</blockquote>
<blockquote>
<p>但是 HashMap线程不安全，而HashTable安全但是效率低，出现了ConcurrentHashMap使用分段锁<br>
cocurrent 将hashmap的数据分为若干个子数组,每个子数组包装为segment对其加锁;<br>
抛开 HashMap，hash 冲突有那些解决办法？开放定址法、链地址法、再哈希法<br>
<a href="https://www.cnblogs.com/cosmos-wong/p/11845934.html" target="_blank" rel="noopener">java stack不推荐使用</a>,建议使用dequeue代替</p>
</blockquote>
<p>HashMap 扩容时机</p>
<ul>
<li>hashmap首次插入元素时会resize初始化table</li>
<li>hashmap中元素总数量达到阈值threshold(阈值初始化时等于)</li>
<li>如果某个链表的长度&gt;=8-1,则转化为红黑树(小于等于6时转换回来);在转化时,首先判断数组长度是否小于64那么就扩容,否则才转化</li>
</ul>
<h2 id="linkedhashmap-treemap">LinkedHashMap TreeMap</h2>
<blockquote>
<p>LinkedHashMap保存了记录的插入顺序,在用Iterator遍历LinkedHashMap时,先得到的记录肯定是先插入的,也可以在构造时用带参数,按照应用次数排序.<br>
在遍历的时候会比HashMap慢,不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关<br>
TreeMap实现SortMap接口,能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。插入查询的效率都是O(logN)</p>
</blockquote>
<h2 id="arraylist-vs-linkedlist">Arraylist VS LinkedList</h2>
<blockquote>
<p>LinkedList与ArrayList一样实现List接口，只是ArrayList是List接口的大小可变数组的实现，LinkedList是List接口链表的实现。基于链表实现的方式使得LinkedList在插入和删除时更优于ArrayList，而随机访问则比ArrayList逊色些。<br>
LinkedList实现所有可选的列表操作，并允许所有的元素包括null。<br>
除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。<br>
此类实现 Deque 接口，为 add、poll 提供先进先出队列操作，以及其他堆栈和双端队列操作</p>
</blockquote>
<h2 id="volatile和synchronized特点">volatile和synchronized特点：</h2>
<blockquote>
<p>执行控制（执行顺序，并发）和内存可见（读写经过内存）<br>
volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别(class对象的锁)的<br>
volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞<br>
volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</p>
</blockquote>
<h2 id="java两种数据类型">Java两种数据类型</h2>
<blockquote>
<p>分为基本数据类型（boolean、byte、int、char、long、short、double、float）和引用数据类型（数组、类、接口）<br>
Java为每 一个基本数据类型都引入了对应的包装类型（Boolean，Character，Byte，Short，Integer，Long，Float，Double），可以使用自动装箱/拆箱进行替换（装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型）<br>
例如：int与Integer的基本使用对比</p>
<ul>
<li>Integer是int的包装类，Integer变量必须实例化后才能使用；Integer的默认值是null;int是基本数据类型，int变量不需要初始化，int的默认值是0。</li>
<li>在使用时，Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；</li>
</ul>
</blockquote>
<h2 id="设计模式">设计模式</h2>
<blockquote>
<p><a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/design-pattern-tutorial.html</a><br>
工厂模式:定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行<br>
优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p>
<p>控制反转（Inversion of Control，缩写为IoC）；依赖注入<br>
缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事<br>
使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。2、设计一个连接服务器的框架，需要三个协议，“POP3”、“IMAP”、“HTTP”。</p>
<p>单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br>
主要解决：一个全局使用的类频繁地使用，实现共享，锁,static<br>
优点：1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。2、避免对资源的多重占用（比如写文件操作）。<br>
缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<p>装饰器模式:动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活<br>
主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。<br>
优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能.<br>
缺点：多层装饰比较复杂。</p>
<p>组合模式：是用于把一组相似的对象当作一个单一的对象</p>
<p>外观模式：隐藏系统的复杂性，客户端请求的简化方法和对现有系统类方法的委托调用（列类似于自动化脚本的概念）。<br>
优点： 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。<br>
缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</p>
<p>代理模式：其他对象提供一种代理以控制对这个对象的访问<br>
主要解决：远程调用，RPC；直接调用带来的危险，添加控制，火车站<br>
静态代理：添加日志</p>
</blockquote>
<h2 id="堆栈">堆栈</h2>
<blockquote>
<p>都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。<br>
堆：一棵树的数组对象（大顶堆，小顶堆），一般程序员申请    ；栈：先入后出，有一半程序员申请 队列：先入先出</p>
</blockquote>
<h2 id="bean">bean</h2>
<blockquote>
<p><a href="https://www.awaimai.com/2596.html" target="_blank" rel="noopener">https://www.awaimai.com/2596.html</a><br>
bean是一个由Spring IoC容器实例化、组装和管理的对象。<br>
类的实例化、依赖的实例化、依赖的传入都交由 Spring Bean 容器控制而不是new</p>
</blockquote>
<h2 id="malloc-vs-new">malloc VS new</h2>
<h2 id="4种io模式">4种IO模式</h2>
<blockquote>
<ul>
<li>同步阻塞IO（Blocking IO）</li>
<li>同步非阻塞IO（Non-blocking IO）</li>
<li>IO多路复用（IO Multiplexing）</li>
<li>异步IO（Asynchronous IO）<br>
<a href="https://blog.csdn.net/qq_34802511/article/details/81543817" target="_blank" rel="noopener">https://blog.csdn.net/qq_34802511/article/details/81543817</a><br>
同步io操作导致请求进程阻塞，直到i/o操作完成；异步io操作不导致请求进程阻塞<br>
以read IO为例子，大致分为2步 1）等待数据准备(数据从磁盘拷贝到内核内存) 2）将数据从内核拷贝到进程中<br>
同步阻塞在两个阶段都会阻塞；而同步非阻塞IO只会在第二个阶段阻塞，进程在第一步受阻后，会返回，然后反复询问是否内核准备好数据；<br>
IO多路复用：在同步非阻塞的基础上，可以使用一个进程监视多个输入（select，poll，epoll）<br>
而异步IO中，两步都不会造成阻塞，知道数据已经复制到进程内存区，会通知进程</li>
</ul>
</blockquote>
<h2 id="nio">NIO</h2>
<blockquote></blockquote>
<p><a href="https://juejin.im/post/6844903729435508750" target="_blank" rel="noopener">Java ClassLoader 再不理解就老了</a></p>
<h2 id="类的加载">类的加载</h2>
<p>在类的加载之前需要首先基于javac命令将java源文件编译成class文件,然后在运行中加载.<br>
我们借助类加载器完成类的加载,类的加载共分为三个阶段:加载 链接(验证 准备 解析)  初始化</p>
<ul>
<li>加载：根据类的全限定名来找到相应的class文件,并加载到内存</li>
<li>链接
<ul>
<li>验证：验证class字节流文件中的信息符合虚拟机的要求,不会危害自身安全</li>
<li>准备：给类变量分配内存并初始化为默认值,初始化常量(final)</li>
<li>解析：将常量池(在编译期即被确定的一些常量)中符号引用转化为直接引用
<ul>
<li>举例：对于类而言就是将全限定名转化为该类在内存中的地址</li>
<li>对于类引用的解析,是在初始化之前加载还是在初始化之后使用前加载,可以由加载器自己决定实现</li>
</ul>
</li>
</ul>
</li>
<li>初始化：给类的静态变量赋给定的初始值,这些操作和静态代码块会统一放置在类构造器<clinit>方法中,该方法只会执行一次.</clinit></li>
<li>使用：在实例构造器<init>方法中包含了代码分别为 父类的初始化方法-普通常量的初始化赋值-普通代码块-构造函数
<ul>
<li>主动使用-触发初始化:new 创建类的实例;访问类的静态变量或类方法;反射;初始化子类导致初始化父类</li>
<li>被动使用- 不会触发初始化:主动使用的一些例外
<ul>
<li>子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化</li>
<li>通过数组定义来引用类，不会触发此类的初始化,例如MyObject[] b = new MyObject[10];</li>
<li>常量字段编译期不确定：UUID.random().toString()</li>
<li>父类接口：一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中运行期才确定的常量）才会初始化</li>
</ul>
</li>
</ul>
</init></li>
<li>卸载：当MySample类被加载，连接和初始化后，它的生命周期就开始了。当代表MySample类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，MySample类在方法区内的数据也会被卸载，从而结束MySample类的生命周期。一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期</li>
</ul>
<blockquote>
<p>由Java虚拟机自带的加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。Java虚拟机自带的类加器包括根类加载器，扩展类加载器和系统类加载器。Java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始引用它们所加载的类的Class对象，因此这Class对象终是可及的。由用户自定义的类加载器所加载的类是可以被卸载的。</p>
</blockquote>
<p>父子类的执行顺序</p>
<ul>
<li>父类<clinit> 子类 <clinit> 虚拟机会保证 子类初始化之前 父类已经初始化defineClass</clinit></clinit></li>
<li>父类<init> 子类<init></init></init></li>
<li><init>:父类<init>+普通成员变量赋值+代码块+构造函数</init></init></li>
</ul>
<h2 id="类加载的委派机制">类加载的委派机制</h2>
<p>通常情况下有4种类加载器:</p>
<ul>
<li>Bootstrap classLoader 特定目录下,JavaHome/lib</li>
<li>Extension classLoader 特定目录下,JavaHome/lib/ext</li>
<li>Application classLoader ClassHome 下 以及 外部依赖</li>
<li>自定义类加载器</li>
</ul>
<p>ClassLoader.defineClass</p>
<blockquote>
<p>将字节流转化为class对象</p>
</blockquote>
<p>ClassLoader.loadClass</p>
<ul>
<li>首先调用findLoadedClass:寻找是否已经加载过该类,如果有则返回</li>
<li>如果无,那么存在父类加载器,则尝试调用父类加载器的loadClass ,那么调用bootstrap 加载器</li>
<li>如果还是找不到,会调用findClass(默认抛出classNotfiound异常,被继承后需要重写逻辑;UrlClassLoader中会根据全限定类名找到路径去加载)</li>
</ul>
<p>如果想违背父类机制</p>
<blockquote>
<p>那么重写loadClass方法,首先调用findLoadedClass  然后直接调用findClass</p>
</blockquote>
<h3 id="相同类的加载">相同类的加载</h3>
<p>利用不同的自定义类加载器实例 实现加载,通过实现不同的findClass方法实现加载,由于JVM 中通过类加载器和全限定类名来确保一个类的唯一性,所以类名字一致但不会重合</p>
<h3 id="钻石依赖">钻石依赖</h3>
<p>项目管理上有一个著名的概念叫着「钻石依赖」，是指软件依赖导致同一个软件包的两个版本需要共存而不能冲突。<br>
MAVEN</p>
<blockquote>
<p>maven 是这样解决钻石依赖的，它会从多个冲突的版本中选择一个来使用，如果不同的版本之间兼容性很糟糕，那么程序将无法正常编译运行。Maven 这种形式叫「扁平化」依赖管理。</p>
</blockquote>
<p>JVM</p>
<blockquote>
<p>使用 ClassLoader 可以解决钻石依赖问题。不同版本的软件包使用不同的 ClassLoader 来加载，位于不同 ClassLoader 中名称一样的类实际上是不同的类。</p>
</blockquote>
<h3 id="threadcontextclassloader">Thread.contextClassLoader</h3>
<p>首先 contextClassLoader 是那种需要显示使用的类加载器，如果你没有显示使用它，也就永远不会在任何地方用到它<br>
其次线程的 contextClassLoader 默认是从父线程那里继承过来的，所谓父线程就是创建了当前线程的线程。程序启动时的 main 线程的 contextClassLoader 就是 AppClassLoader。这意味着如果没有人工去设置，那么所有的线程的 contextClassLoader 都是 AppClassLoader。</p>
<p>用处</p>
<blockquote>
<p>如果不同的线程使用不同的 contextClassLoader，那么不同的线程使用的类就可以隔离开来。<br>
如果我们对业务进行划分，不同的业务使用不同的线程池，线程池内部共享同一个 contextClassLoader，线程池之间使用不同的 contextClassLoader，就可以很好的起到隔离保护的作用，避免类版本冲突。</p>
</blockquote>
<h3 id="类的运行时寻找机制">类的运行时寻找机制</h3>
<ul>
<li>java.lang.File 编译器会自动导入java.lang包</li>
<li>其他import 的包<br>
如果出现多个同名的类,编译器会报错</li>
</ul>
<h3 id="classloader-的传递性">classLoader 的传递性</h3>
<p>当程序在运行中遇到一个未知的类时,虚拟机会使用调用者的class对象的classLoader(class有该字段记录加载器)来加载当前类,通常情况下为系统加载器即AppClassLoader</p>
<h2 id="final-vs-static-vs-finally">final vs static vs finally</h2>
<blockquote>
<p>final 标识常量，创建或者初始化后不可更改，可以修饰 属性，方法（不可被重写），类（不可被继承），局部变量<br>
static 标识唯一性，可以修饰 变量，方法（与类的具体实例），代码段 （仅仅在类被初次加载的时候被调用一次，之后再调用不会再加载；如有父类先进行父类的初始化），不可修饰局部变量<br>
finally 是异常处理里的内容，try catch finally<br>
static final=final static：修饰的属性表示一旦给值，就不可修改，并且可以通过类名访问，也可以修饰方法，表示该方法不能重写</p>
</blockquote>
<h2 id="throws和throw">throws和throw</h2>
<blockquote>
<p>throws出现在方法函数头，可以跟多个异常类名，用逗号隔开，表示出现异常的一种可能性，并不一定会发生这些异常，由调用方去处理，当然也可以不处理，当产生异常，系统会报；<br>
而throw出现在函数体，是抛出了异常，执行throw则一定抛出了某种异常对象。<br>
两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</p>
</blockquote>
<h1 id="异常体系throwable">异常体系(throwable)</h1>
<blockquote>
<p><a href="https://blog.csdn.net/junlixxu/article/details/6096266" target="_blank" rel="noopener">java异常体系</a><br>
Java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类<br>
在Java API中已经定义了许多异常类，这些异常类分为两大类，错误Error和异常Exception</p>
</blockquote>
<h2 id="error">error</h2>
<blockquote>
<p>程序无法处理的错误,多与内存线程相关，比如OutOfMemoryErrorThreadDeath等。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</p>
</blockquote>
<h2 id="exception">Exception</h2>
<blockquote>
<p>Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常</p>
</blockquote>
<h3 id="运行时异常非受检异常">运行时异常(非受检异常)</h3>
<blockquote>
<p>个人理解 运行时才可能出现的异常,比如NullPointerException，IndexOutOfBoundsException，IllegalArgumentException,RuntimeException,InputMismatchException等,可以不处理，系统会统一处理，打出日志</p>
</blockquote>
<h3 id="非运行时异常受检异常checkexception">非运行时异常(受检异常:checkException)</h3>
<blockquote>
<p>系统在预编译检查时发现的错误,必须在编译前解决，否则无法编译成功，比如IOException、SQLException等以及用户自定义的Exception<br>
通过throws 要求调用者必须处理或者向上排除</p>
</blockquote>
<h2 id="异常处理">异常处理</h2>
<ul>
<li>try catch finally</li>
<li>throws 可能的Exception 有调用者处理</li>
<li>异常链的处理,避免异常覆盖：Throwable 里面有 cause同类型字段,可以保存构造异常时传递的根异常参数,实现异常链条</li>
</ul>
<h1 id="出现异常的处理方法">出现异常的处理方法</h1>
<p>top<br>
ps -ef<br>
gc<br>
iostat  查TCP 连接</p>
<h1 id="java-多线程-java多线程面试题">Java 多线程 <a href="https://blog.csdn.net/qq_36387471/article/details/105479238" target="_blank" rel="noopener">Java多线程面试题</a></h1>
<h1 id="java-spi机制是什么">Java SPI机制是什么？</h1>
<blockquote>
<p>SPI(service Provider  interface)是一种服务发现机制，提供服务接口，且为该接口寻找服务的实现<br>
约定：</p>
</blockquote>
<ul>
<li>当服务提供者提供了接口的一种具体实现后，在jar包的META-INF/services目录下创建一个以“接口全限定名”为命名的文件，内容为实现类的全限定名；</li>
<li>接口实现类所在的jar包放在主程序的classpath中；</li>
<li>主程序通过java.util.ServiceLoder动态装载实现模块，它通过扫描META-INF/services目录下的配置文件找到实现类的全限定名，把类加载到JVM；</li>
<li>SPI的实现类必须携带一个不带参数的构造方法；</li>
</ul>
<p>加载过程</p>
<ul>
<li>ServiceLoader 初始化</li>
<li>应用程序通过迭代器接口获取对象实例：首先判断是否有缓存实例对象,如果没有就通过反射加载对象并实例化,并把实例化对象缓存到provider,返回对象</li>
</ul>
<p>加载-&gt;验证-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载</p>
<p><a href="https://juejin.im/post/6844903633574690824" target="_blank" rel="noopener">JVM 类加载机制及双亲委派模型</a></p>
<h1 id="双亲委派模式">双亲委派模式</h1>
<p>类加载器</p>
<ul>
<li>启动（Bootstrap）类加载器：负责将 Java_Home/lib下面的类库加载到内存中（比如rt.jar）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作</li>
<li>标准扩展（Extension）类加载器：基于java是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将Java_Home /lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。</li>
<li>应用程序（Application）类加载器：基于java是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般称为系统（System）加载器。</li>
<li>自定义加载器<br>
该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，而这种父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）</li>
</ul>
<p>需要注意的是 对于任意一个类，都需要由加载它的类加载器和这个类本身共同确立其在Java虚拟机中的唯一性</p>
<p>双亲委派模型：</p>
<blockquote>
<p>某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。<br>
这样可以防止他人写的类替换掉系统的默认类</p>
</blockquote>
<p><a href="https://juejin.im/post/6844903806757502984" target="_blank" rel="noopener">java 循环依赖</a></p>
<p><a href="https://baijiahao.baidu.com/s?id=1667840029586081215" target="_blank" rel="noopener">内存屏障</a><br>
指令重排序</p>
<blockquote>
<p>对于单线程的指令,可能对指令重排序减少对于寄存器的反复读写操作,可以减少执行时间,而多线程下的指令重排序可能导致意外的错误,比如使用未初始化的变量</p>
</blockquote>
<p>内存一致性问题</p>
<blockquote>
<p>内存模型：对于多核CPU,每个核都使用高速缓存加快数据的读取(而不是每次都到主存存取),但是每个CPU的高速缓存必然是互相隔离的,可能出现共享变量副本不一致的情况<br>
一般有两种解决方案：</p>
</blockquote>
<ul>
<li>在总线上加锁的方式:在总线上发送busy信号,阻塞其他CPU对 与其他部件的访问 比如 内存,但是效率低下</li>
<li>缓存一致性协议：比如说inter的MESI 协议保证了每个缓存中使用的变量副本一致</li>
</ul>
<p>内存屏障分为两种</p>
<ul>
<li>load barrier：读屏障</li>
<li>Store barrier：写屏障</li>
</ul>
<p>内存屏障的作用</p>
<ul>
<li>阻止屏障两侧的指令重排序</li>
<li>写的时候,强制把缓冲区/高速缓存的数据写会内存,并让缓冲区的数据失效,读的时候需要从主存读取</li>
</ul>
<p>常见的内存屏障组合有4种</p>
<ul>
<li>LoadLoad屏障:保证屏障后的语句读取数据之前完成之前语句的读操作</li>
<li>StoreStore屏障：保证屏障后的写入操作执行之前,之前的写入操作的对其他处理器可见(获取最新结果)</li>
<li>LoadStore 屏障：保证屏障之后的写操作被执行完之前,之前读操作的结果必须完成</li>
<li>StoreLoad 屏障：保证之后的读操作执行之前,屏障之前的写操作的结果对其他处理器可见<br>
其中StoreLoad是核心 ,因为只有先写后读的操作顺序颠倒才会导致比较严重的后果</li>
</ul>
<p>volatile 与 内存屏障</p>
<ul>
<li>在每个volatile写操作之前插入StoreStore屏障,在其之后 插入StoreLoad屏障</li>
<li>在每个volatile读操作之前插入LoadLoad屏障,在其之后插入LoadStore屏障<br>
从而禁止了指令的重排序和内存的可见性</li>
</ul>
<p>提前担保机制</p>
<p>static synchronize VS synchronize</p>
<p>ZGC</p>
<p><a href="https://www.pianshen.com/article/38291243907/" target="_blank" rel="noopener">JVM里的记忆集合</a><br>
GC两个关键难点</p>
<ul>
<li>跨代引用：分带收集将对象分为老年代和年轻代,年轻代朝生夕死,YGC频繁发生,但是可能存在老年代引用新生代导致错误清除新生代对象</li>
<li>并发标记：stop-word方式的标记对系统影响大,且没有利用多核资源,故而采用并发标记,但是并发标记过程中存在对象的变化没有被感知的风险</li>
</ul>
<p>为了解决跨代引用,最简单的方法就是遍历所有的老年代对象,但是实际上只有少部分老年代对象对于年轻代对象有引用,这样效率很低：从而引入了&quot;记忆集&quot;的思想<br>
记忆集：记录非GC收集区域指向收集区域的抽象数据结构,具体而言就是记录内存空间是否存在记老年代对于新生代的引用状况,根据记录精度分为3种</p>
<ul>
<li>字长精度：每个记录精确到一个机器字长,该字中包含跨代指针</li>
<li>对象精度：每个记录精确到一个对象,该对象包含跨代指针字段</li>
<li>卡精度：每个记录精确到一块内存区域,该区域中包含跨代指针<br>
CMS 和 G1 中使用的是cardTable基于卡精度;卡表是个字节数组，每个字节对应堆空间老生代中的512个字节（这512个字节叫做卡页）是否有跨代引用</li>
</ul>
<p><a href="https://blog.csdn.net/MACRosshaha/article/details/108433196" target="_blank" rel="noopener">GC</a><br>
并发标记的可达性分析:<br>
三色标记：</p>
<ul>
<li>白色：尚未被垃圾收集器访问</li>
<li>黑色：已被访问,且该对象的所有引用已被扫描</li>
<li>灰色：已被访问,且至少存在一个对象未被扫描</li>
</ul>
<p>并发标记可能出现浮动垃圾和对象消失问题</p>
<blockquote>
<p>浮动垃圾:黑色对象的引用白色对象不再应用<br>
对象消失：新增白色对象被黑色对象引用,但没有拉入统计而被回收<br>
浮动垃圾的问题并不严重,数量不大而且可以下次回收;而对象消失可能干扰 系统的运行导致严重后果</p>
</blockquote>
<p>对象消失必然有两个前提：</p>
<ul>
<li>增加了黑色对象到该白色对象的引用</li>
<li>删除后了所有灰色对象对于到该白色对象的直接或者间接引用<br>
解决方法：</li>
<li>增量更新：记录新增的黑色对白色的引用,并发结束后,重新扫描</li>
<li>原始快照：在开始GC之前,对对对象之间的关系快照,涉及删除灰色到白色引用时备份引用,后面再扫描确认(此间产生的对象默认存活)<br>
两种方法 都通过写屏障 来实现记录的操作(并非内存屏障)<br>
<a href="https://cloud.tencent.com/developer/article/1599225" target="_blank" rel="noopener">G1回收器：我怎么知道你是什么时候的垃圾 垃圾回收详细过程</a></li>
</ul>
<p>高并发下 写屏障可能导致虚共享问题<br>
<a href="https://www.cnblogs.com/cyfonly/p/5800758.html" target="_blank" rel="noopener">false sharing</a> 并发杀手<br>
CPU 和 3级cache<br>
其中速度 L1&gt;L2&gt;L3; 空间L3&gt;L2&gt;L1<br>
每个cpu核有自己的L1 L2缓存,共享L3级缓存<br>
缓存中以缓存行(cache Line)作为单位存储,通常是64字节,一次性读取连续的64字节的数据,他有效隐射内存的一块地址<br>
当多线程所私有的变量处于同一个cache行时,会出现多线程轮番争用拥有权,并发变串行,同时该cache行的更改会将其他核高级cache行设置为失效,强制要求读取内存,即伪共享(可以通过<a href="http://ifeve.com/disruptor-cacheline-padding/" target="_blank" rel="noopener">缓存行填充</a>,使得自己的变量成为占满缓存行)<br>
而在G1通过配置要求判断是否已经为脏位,是脏位就无须再写,同时java中支持配置注解填充缓存行</p>
<p>java  泛型和 重写 继承的关系和缺陷<br>
<a href="https://www.cnblogs.com/wuqinglong/p/9456193.html" target="_blank" rel="noopener">Java泛型类型擦除以及类型擦除带来的问题</a><br>
<a href="http://blog.sina.com.cn/s/blog_7ffb8dd501012ku9.html" target="_blank" rel="noopener">泛型与类型擦除</a></p>
<blockquote>
<p>在代码阶段的重载检查和在JVM 阶段的检查<br>
如何实现泛型的多态</p>
</blockquote>
<p>Java 基础，集合类有哪些，全部说一遍</p>
<blockquote>
<p>四大类吧，分别是List、Queue、Set、Map</p>
</blockquote>
<ul>
<li>List：常见的有 ArrayList、LinkedList、Vector、CopyOnWriteArrayList</li>
<li>Queue：常见的有 ArrayDeque、PriorityQueue、ArrayBlockingQueue、LinkedBlockingQueue、DelayBlockingQueue等等</li>
<li>Map：HashMap、LinkedHashMap、TreeMap、ConcurrentHashMap等等</li>
<li>Set：HashSet、LinkedHashSet、TreeSet等</li>
</ul>
<p>JAVA的final字段</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/14/基础知识/论文阅读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/基础知识/论文阅读/" class="post-title-link" itemprop="url">论文阅读</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-14 19:12:45" itemprop="dateCreated datePublished" datetime="2020-06-14T19:12:45+08:00">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-30 13:25:24" itemprop="dateModified" datetime="2020-08-30T13:25:24+08:00">2020-08-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="大多是data-center-资源集中">大多是Data Center ,资源集中</h4>
<h4 id="cooperative-game-based-virtual-machine-resource-allocation-algorithms-in-cloud-data-centershindawi">Cooperative Game-Based Virtual Machine Resource Allocation Algorithms in Cloud Data Centers(hindawi)</h4>
<ol>
<li>Cloud Data Center(CDC)资源利用率低</li>
<li>思路：对不同资源使用不同的基于 value 的博弈论解决方法;
<ul>
<li>CPU: Shaply value(SV), payoff by number contribution</li>
<li>memory: weighted Shaply value(WSV),payoff by coliation ;and  members’s payoff about positive effort of coliation</li>
<li>storage: proportional Shaply value(PSV)</li>
<li>bandwith: weigthed-egalitarian Shaply value(WESV) payoff by member contribution and  heterogeneity between members</li>
</ul>
</li>
<li>不足：
<ul>
<li>task 生成分为四类,每类的资源要求固定(task 不具有 变动性)</li>
<li>数据未公开</li>
<li>未解释 四类资源某些不足时的处理???</li>
</ul>
</li>
</ol>
<h4 id="game-theoretic-resource-allocation-in-cloud-computing">Game theoretic resource allocation in cloud computing</h4>
<ol>
<li>介绍：同名书中的相干章节，基于Min-Max Game
<ul>
<li>输入：request的信息，resource的信息</li>
<li>输出：分配矩阵</li>
</ul>
</li>
<li>思路：实现最大化资源的 utility(效用) 的目标；</li>
<li>utility 的公式构成(又分为单类资源utility和全局资源utility) ?? 不同资源,CPU
<ul>
<li>budget</li>
<li>cost per sencod</li>
<li>request 量</li>
<li>request time 消耗时间</li>
<li>budget和time的factor因子</li>
</ul>
</li>
<li>算法：
<ul>
<li>挑选出可以进行博弈的request</li>
<li>依次对每一种资源选择全局最大化utility时的分配，iteration</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/11/工具/毕设/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/11/工具/毕设/" class="post-title-link" itemprop="url">毕设实验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-11 19:12:45" itemprop="dateCreated datePublished" datetime="2020-06-11T19:12:45+08:00">2020-06-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-30 13:26:47" itemprop="dateModified" datetime="2020-08-30T13:26:47+08:00">2020-08-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>##实验分类：</p>
<ol>
<li>小规模 系统搭建(请求链条不需要长)</li>
<li>大规模仿真模拟(可以模拟长请求链和大规模，大流量)</li>
</ol>
<p>###小规模系统构成：</p>
<ol>
<li>请求发送者(微服务的benchmark 附带流量)</li>
<li>微服务benchmark/请求处理
<ul>
<li>服务链确定</li>
<li>流量监控(istio)</li>
</ul>
</li>
<li>决策中心(初次放置,调整): 博弈论均衡
<ul>
<li>思路：
<ul>
<li>分类</li>
<li>加权 集中</li>
</ul>
</li>
<li>放置：资源充足时, 参数 服务链(整体时延) &gt; 资源使用集中程度(避免资源过度集中于某些machine,也避免过度分散)</li>
<li>缩容：谨慎，按照kubeneats自带策略/长期监控流量,然后决策调整</li>
<li>扩容：存在多服务链扩容,博弈论
<ul>
<li>资源不冲突，分配</li>
<li>资源冲突，考虑优先级, 其他参数 资源利用率,资源集中程度<br>
###大规模仿真模拟</li>
</ul>
</li>
</ul>
</li>
<li>工具：CloudSim(docker)</li>
<li>微服务的指标细化(QOS,基本资源需求,基本处理能力)</li>
<li>流量构造(常规多样流量；突发大规模流量)</li>
</ol>
<p>###目标：</p>
<ol>
<li>满足已存在的QOS 要求(根据流量调整实例的部署，扩缩容)</li>
<li>资源利用率</li>
<li>性能表现(latency,稳定性)</li>
</ol>
<p>###问题：</p>
<ol>
<li>利用博弈论简化问题，
<ul>
<li>只考虑了部署实例的问题，没有考虑具体资源的供给(如何量化的问题),</li>
<li>暂时没有考虑后续的伸缩</li>
<li>未考虑 资源不集中</li>
</ul>
</li>
<li>平衡不是目标，平衡是为了降低干扰，我的目标是提高QOS，稳定性，提高资源利用率，降低资源占有率</li>
<li>长请求链的实际存在依据(实际运行中的每个环节都是请求链的一环)：更多例子</li>
<li>微服务benchmark的自带流量测试比较简单/不够复杂和波动，需要重新构造设计</li>
</ol>
<p>已完成：</p>
<ol>
<li>benchmark:<br>
1.1 已部署 <a href="https://github.com/microservices-demo/microservices-demo" target="_blank" rel="noopener">Sock-Shop</a> <a href="https://github.com/GoogleCloudPlatform/microservices-demo" target="_blank" rel="noopener">Hipster</a> <a href="https://github.com/FudanSELab/train-ticket/wiki" target="_blank" rel="noopener">Train-Ticket</a> <a href="https://github.com/delimitrou/DeathStarBench" target="_blank" rel="noopener">DeahStarBench</a></li>
</ol>
<p>1.2 待部署 <a href="https://github.com/dream-lab/riot-bench" target="_blank" rel="noopener">Riot</a></p>
<ol start="2">
<li>决策中心<br>
2.1 熟悉了解 <a href="https://www.coursera.org/learn/game-theory-1/" target="_blank" rel="noopener">博弈论理论</a><br>
2.2 算法实现，需要想清楚问题</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/14/基础知识/源码阅读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/14/基础知识/源码阅读/" class="post-title-link" itemprop="url">源码阅读</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-14 21:16:59" itemprop="dateCreated datePublished" datetime="2020-04-14T21:16:59+08:00">2020-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-30 13:18:55" itemprop="dateModified" datetime="2020-08-30T13:18:55+08:00">2020-08-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>docker</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/zyDGaT6SGFUVU60r9L7S3Q?" target="_blank" rel="noopener">参考博客1</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/31/基础知识/云计算模拟/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/31/基础知识/云计算模拟/" class="post-title-link" itemprop="url">云计算模拟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-31 19:47:06" itemprop="dateCreated datePublished" datetime="2020-03-31T19:47:06+08:00">2020-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-30 13:18:55" itemprop="dateModified" datetime="2020-08-30T13:18:55+08:00">2020-08-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>毕业设计需要对于大型云计算环境进行模拟，经过调研，决定使用<a href="http://www.cloudbus.org/cloudsim/" target="_blank" rel="noopener">CloudSim</a> <a href="https://github.com/Cloudslab/cloudsim" target="_blank" rel="noopener">Github</a></p>
<p>CloudSim是在离散事件模拟包SimJava上开发的函数库,可以直接当做Java工程使用，即导入IDEA<br>
<a href="https://www.cnblogs.com/sddai/p/6036893.html" target="_blank" rel="noopener">国内比较全的关于CloudSim的介绍</a><br>
<a href="https://www.cnblogs.com/xxfna/articles/9563068.html" target="_blank" rel="noopener">如何将CloudSim导入IDEA</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/13/基础知识/linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="夸父">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行合一">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/13/基础知识/linux/" class="post-title-link" itemprop="url">linux</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-13 10:57:57" itemprop="dateCreated datePublished" datetime="2020-01-13T10:57:57+08:00">2020-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-30 13:19:27" itemprop="dateModified" datetime="2020-08-30T13:19:27+08:00">2020-08-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本问用于记录linux常用的命令</p>
<p>ssh</p>
<p>scp</p>
<blockquote>
<p>在两个服务器之间传输文件<br>
rz<br>
传输本地文件到服务器<br>
sz [filename]<br>
传输服务器文件到本地</p>
</blockquote>
<p>find [PATH] [option]</p>
<blockquote>
<p>在指定目录下查找相关文件<br>
example : find . -name “name”</p>
</blockquote>
<p>tail [file] [option]</p>
<blockquote>
<p>从后开始查询文件，默认查询最后十行<br>
tail -n 100 nohup.log</p>
</blockquote>
<p>cat/touch<br>
netstat<br>
telnet<br>
chown/chmod/chgrp<br>
useradd</p>
<p>配置 <a href="https://wiki.archlinux.org/index.php/Readline" target="_blank" rel="noopener">命令自动补全</a></p>
<blockquote>
<p>配置 ~/.inputrc 文件</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="夸父"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">夸父</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">101</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">56</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/walkdeadtobe" title="GitHub → https://github.com/walkdeadtobe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">京ICP备2020045262号 </a>
      <img src="/images/gongan.png" style="display: inline-block;"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010802033764" rel="noopener" target="_blank">京公网安备 11010802033764 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chengr</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
