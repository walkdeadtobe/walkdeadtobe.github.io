<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="第1章 概述 概念 分布式存储系统  大量普通PC服务器通过Internet互联,对外作为一个整体提供存储服务  特性  可扩展:在扩展的同时,性能也线性提升 低成本:基于分布式存储系统的自动容错以及负载均衡功能使得其可以在普通机器上扩展 高性能: 易用性:分布式存储系统要求对外提供易用的外部接口,同时具备完备的监控和运维功能,并支持与其他系统集成  分布式存储系统的挑战在于数据、状态信息的持久化">
<meta name="keywords" content="书籍">
<meta property="og:type" content="article">
<meta property="og:title" content="大规模分布式存储系统">
<meta property="og:url" content="http://yoursite.com/2020/11/19/分布式/书籍阅读笔记/大规模分布式存储系统-原理解析与架构实战/index.html">
<meta property="og:site_name" content="面向对象编程">
<meta property="og:description" content="第1章 概述 概念 分布式存储系统  大量普通PC服务器通过Internet互联,对外作为一个整体提供存储服务  特性  可扩展:在扩展的同时,性能也线性提升 低成本:基于分布式存储系统的自动容错以及负载均衡功能使得其可以在普通机器上扩展 高性能: 易用性:分布式存储系统要求对外提供易用的外部接口,同时具备完备的监控和运维功能,并支持与其他系统集成  分布式存储系统的挑战在于数据、状态信息的持久化">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2020-11-29T15:25:14.134Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大规模分布式存储系统">
<meta name="twitter:description" content="第1章 概述 概念 分布式存储系统  大量普通PC服务器通过Internet互联,对外作为一个整体提供存储服务  特性  可扩展:在扩展的同时,性能也线性提升 低成本:基于分布式存储系统的自动容错以及负载均衡功能使得其可以在普通机器上扩展 高性能: 易用性:分布式存储系统要求对外提供易用的外部接口,同时具备完备的监控和运维功能,并支持与其他系统集成  分布式存储系统的挑战在于数据、状态信息的持久化">

<link rel="canonical" href="http://yoursite.com/2020/11/19/分布式/书籍阅读笔记/大规模分布式存储系统-原理解析与架构实战/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>大规模分布式存储系统 | 面向对象编程</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">面向对象编程</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/19/分布式/书籍阅读笔记/大规模分布式存储系统-原理解析与架构实战/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chengr">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="面向对象编程">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          大规模分布式存储系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-19 18:57:50" itemprop="dateCreated datePublished" datetime="2020-11-19T18:57:50+08:00">2020-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-29 23:25:14" itemprop="dateModified" datetime="2020-11-29T23:25:14+08:00">2020-11-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="第1章-概述">第1章 概述</h2>
<h3 id="概念">概念</h3>
<p>分布式存储系统</p>
<blockquote>
<p>大量普通PC服务器通过Internet互联,对外作为一个整体提供存储服务</p>
</blockquote>
<p>特性</p>
<ul>
<li>可扩展:在扩展的同时,性能也线性提升</li>
<li>低成本:基于分布式存储系统的自动容错以及负载均衡功能使得其可以在普通机器上扩展</li>
<li>高性能:</li>
<li>易用性:分布式存储系统要求对外提供易用的外部接口,同时具备完备的监控和运维功能,并支持与其他系统集成</li>
</ul>
<p>分布式存储系统的挑战在于数据、状态信息的持久化,要求在自动化、自动容错、并发读写的过程中保证数据的一致性.分布式存储涉及的技术主要来自于两个领域:分布式系统和数据库,分类如下</p>
<ul>
<li>数据分布:如何均匀地将数据分布到多台服务器,又如何实现跨服务器的读写服务</li>
<li>一致性:在分布式系统中,会存在一份数据的多个副本存在于多个服务器,如何管理副本同时保证不同副本之间的数据一致性?</li>
<li>容错:如何检测服务器故障,在检测到错误之后如何迁移数据到安全的服务器</li>
<li>负载均衡:在日常运行以及服务器上下线时如何保证负载均衡,在迁移的过程中如何保证不影响已有服务?</li>
<li>事务并发和控制:实现分布式事务?如何实现多版本并发控制?</li>
<li>易用性:</li>
<li>压缩/解压缩:如何根据数据的特点设计压缩和解压缩算法,如何平衡压缩算法的存储资源和CPU资源消耗?</li>
</ul>
<h3 id="分布式存储分类">分布式存储分类</h3>
<p>分布式存储数据的类型</p>
<ul>
<li>非结构化数据:包括文档、文本、图片、影响、音频和视频信息等</li>
<li>结构化数据:一般存储在关系数据库中</li>
<li>半结构化数据:介于结构化数据和非结构化数据之间;例如HTML,不需要预设规则,可以自描述</li>
</ul>
<p>不同的分布式存储系统适合处理不同的数据类型,文中将分布式存储系统分为四类:分布式文件系统,分布式键值系统,分布式表格系统,分布式数据库</p>
<h4 id="分布式文件系统">分布式文件系统</h4>
<p>互联网需要存储大量的非结构化数据,例如图片、视频等,称之为Blob(Binary Large Object);<br>
典型:Facebook Haystack 、 Taobao File System 、Google File System</p>
<h4 id="分布式键值系统">分布式键值系统</h4>
<p>分布式键值系统用于存储关系简单的半结构化数据,提供基于主键的CRUD功能.</p>
<h4 id="分布式表格系统">分布式表格系统</h4>
<p>存储关系较为复杂的半结构化数据<br>
典型系统: Google Bigtable 、 Megastore</p>
<h4 id="分布式数据库">分布式数据库</h4>
<p>一般从单机数据库扩展而来,用于存储结构化数据<br>
典型系统:Mysql Sharding 、Amazon RDS 、 Microsoft SQL Azure</p>
<p>基础篇</p>
<ul>
<li>第2章 单机存储系统</li>
<li>第3章 分布式存储系统</li>
</ul>
<h2 id="第2章-单机存储系统">第2章 单机存储系统</h2>
<h3 id="21-硬件基础">2.1 硬件基础</h3>
<h3 id="22-单机存储引擎">2.2 单机存储引擎</h3>
<blockquote>
<p>存储引擎是存储系统的发动机,直接决定了存储系统能够提供的性能和功能.<br>
存储系统的基本功能包括:增删读改,读取操作又分为随机读取和顺序扫描.</p>
</blockquote>
<p>哈希存储引擎是哈希表的持久化实现,支持增删盖和随机读取,不支持顺序扫描,对应的存储系统是键值存储系统<br>
B树存储引擎是B树的持久化实现,不仅支持单条数据的增删改查,还支持顺序扫描(范围查询),对应的存储系统是关系数据库<br>
LSM(Log_structured Merge Tree)存储引擎与B树存储引擎一样,支持单条数据的增删读改,也支持顺序扫描,其通过批量转储技术规避磁盘随机写入问题,广泛用于互联网的后台存储系统.例如Google Bigtable 、Google LevelDB、Cassandra</p>
<h4 id="221-哈希存储引擎">2.2.1 哈希存储引擎</h4>
<p>Bitcask</p>
<h4 id="222-b树存储引擎">2.2.2 B树存储引擎</h4>
<p>Mysql Innodb</p>
<h4 id="223-lsm树存储引擎">2.2.3 LSM树存储引擎</h4>
<p>典型 Level DB<br>
其思想是将数据的修改增量保持在内存中,达到指定的大小限制后,将这些修改操作批量写入磁盘,读取时需要合并磁盘中的历史数据和内存中最近的修改操作;尽管避免了磁盘随机写入的问题,但是在读取时会访问比较多的磁盘文件</p>
<h3 id="23-数据模型">2.3 数据模型</h3>
<p>如果存储引擎相当于存储系统的发动机,那么数据局模型相当于存储系统的外壳.<br>
存储系统的数据模型主要包括3类:文件、关系、键值模型</p>
<h4 id="231-文件模型">2.3.1 文件模型</h4>
<p>文件模型以目录树的形式组织文件,包含打开/关闭、读取/写入文件的操作,包括打开/关闭目录,遍历目录的操作<br>
在单机文件系统的标准,例如POSIX 要求在并发时保证操作的原子性(例如读操作不能读取到脏数据);但是在分布式文件系统中,处于性能考虑,不遵守该标准;例如NFS(Network File System) 允许客户端缓存文件数据,多个客户端修改同一个文件容易出现不一致的问题.<br>
对象模型与文件模型有些相似,用于存储图片、视频、文件等二进制数据块,典型的包括Amazon Simple Storage(S3), Taobao File System(TFS),这些系统弱化了目录树的概念,S3只支持一级目录,不支持子目录,TFS甚至不支持目录结构.同时与文件模型不同,对象模型要求对象一次性写入到系统,修改时只能删除整个对象,无法部分修改.</p>
<h4 id="232-关系模型">2.3.2 关系模型</h4>
<p>每个关系都会一个表格,由多个元组(行)构成,而每个元组又包含多个属性(列).关系名、属性名以及属性类型称之为该关系的模式(scheme);<br>
数据库的SQL语言用于描述查询和修改操作<br>
此外,SQL还包含两个重要特性,索引以及事务;索引可以降低查询时需要扫描的数据量,而事务是保证各个数据操作过程中,多操作并发的ACID(原子性 一致性 隔离性 持久性)</p>
<h4 id="233-键值模型">2.3.3 键值模型</h4>
<p>大量的NOSQL系统采取的键值模型,每行记录由主键和值两部分构成,支持基于主键的PUT、GET、DELETE操作<br>
由于键值模型比较简单,支持的应用场景有限,NOSQL 系统中使用较为广泛的模型表格型</p>
<blockquote>
<p>表格模型弱化了关系模型中的多表关联,支持基于单表的简单操作,典型的系统包括Google BigTable 和 HBase.</p>
</blockquote>
<p>表格模型除了支持简单的基于主键的操作之外,还支持范围扫描,也支持基于列的操作</p>
<h4 id="234-sql-和-nosql">2.3.4 SQL 和 NOSQL</h4>
<p>随着互联网的快速发展,数据规模越来越大,并发量也越来越高,关系数据的应对这样的需求有些力不从心,而非关系数据库NOSQL(Not Only SQL),带来许多新的理念,比如良好的可扩展性,弱化数据库的设计范式,降低一致性的要求,一定程·度上解决del海量数据和高并发的问题,但是需要注意的是NOSQL只是对于SQL特性的一种取舍和升华,使得SQL更加适应于海量数据的应用场景.<br>
关系数据库在海量数据中面临的挑战</p>
<ul>
<li>事务:关系模型要求多个SQL操作满足ACID特性,所有的SQL操作要么都成功要么都失败;但是在分布式系统中,如果多操作属于不同的服务器,那么他们的原子性需要二阶段提交协议保证,但是该协议无法保证高性能,也不能应对单机故障.</li>
<li>联表:关系数据库为了避免出现数据冗余的情况,会利用范式进行限制,这样会出现频繁的联表操作,但是海量数据的场景中,为了避免联表操作带来的性能损失,会使用数据冗余等违反范式的方法.</li>
<li>性能:关系数据库使用B树存储引擎,其更新性能不如LSM树,此外,在只有基于主键的增删查改的场景中,其性能又不如键值存储系统</li>
</ul>
<p>随着数据规模越来越大,NOSQL 数据库广泛应用于互联网业务中,但是其也面临如下问题</p>
<ul>
<li>缺乏统一标准:关系数据库经过几十年的发展已经形成SQL语言这样的业界标准,也有了完善的生态链;而现在的NOSQL 系统的使用方法不同,切换成本高,很难通用.</li>
<li>使用以及运维复杂:NOSQL系统无论选型还是使用方式,都有很大的学问,往往需要理解系统的实现,缺乏专业的运维工具和人员</li>
</ul>
<h3 id="24-事务和并发控制">2.4 事务和并发控制</h3>
<h3 id="25-故障恢复">2.5 故障恢复</h3>
<p>数据库运行过程中会出现故障,事务可能执行到一半没有提交,而系统重启时,需要恢复一致的状态,即要么提交整个事务,要么回滚.<br>
数据库系统以及其他分布式存储系统一般采用操作日志的技术来实现故障恢复.<br>
操作日志分为回滚日志(记录事务修改之前的状态)、重做日志(记录事务修改之后的状态)</p>
<h4 id="251-操作日志">2.5.1 操作日志</h4>
<h4 id="252-重做日志">2.5.2 重做日志</h4>
<ol>
<li>成组提交</li>
<li>检查点</li>
</ol>
<h3 id="26-数据压缩">2.6 数据压缩</h3>
<p>数据压缩分为两种,有损压缩和无损压缩,前者压缩比例高,但是有可能失真,一般用于压缩图片、视频、音频;而无损压缩算法可以完全还原原始数据,一般适用于文本.<br>
早期的压缩技术是基于编码上的优化技术,其中以霍夫曼编码最为知名.后面的<a href="https://baike.baidu.com/item/LZ%E7%BC%96%E7%A0%81/3155215" target="_blank" rel="noopener">LZ</a>系列压缩算法几乎通用无损压缩领域.</p>
<h4 id="261-压缩算法">2.6.1 压缩算法</h4>
<h4 id="262-列式存储">2.6.2 列式存储</h4>
<p>传统的行式存储是将一个个完整的数据行存储在数据页中,在查询需要大多数的列时,磁盘IO是高效的;但是一次查询涉及几百万甚至亿级行数据的,且仅关心少数几个列时,这种磁盘IO很难说是高效的.这种情况下,列式数据库更加高效.<br>
列式数据库是将同一个数据列的各个值存放在一起/一行,插入某行时,该行的各个数据列的值也会存放到不同的地方;当需要获取某个行的全部数据时,需要从不同的地方读取各个数据列的值,然后合并成数据行,所以对于涉及量较小的查询或者大部分查询都需要整行的数据的查询,列式数据库并不适用.</p>
<h2 id="第3章-分布式存储系统">第3章 分布式存储系统</h2>
<p>分布式系统面临的第一个问题就是数据分布,即将数据均匀的分布到多个存储节点.另外为了保证可靠性和可用性,需要将数据复制成多个副本,这就带来了多个副本之间数据一致性的问题.此外,大规模分布式系统的重要目标是节省成本,大多采用性价比更高而非可靠性更高的服务器,因而在软件层面需要应对服务器故障的问题,达到容错的目标.<br>
分布式系统中有两个重要协议,Paxos选举协议和两阶段提交协议.<br>
Paxos协议用于多个节点之间达成一致,往往仅用于实现总控节点选举,因为用于日常事务提交会降低效率.二阶段提交协议用于保证跨多个节点操作的原子性.</p>
<h3 id="31-基本概念">3.1 基本概念</h3>
<h4 id="311-异常">3.1.1 异常</h4>
<h4 id="312-一致性">3.1.2 一致性</h4>
<p>由于异常的存在,分布式存储系统一般会将数据冗余存储多份,每一份称之为副本.如此在一个节点出现故障时,可以从其他节点的副本中读取数据.<br>
副本是分布式存储系统容错技术的唯一手段,因而如何保证多个副本之间的一致性是分布式理论核心.<br>
可以从两个角度来理解一致性:操作的一致性和存储的一致性<br>
一致性具体又可以分为强一致性、弱一致性、最终一致性.</p>
<ul>
<li>强一致性:对一个副本的操作,要求同样在其他副本生效</li>
<li>弱一致性:对一个副本的操作,不要求在其他副本上生效</li>
<li>最终一致性:是弱一致性的一种特例,对一个副本的操作,保证在一定的时间窗口内同样会在其他副本中生效</li>
</ul>
<p>从存储系统的角度,一致性 主要分为如下几个方面</p>
<ul>
<li>副本一致性:存储系统的多个副本之间的数据是否一致,不一致的时间窗口又是怎样的等</li>
<li>更新顺序一致性:存储系统的多个副本之间是否按照相同的顺序执行更新操作</li>
</ul>
<h4 id="313-衡量标准">3.1.3 衡量标准</h4>
<p>性能:系统的吞吐能力和响应时间 例如 QPS(query per second) TPS(transaction per second) 和 系统的响应延迟,高吞吐和低延迟之间需要取舍和权衡<br>
可用性:系统在面临各种异常时可以提供正常服务的能力,通常可以用系统停服的时间和正常提供服务的时间的比例来衡量<br>
一致性:<br>
可扩展性:</p>
<h3 id="32-性能分析">3.2 性能分析</h3>
<h3 id="33-数据分布">3.3 数据分布</h3>
<p>分布式系统与传统系统的区别在于将数据分布到多个节点,并在多个节点之间实现负载均衡<br>
数据分布的方式主要有两种,哈希分布和顺序分布</p>
<ul>
<li>哈希分布:例如一致性哈希,Amazon的Dynamo系统</li>
<li>顺序分布:即每张表格上的数据按照主键整体有序,例如Google的Bigtable系统</li>
</ul>
<h4 id="331-哈希分布">3.3.1 哈希分布</h4>
<p>只支持随机读写,使用场景包括:某些互联网应用根据用户进行数据拆分,可以通过哈希方法进行数据分布,同一个用户的数据将分布到同一个节点,支持对于同一个用户的数据进行顺序扫描,涉及多个用户的数据由应用层解决.<br>
数据倾斜<br>
节点上下线时的数据迁移</p>
<h4 id="332-顺序分布">3.3.2 顺序分布</h4>
<p>哈希分布破坏了数据的有序性,只支持随机读取操作,不支持顺序扫描.<br>
顺序分布在分布式表格系统中比较常见,一般的做法是将大表顺序划分为连续的范围,每一个范围称为一个子表,总控服务器按照一定的策略将这些子表分配到存储节点.<br>
同时由于数据的插入和删除,会导致某些子表大小偏离正常标准太多,太大或者太小,系统还需要考虑子表的分裂与合并.</p>
<h4 id="333-负载均衡">3.3.3 负载均衡</h4>
<p>分布式存储系统的每个集群中一般会有一个总控节点,其他节点为工作节点,由总控节点根据全局负载信息进行整体调度.<br>
在节点上下线以及数据增删的情况下,总控节点需要将数据从负载较高的节点迁移至负载较低的节点.<br>
工作节点通过心跳包将节点负载相关的信息例如CPU 磁盘 内存 网络等资源利用率,读写次数和读写数据量等数据发送给总控节点.总控节点根据全局信息调节负载.</p>
<h3 id="34-复制">3.4 复制</h3>
<p>为了保证分布式存储系统的高可靠和高可用,数据在系统中一般存储多个副本,分布式存储系统通过复制协议将数据同步到多个节点,并保证多个副本之间的数据一致性.<br>
同一个数据的多个副本中有一个主副本,其他为备副本,由主副本将数据复制到备副本.<br>
复制协议分为两种,强复制协议以及异步复制,两者的区别在于用户的写请求是否需要同步到各副本之后才可以返回成功.</p>
<h4 id="341-复制的概述">3.4.1 复制的概述</h4>
<p>利用操作日志(commit log)实现主副本到备副本的复制;基于Quorum机制的NWR协议</p>
<h4 id="342-一致性和可用性">3.4.2 一致性和可用性</h4>
<p>CAP理论</p>
<h3 id="35-容错">3.5 容错</h3>
<h4 id="351-常见故障">3.5.1 常见故障</h4>
<h4 id="352-故障检测">3.5.2 故障检测</h4>
<p>心跳机制检测<br>
租约机制(带有超时时间的授权)检测</p>
<h4 id="353-故障恢复">3.5.3 故障恢复</h4>
<h3 id="36-可扩展性">3.6 可扩展性</h3>
<h4 id="361-总控节点">3.6.1 总控节点</h4>
<h4 id="362-数据库扩容">3.6.2 数据库扩容</h4>
<h4 id="363-异构系统">3.6.3 异构系统</h4>
<p>同一个组内的节点存储同一个服务的数据,这样的系统称之为同构系统,同构系统的问题在于增加副本所导致的数据传输发生只在对应的组之间,由于带宽的限制,导致传输时间长,因而增加故障发生的概率</p>
<h3 id="37-分布式协议">3.7 分布式协议</h3>
<h4 id="371-两阶段提交协议">3.7.1 两阶段提交协议</h4>
<p>节点分类:协调者和事务参与者<br>
阶段:请求阶段(协商确认阶段) 和 提交阶段</p>
<h4 id="372-paxos">3.7.2 Paxos</h4>
<h4 id="373-paxos-和-2pc">3.7.3 Paxos 和 2PC</h4>
<p>在分布式系统中,Paxos 用于保证多个副本之间的数据一致性,而2PC保证了跨节点/数据分片的操作的原子性</p>
<h3 id="38-跨机房部署">3.8  跨机房部署</h3>
<p>//## 第二篇 范型篇</p>
<h2 id="第4章-分布式文件系统">第4章 分布式文件系统</h2>
<p>分布式文件系统的功能主要有两个,一个是存储文档、图像、视频之类的Blob类型数据,另一个是分布式表格系统的持久化存储层<br>
分布式文件系统中最著名的是GFS(Google file System),它构建在廉价的PC服务器之上,支持自动容错.GFS内部将大文件划分为大小约64MB的数据块(chunk),并通过主控服务器(Master)实现元数据管理、副本管理、自动负载均衡等操作.其他的分布式文件系统包括Tabao File System(TFS)、Facebook Haystack</p>
<h3 id="41-gfs">4.1 GFS</h3>
<h4 id="411-系统架构">4.1.1 系统架构</h4>
<p>GFS系统的节点可以分为三种角色:GFS Master(主控服务器)、GFS ChunkServer(CS,数据块服务器)以及GFS客户端<br>
GFS文件被划分为固定大小的数据块(chunk),由主服务器在创建时分配一个64位全局唯一的chunk句柄.CS以普通的Linux文件的形式将chunk存储在磁盘中.为了保证可靠性,chunk在不同的机器中复制多份,默认为三份.<br>
主服务器中维护了系统的元数据,包括文件及chunk命名空、文件到chunk的映射、chunk位置信息.他也负责整个系统的全局控制,如chunk租约管理、垃圾回收无用chunk、chunk复制等.主控服务器会定期与CS通过心跳的方式交换信息.</p>
<p>客户端是GFS提供给应用程序的访问接口,它是一组专用接口,以库文件的形式提供.客户端访问GFS时,首先访问主控服务节点,获取与之交互信息的CS信息,然后直接访问这些CS,完成数据存取工作.</p>
<p>需要注意的是,GFS客户端不缓存文件数据,只缓存从主控服务器中获取的元数据,这是GFS的应用特点决定的.<br>
GFS主要的应用是MapReduce 和 Bigtable,对于MapReduce ,GFS客户端使用方式为顺序读写,没有缓存文件的必要;而BigTable作为分布式表格系统,内部实现了缓存机制.</p>
<h4 id="412-关键问题">4.1.2 关键问题</h4>
<ol>
<li>租约机制</li>
</ol>
<blockquote>
<p>GFS数据追加以记录为单位,每个记录的大小为几十KB到几MB不等,如果 每个记录追加都请求master,会让master成为系统性能瓶颈.因此GFS中通过租约(lease)机制将chunk写操作授权给ChunkServer.<br>
拥有授权的ChunkServer称为主ChunkServer,其他ChunkServer称为备ChunkServer.租约授权针对单个chunk,在租约有效期内对于该chunk的写操作都由主ChunkServer负责,从而减轻Master的负载.租约的有效期一般比较长,且在没有异常的情况下,主ChunkServer可以不断向Master请求延长租约的有效期直至整个chunk写满<br>
例子:对于chunk的多个副本都有自己的版本号,每次对于副本的更新以及租约授权和延长租约时都会增加版本号,版本号低的副本会被Master标记成可删除,当定时垃圾回收任务触发时,会通知ChunkServer回收之</p>
</blockquote>
<ol start="2">
<li>一致性模型</li>
</ol>
<blockquote>
<p>GFS主要是为了追加而不是改写设计的.一方面是因为改写的需求比较小或者可以通过追加实现,另一方面追加的一致性模型相对更为简单(部分副本追加失败的后果是存在读过期数据的可能,而改写的后果是不正确的数据)<br>
理想情况下,追加成功的记录会在GFS的各个副本中存在而且严格一致;但是如果出现异常,可能出现某些副本追加成功而某些副本没有成功,失败的副本可能会出现一些可识别的填充记录.由于客户端在追加失败后会重试,导致某些记录在某些副本中被追加多次;在并发追加的情况下,客户端连续发出的追加操作在chunk副本上并不一定是连续执行的,中间可能夹杂其他客户端的追加操作;应用层对于这些异常情况应当加以识别和处理.</p>
</blockquote>
<ol start="3">
<li>追加流程</li>
</ol>
<blockquote>
<p>GFS追加的过程中,将控制流和数据流分开<br>
1)客户端向Master请求chunk每个副本所在的ChunkServer,其中主ChunkServer持有修改租约.如果没有CHunkServer持有租约,那么意味着该chunk最近没有写操作,Master会发起一个任务,按照一定的策略将chunk的租约授权给其中一台ChunkServer.<br>
2)Master返回客户端主副本和备副本所在的ChunkServer的位置信息,客户端会缓存这些信息供以后使用.如果不出现故障,客户端之后写该chunk不需要再次请求Master.<br>
3)客户端将追加的记录发送到每一个副本.每一个ChunkServer会在内部的LRU结构中缓存这些数据.GFS中采用数据流和控制流分离的方法,从而能够基于网络拓扑结构更好地调度数据流的传输.<br>
4)当所有的副本都确定收到了数据,客户端会发起一个写请求控制命令给主副本.由于主副本可能收到多个客户端对于同一个chunk的并发追加操作,主副本将确定这些操作的顺序并写入本地.<br>
5)主副本将写请求提交给所有的备副本.每个备副本会根据主副本确定的顺序将执行写操作.<br>
6)各备副本成功后应答主副本.<br>
7)主副本应答客户端,如果有副本发生错误,将出现主副本写成功但是某些备副本写不成功的情况,客户端将重试.</p>
</blockquote>
<p>GFS追加流程有两个特色:流水线及分离数据流与控制流.<br>
流水线操作</p>
<blockquote>
<p>当一个ChunkServer接受到一些数据时,它就立刻开始转发;由于全双工网络的特性,发送数据不会影响接受数据.</p>
</blockquote>
<p>分离数据流和控制流</p>
<blockquote>
<p>分离可以优化数据传输,控制流应该按照主副本到备副本的方向,而数据流可以依照网络拓扑向时延最小的ChunkServer发送数据.<br>
需要注意的是,分离会导致追加流程控制的复杂性,所以分离的前提是每次追加的数据都比较大,所以分离有优化效果</p>
</blockquote>
<p>异常情况:</p>
<ul>
<li>追加的过程中,出现主副本租约过期而失去chunk修改操作的授权</li>
<li>主副本或者备副本所在的ChunkServer出现故障</li>
</ul>
<ol start="4">
<li>容错机制</li>
</ol>
<p>Master容错</p>
<ul>
<li>通过操作日志以及checkpoint的方式保存状态</li>
</ul>
<blockquote>
<p>Master 保留了三种元数据,命令空间(整个文件系统的目录结构和chunk的基本信息)、文件到chunk之间的映射、chunk副本的位置信息(一般会有3个副本);Master总是先记录操作日志然后修改内存,故障时Master可以通过操作日志恢复,定期的checkpoint可以降低回放的日志量.</p>
</blockquote>
<ul>
<li>热备份</li>
</ul>
<blockquote>
<p>GFS所有对于元数据的修改够必须保证发送到实时热备份,才算成功,如果Master宕机可以秒级切换到热备份.同时通过Chubby服务选主操作保证只有一台Master.</p>
</blockquote>
<p>ChunkServer 容错</p>
<blockquote>
<p>GFS通过复制多个副本实现对于ChunkServer的容错.对于每个chunk,必须将所有的副本都写入成功才视为成功写入,如果相关副本丢失或者不可恢复,master会自动将副本复制到其他ChunkServer,确保副本数量达到标准.同时ChunkServer还会对存储的数据位置校验和,保证副本数据正确.</p>
</blockquote>
<h4 id="413-master设计">4.1.3 Master设计</h4>
<ol>
<li>
<p>Master 内存占用<br>
Master系统中维护了系统的元数据,包括文件和chunk命令空间、文件到chunk的映射以及chunk副本的位置,前两者需要持久化到磁盘,而后者不需要持久化,可以通过ChunkServer回到获取最新信息.<br>
内存是稀缺资源,我们需要估算Master的内存使用量.<br>
文中通过论证(chunk元数据的构成),得出结论:Master的内存容量不会成为GFS的系统瓶颈.</p>
</li>
<li>
<p>负载均衡<br>
GFS中副本的分布策略需要考虑多种因素,如网络拓扑、机架分布、磁盘利用率等.为了提高系统的可用性,GFS会避免将同一个chunk的副本放置在同一个机架.<br>
在系统中,以下三种情况会创建chunk副本:chunk创建、chunk复制、负载均衡.<br>
chunk在创建时,选择副本的初始位置会考虑以下因素</p>
</li>
</ol>
<ul>
<li>新副本所在的ChunkServer的磁盘利用率低于平均水平</li>
<li>限制每个ChunKServer最近创建副本的数量(避免新加入的机器创建过多副本)</li>
<li>chunk的副本不能过于集中</li>
</ul>
<p>当chunk副本数量小于一定数量时,Master会尝试复制一个chunk副本.<br>
同时,Master会定时扫描当前副本的分布情况,如果发现磁盘使用量或者机器负载不均衡,将再次执行负载均衡操作.</p>
<ol start="3">
<li>
<p>垃圾回收<br>
GFS采用延迟删除的机制,在操作删除文件之后,GFS并不要求立刻归还可用的物理存储,而是在Master元数据中将文件名改为一个隐藏的名称,并包含一个删除时间戳.Master在后续的定时检查中,超过时间戳就会将之从内存中删除,在后续与ChunkServer心跳交互中,Master会回复已经不存在与Master元数据中的chunk信息,此时ChunkServer会释放这些chunk副本.同时chunk副本版本号低也会被Master通过垃圾回收删除.<br>
为了减轻系统的负载,垃圾回收一般在服务低峰期进行.</p>
</li>
<li>
<p>快照<br>
快照操作是对源文件/目录进行操作,生成此刻该源文件/目录的一个瞬间状态存在于目标文件或者目录中.<br>
GFS采用标准的写时复制机制生成快照,即在未写时,快照操作仅仅增加GFS中chunk的引用计数,表示该chunk被快照文件引用了,当修改时,需要在ChunkServer上拷贝chunk的数据生成新的chunk,后续得修改操作都落在新生成的chunk和是哪个.<br>
实际快照操作中涉及很多步骤,比如需要事先收回对于chunk的写操作权限的租约,Master需要生成新的chunk元数据,对于执行快照的文件的所有chunk增减引用计数.</p>
</li>
</ol>
<h4 id="414-chunkserver设计">4.1.4 ChunkServer设计</h4>
<p>ChunkServer管理大小为64MB的chunk,存储时需要保证chunk尽量均匀的分布在不同的磁盘,需要考虑的因素包括磁盘空间、最近新建chunk数等.<br>
同时,Linux文件系统删除64MB大文件消耗时间长,所有可以将该chunk移动至磁盘回收站,新建chunk时可以重用.<br>
ChunkServer是磁盘和网络IO密集的应用,应当做到磁盘和网络操作异步化,以最大限度发挥机器性能,但是也增加了编程难度.</p>
<h4 id="415-讨论">4.1.5 讨论</h4>
<p>GFS是一个具有良好扩展性并且能够在软件层面自动处理各种异常情况的系统.<br>
这种自动化对于容错能力有很高的要求,在实际编程中,也要考虑各种异常情况并加以处理.<br>
此外单Master的可行性在GFS得到印证,单Master简化了系统实现,提高工作效率,同时也有相关的日志、热备机制保证单Master的可用性.</p>
<h3 id="42-taobao-file-system">4.2 Taobao File System</h3>
<p>互联网应用经常要存储用户上传的文档、图片、视频等,例如Facebook相册、淘宝图片、Dropbox文档等等.<br>
文档、图片、视频一般称为Blob(Binary Large Object)数据,存储Blob数据的文件系统也相应称为Blob存储系统.<br>
Blob文件系统的特点在于数据写入后基本都是只读,很少出现更新操作.</p>
<p>由于淘宝数据量大且增长很快,由于性能和成本的考虑,淘宝自研了TFS系统.<br>
TFS架构设计时考虑如下两个问题:</p>
<ul>
<li>Metadata信息存储.由于图片数据巨大,单机存放不了所有的元数据信息,假设每个图片的元数据占用100字节,100亿图片的元数据占用的空间就是1TB,单机无法提供元数据存储和其他服务.</li>
<li>减少图片读取的IO次数.普通的Linux文件系统,读取一个文件一般需要三次磁盘IO:首先读取目录元数据到内存,其次将文件的inode节点装载到内存,最后读取实际的文件内容.但是TFS的小文件个数太多,无法将所有目录及文件的inode信息缓存到内存,因此磁盘IO次数很难达到每个图片读取只需要一个磁盘IO的理想状态.<br>
因此,TFS采取的思路是:<strong>多个逻辑图片文件共享一个物理文件</strong>.</li>
</ul>
<h4 id="421-系统架构">4.2.1 系统架构</h4>
<p>由于TFS文件之间往往 不存在连续,所以相对于GFS,它不维护文件目录树,每个小文件使用64位的编号表示;同时,鉴于TFS数据读多写少的特点,TFS的写流程更加简单.</p>
<p>详细内容可看书籍</p>
<h4 id="422-讨论">4.2.2 讨论</h4>
<p>图片应用中有几个问题,首先是图片去重,然后是图片更新和删除.<br>
去重</p>
<blockquote>
<p>由于用户会上传大量相同的照片,因此上传到TFS之前,需要去重;<br>
一般在外部维护一套文件级别的去重系统,采用MD5或者SHA1等Hash算法为图片文件计算指纹(FingerPrint).</p>
</blockquote>
<p>更新</p>
<blockquote>
<p>图片的更新操作是在TFS中写入新图片,并在应用系统的数据库内保存新图片的位置,图片的删除操作仅仅在应用系统中将图片删除.<br>
图片在TFS中的位置是通过&lt; Block id,Block offset&gt; 标识的,因此每个Block中只要有一个有效的文件,整个Block就无法回收.</p>
</blockquote>
<h3 id="43-facebook-haystack">4.3 Facebook Haystack</h3>
<p>Facebook目前存储了2600亿张图片,总大小为20PB,平均每张80KB,每周新增照片为10亿(总大小为60TB),大约每秒3500次新增/写操作,读操作峰值可达每秒百万次.</p>
<h4 id="431-系统架构">4.3.1 系统架构</h4>
<p>其设计思路与TFS类似,也是多个逻辑文件共享一个物理文件.<br>
Haystack系统主要分为三个部分,目录(Directory)、存储(Storage)以及缓存(Cache).</p>
<p>详情见书籍</p>
<h4 id="432-讨论">4.3.2 讨论</h4>
<h3 id="44-内容分发网络-cdn">4.4 内容分发网络 CDN</h3>
<p>CDN通过将网络内容发布到靠近用户的边缘节点,使不同地域的用户在访问相同网页时可以就近获得内容,既可以减轻原服务器的负载,也可以减轻整个网络中分布不均匀的情况,进而改善网络性能.</p>
<p>在CDN中,DNS在对域名解析时不再向用户返回源服务器的IP,而是返回某个由智能CDN负载均衡系统选定的某个边缘节点的IP;用户利用这个IP访问边缘节点,然后该节点通过内部DNS解析获得源服务器IP并请求获取所需页面或者内容,如果成功,边缘节点会缓存数据,下次用户访问可以直接读取,不需要每次都访问源服务器.</p>
<h4 id="441-cdn-架构">4.4.1 CDN 架构</h4>
<p>大致构成是分级cache+多级负载均衡(四层:ip+port 和 七层:url),详细内容见书籍</p>
<p>其他优化</p>
<ul>
<li>分级存储:由于缓存数据具有较高的局部性,在squid服务器(源服务器的缓存服务器)上使用SSD+SAS+SATA 混合存储,图片随着热点变化而迁移,最热门的存储到SSD,中等热度的存储到SAS,轻热度的存储到SATA,通过这样的方式可以很好的结合SSD的性能和SAS、SATA磁盘的成本优势.</li>
<li>低功耗服务器定制:CDN缓存服务是IO密集型而不是CPU密集型服务,因而采用定制服务器降低整体功耗.</li>
</ul>
<h4 id="442-讨论">4.4.2 讨论</h4>
<p>由于Blob存储系统读访问量大,更新或者删除很少,适合通过CDN技术分发到距离用户更近的节点.<br>
同时需要注意的CDN是一种缓存系统,不能实现与源服务器的强一致性,源服务器更新或者删除Blob数据,不能及时反映到CDN节点中.<br>
此外,随着硬件发展,SSD价格不断下降,分级存储的优势不再明显,目前已经全部配置SSD.</p>
<h2 id="第五章-分布式键值系统">第五章 分布式键值系统</h2>
<p>分布式键值模型可以看做分布式表格模型的一种特例,它只支持对单个key-value的增删改查,因此适合用3.3.1中提到的哈希分布算法.<br>
Amazon Dynamo 是分布式键值系统,最初用于支持购物车应用.<br>
Tair是淘宝开发的分布式键值系统,借鉴了Dynamo系统的一些设计思路并作出创新,其中最大的变化是从P2P架构修改为带有中心节点的架构.</p>
<h3 id="51-amazon-dynamo">5.1 Amazon Dynamo</h3>
<p>Dynamo以简单的键值方式存储数据,不支持复杂的查询.<br>
Dynamo主要用于Amazon的购物车以及S3云存储服务.<br>
Dynamo通过组合P2P的各种技术大打造了线上可运行的分布式键值系统,对于设计时面临的问题提出了自己的解决方案.</p>
<ul>
<li>使用改进的一致性哈希(虚拟节点)解决数据分布问题.</li>
<li>使用复制写协议(Reolicated-write protocol,NWR参数可调)作为复制协议.</li>
<li>通过向量时钟处理数据冲突问题.</li>
<li>通过数据回传机制(Hinted handoff)处理临时故障.</li>
<li>基于Merkle哈希树,在永久故障后恢复数据</li>
<li>基于Gossip实现成员资格和错误检测</li>
</ul>
<h4 id="511-数据分布">5.1.1 数据分布</h4>
<p>Dynamo 采用一致性哈希算法将数据分布到多个存储节点中;</p>
<p>由于节点的异构性,不同节点的处理能力差异很大,因此Dynamo采用了改进的一致性哈希算法:每个物理节点根据其性能的差异分配多个token,每个token对应一个虚拟节点,而每个虚拟节点的处理能力基本相当,随机分布在哈希空间中.存储时,数据按照哈希值落到某个虚拟节点负责的区域,然后被存储在该虚拟节点所对应的物理节点中.</p>
<p>同时为了找到数据所属的物理节点，要求每个节点维持一定的集群信息用于定位。Dynamo要求每个节点维护整个集群的信息，客户端也缓存整个集群的信息，因此大部分请求可以一次定位到目标节点。</p>
<p>由于机器或者人为因素，系统中的节点成员加入或者退出经常发生，Wie拉堡镇每个节点缓存的都是Dynamo集群中最新的成员信息，所有节点每隔固定时间会通过Gossip协议的方式与其他节点中任意一个连接，并交互信息。</p>
<p>Gossip协议用于P2P系统中自治的节点协调对整个集群的认识，比如集群的节点状态、负载情况。</p>
<p>节点的加入和退出或者其他信息变更都会引起周围节点信息的变更，进而按照Gossip协议扩散到整个集群。同时，考虑到节点退出的可能，定期相邻节点交换信息可以尽快扩散该信息。</p>
<h4 id="512-一致性和复制">5.1.2 一致性和复制</h4>
<p>为了处理节点失效的情况，需要对节点中的数据进行复制备份；<br>
假设对于任意的一份数据，共有N份备份，如果有一个备份数据所在的节点宕机，那么经过gossip协议获知后，会寻找一个节点代替该节点的作用，负责记录宕机节点的写操作；如果该节点永久失效，需要利用<a href="/2020/11/27/基础知识/数据结构/Merkle树/" title="Merkle树">Merkle树</a>对于该节点的数据文件快速同步。</p>
<p>NWR在Dynamo中提高读写的效率:N标识复制的备份数，R指成功读操作的最少节点数，W表示成功写操作的最少节点数；只要满足W+R&gt;N,那么可以保证宕机数目不超富哦N-W-R-1的情况下，写的数据必然可以被读到；</p>
<p>NWR 也有一些缺陷。在Dynamo这样的P2P集群中，每个节点存储的集群信息同一时刻并不一定一致(比如，某个数据文件对应的备份节点顺序不一致)，在同一条记录被多个节点同时更新的情况下，无法保证多个节点之间更新顺序。因此，Dynamo引入向量时钟(Vector Clock)的技术手段尝试解决冲突。</p>
<p>向量时钟用 [ nodes,counter ] 对表示。其中nodes表示节点，counter是一个计数器，初始为0，节点每次更新操作加1。首先Sx对某个对象进行一次写操作，产生一个对象版本D1([ Sx,1 ]),接着Sx继续操作，counter值更新为2，产生第二个版本D2([ Sx,2 ]);之后 ，Sy与Sz同时对该对象进行写操作，Sy将自身的信息加入向量时钟产生了新的版本 D3([ Sx,2 ],[ Sy,1 ]),Sz产生了新的版本信息 D4([ Sx,2 ],[ Sz,1 ]),如何产生了冲突的版本D3和D4，有两种解决方法：一种是一阿里客户端逻辑解决或者根据时间戳来确定(选择最新的副本,但是如何保证集群内节点之间的时间同步算法准确性又是另一个问题).</p>
<p>向量时钟并不能解决版本冲突的问题，Dynamo只能保证最终一致性。</p>
<h4 id="513-容错">5.1.3 容错</h4>
<p>Dynamo 把异常分为两种类型:临时性的异常(比如机器假死)和永久性的异常(比如硬盘保修或机器报废等)。其容错机制包括</p>
<ul>
<li>数据回传</li>
</ul>
<blockquote>
<p>在Dynamo的设计中，一份数据有多个备份，被写到多个机器节点，如果某一台机器宕机，会有另外一台机器代替他的功能，原本写到该机器的数据会写到这台机器；如果宕机的机器恢复，替代的机器通过Gossip协议发现后，会启动传输任务将暂存的数据回传给宕机的机器。</p>
</blockquote>
<ul>
<li>Merkle树同步</li>
</ul>
<blockquote>
<p>如果超过一定时间，机器仍然处于宕机状态，那就认为该机器不可恢复。此时需要借助Merkle树机制从其他副本进行数据同步。每台机器对每一段范围的数据维护一颗Merkle树，机器同步时首先传输Merkle树信息，并且只需要同步从根到叶子节点的所有节点值均不相同的文件。</p>
</blockquote>
<ul>
<li>读取修复</li>
</ul>
<blockquote>
<p>在NWR中，假设 N=3,W=2,R=2,某个机器K宕机，可能有部分写操作已经返回客户端成功了，但是并没有同步到所有的副本，如果机器K出现永久性异常，比如磁盘故障，三个副本间的数据不一致。客户端的读取操作，会发现不一致，则启动异步的读取修复任务。该任务会合并多个副本的数据，并使用合并后的结果更新过期的副本，从而使副本保持一致。</p>
</blockquote>
<h4 id="514-负载均衡">5.1.4 负载均衡</h4>
<p>Dynamo 使用一致性Hash算法，其负载均衡取决于如何给每台分配虚拟节点号，即token。由于集群环境的异构性，每台物理机器包含多个虚拟节点。一般有两种分配方法。</p>
<ul>
<li>随机分配</li>
</ul>
<blockquote>
<p>每个物理节点加入时根据其配置情况分配若干个token。<br>
这种方法可控性较差，每个物理节点分配的虚拟节点很分散，当节点加入/离开系统时，集群中的原有节点都需要扫描所有的数据从而找到属于新节点的需要复制的数据，Merkle树也需要全部更新；此外，增量归档/备份变得不可能。</p>
</blockquote>
<ul>
<li>数据范围等分+随机分配</li>
</ul>
<blockquote>
<p>为了来解决以上问题，首先将数据的哈希空间等分为Q=NxS份(N=机器个数,S=每台机器的虚拟节点数)，然后每台机器随机选择S个虚拟节点作为token；这种方法较为均衡，而且每台机器可以对每个范围的数据维护逻辑上的Merkle树，新节点的加入/离开时只需扫描部分数据进行同步即可，并更新这部分数据对应的逻辑Merkle树，增量归档也变得简单。</p>
</blockquote>
<h4 id="515-读写流程">5.1.5 读写流程</h4>
<p>去中心化<br>
写数据</p>
<blockquote>
<p>Dynamo写入数据时，首先根据一致性哈希算法算出每个数据副本所在的存储节点，选出其中一个作为本次写操作的协调者。紧接着，该协调者并发的向所有其他副本发送写请求，每个副本包括协调者将接受的数据写入本地。当节点将副本写入本地之后，会回复协调者，如果失败，些日哦阿哲会将之加入重试列表不断重试。直到包括协调者的W个副本写入成功，协调者回复客户端写入成功。协调者回复成功后，还会继续等待或者重试，知道所有的副本都写入成功。</p>
</blockquote>
<p>读数据</p>
<blockquote>
<p>Dynamo读取数据时，首先根据一致性哈希算法计算出每个副本所在的存储节点，选择其中一个作为协调者。接着，协调者根据负载策略选择R个副本，并发的向它们所在节点发送读请求，每个节点包括协调者读取本地数据，读取成功后恢回复协调者读取结果，等待R个副本读取成功后，协调者可以回复客户端。<br>
这里由具体的分为两种情况，如果R个副本返回的数据完全一致，那么直接将某个副本的读取结构返回客户端即可，否则需要依据冲突处理规则合并多个副本的读取结果。</p>
</blockquote>
<h4 id="516-单机实现">5.1.6 单机实现</h4>
<p>Dynamo 存储节点包括三个组件：请求协调、成员和故障检测、存储引擎。</p>
<h4 id="517-讨论">5.1.7 讨论</h4>
<p>Dynamo 采用无中心化的P2P设计，增加了系统可扩展性，但是也带来了一致性的问题，需要上层应用加以处理。</p>
<h3 id="52-淘宝-tair">5.2 淘宝 Tair</h3>
<p>Tair是淘宝开发的一个分布式键值存储引擎。<br>
Tair分为持久化和非持久化两种使用方式，非持久化的Tair可以看做一个分布式缓存，持久化的Tair数据存放于磁盘中。</p>
<h4 id="521-系统架构">5.2.1 系统架构</h4>
<p>Tair作为分布式系统，由一个中心控制节点和若干个服务节点组成，其中中心控制节点成为Config Server，服务节点成为Data Server。<br>
Config Server 负责管理所有的Data Server,Data Server 对外提供各种数据服务，并以心跳的方式将自身状况汇报给Config Server。<br>
Config Server 是单点控制点，使用一主一备保证可靠性。</p>
<p>客户端首先请求Config Server 获取数据所在的 Data Server，然后向Data Server发送读写请求。Tair将数据存放在多台Data Server中，实现异常容错。</p>
<h4 id="522-关键问题">5.2.2 关键问题</h4>
<ol>
<li>
<p>数据分布<br>
根据数据的主键计算哈希值后，分配到Q个桶中，桶是负载均衡和数据迁移的基本单位。<br>
Config Server 依照一定的策略将每个桶指派到不同的Data Server上。</p>
</li>
<li>
<p>容错<br>
当某个Data Server 不可用时，Config Server 可以检测到。每个哈希桶在Tair中有多个副本，如果是备副本，Config Server 会重新指定一台Data Server，如果是持久化存储，还会复制数据到新的Data Server上。如果是主副本，Config Server 会将备副本中某个正常的副本提升为主副本，对外提供服务，bong选择另一台Data Server 增加一个备副本。</p>
</li>
<li>
<p>数据迁移<br>
机器的加入/离开或者负载不均衡可能导致桶的迁移，迁移的过程中需要对外保证服务。请求首先指向桶的原有机器，当某个桶未迁移时，请求会由该桶负责，正在迁移时，同样由该桶负责，但会记录写请求，迁移完成后，将写记录发送给迁移的桶，应用修改。迁移完成后会从原桶的机器转发请求到迁移桶的机器。</p>
</li>
<li>
<p>Config Server<br>
客户端缓存路由表，大多数情况下，客户端不需要访问Config Server。<br>
每次路由的变更，Config Server 都会将新的配置信息推给Data Server；当客户端访问Data Server，会发送给客户端路由表的版本号，如果客户端发现自己的版本号过期，那么会访问 Config Server 获取新的路由表，或者当访问 Data Server 不可达时，也会获取新的路由表。</p>
</li>
<li>
<p>Data Server负责数据的存储，并根据Config Server 的要求完成数据的复制和迁移工作。</p>
</li>
</ol>
<h4 id="523">5.2.3</h4>
<p>相对于Dynamo的P2P结构，Tair引入了中心节点Config Server，更容易处理数据的一致性问题。</p>
<h2 id="第6章-分布式表格系统">第6章 分布式表格系统</h2>
<p>分布式表格系统对外提供表格模型，每个表格由很多行组成，通过主键唯一标识，每一行包含很多列。整个表格在系统中全局有序，适用于3.3.2节中的顺序分布。<br>
Google Bigtable 是分布式表格系统的始祖，它采用双层结构，底层采用GFS作为持久化存储层。GFS+Bigtable 双层结构是一种里程碑式的架构，其他系统包括Microsoft 分布式存储系统 Windows Azure Storage以及开源的Hadoop系统，均为其模仿者。<br>
Bigtable的问题在于对外接口不够丰富，因此，Google后续开发了两台系统，一套是Megastore，构建于Bigtable之上，提供更加丰富的接口支持；另一套是Spanner，支持跨多个数据中心数据库事务。<br>
本章主要介绍Bigtable的架构及实现，接着分析Megastore的架构最后介绍Microsoft Azure Storage的架构。</p>
<h3 id="61-google-bigtable">6.1 Google Bigtable</h3>
<h3 id="62-google-megastore">6.2 Google Megastore</h3>
<h3 id="63-windows-azure-storage">6.3 Windows Azure Storage</h3>
<h2 id="第7章-分布式数据库">第7章 分布式数据库</h2>
<h2 id="第8章-oceanbase-架构初探">第8章 OceanBase 架构初探</h2>
<p><a href="https://www.oceanbase.com/community" target="_blank" rel="noopener">OceanBase 社区</a><br>
<a href="https://github.com/tobato/oceanbase" target="_blank" rel="noopener">OceanBase Github</a></p>
<h2 id="第9章-分布式存储引擎">第9章 分布式存储引擎</h2>
<h2 id="第10章-数据库功能">第10章 数据库功能</h2>
<h2 id="第11章-质量保证-运维及实践">第11章 质量保证、运维及实践</h2>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/书籍/" rel="tag"># 书籍</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/19/分布式/chubby/" rel="prev" title="chubby分布式锁服务">
      <i class="fa fa-chevron-left"></i> chubby分布式锁服务
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/11/24/分布式/MIT6.824/Readme/" rel="next" title="">
       <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#第1章-概述"><span class="nav-number">1.</span> <span class="nav-text">第1章 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式存储分类"><span class="nav-number">1.2.</span> <span class="nav-text">分布式存储分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分布式文件系统"><span class="nav-number">1.2.1.</span> <span class="nav-text">分布式文件系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分布式键值系统"><span class="nav-number">1.2.2.</span> <span class="nav-text">分布式键值系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分布式表格系统"><span class="nav-number">1.2.3.</span> <span class="nav-text">分布式表格系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分布式数据库"><span class="nav-number">1.2.4.</span> <span class="nav-text">分布式数据库</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第2章-单机存储系统"><span class="nav-number">2.</span> <span class="nav-text">第2章 单机存储系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#21-硬件基础"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 硬件基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-单机存储引擎"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 单机存储引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#221-哈希存储引擎"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1 哈希存储引擎</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#222-b树存储引擎"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2 B树存储引擎</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#223-lsm树存储引擎"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.2.3 LSM树存储引擎</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-数据模型"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 数据模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#231-文件模型"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3.1 文件模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#232-关系模型"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.3.2 关系模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#233-键值模型"><span class="nav-number">2.3.3.</span> <span class="nav-text">2.3.3 键值模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#234-sql-和-nosql"><span class="nav-number">2.3.4.</span> <span class="nav-text">2.3.4 SQL 和 NOSQL</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-事务和并发控制"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 事务和并发控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-故障恢复"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 故障恢复</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#251-操作日志"><span class="nav-number">2.5.1.</span> <span class="nav-text">2.5.1 操作日志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#252-重做日志"><span class="nav-number">2.5.2.</span> <span class="nav-text">2.5.2 重做日志</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-数据压缩"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 数据压缩</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#261-压缩算法"><span class="nav-number">2.6.1.</span> <span class="nav-text">2.6.1 压缩算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#262-列式存储"><span class="nav-number">2.6.2.</span> <span class="nav-text">2.6.2 列式存储</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第3章-分布式存储系统"><span class="nav-number">3.</span> <span class="nav-text">第3章 分布式存储系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#31-基本概念"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#311-异常"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.1 异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#312-一致性"><span class="nav-number">3.1.2.</span> <span class="nav-text">3.1.2 一致性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#313-衡量标准"><span class="nav-number">3.1.3.</span> <span class="nav-text">3.1.3 衡量标准</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-性能分析"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 性能分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33-数据分布"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 数据分布</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#331-哈希分布"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.3.1 哈希分布</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#332-顺序分布"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.3.2 顺序分布</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#333-负载均衡"><span class="nav-number">3.3.3.</span> <span class="nav-text">3.3.3 负载均衡</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34-复制"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 复制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#341-复制的概述"><span class="nav-number">3.4.1.</span> <span class="nav-text">3.4.1 复制的概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#342-一致性和可用性"><span class="nav-number">3.4.2.</span> <span class="nav-text">3.4.2 一致性和可用性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#35-容错"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 容错</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#351-常见故障"><span class="nav-number">3.5.1.</span> <span class="nav-text">3.5.1 常见故障</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#352-故障检测"><span class="nav-number">3.5.2.</span> <span class="nav-text">3.5.2 故障检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#353-故障恢复"><span class="nav-number">3.5.3.</span> <span class="nav-text">3.5.3 故障恢复</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#36-可扩展性"><span class="nav-number">3.6.</span> <span class="nav-text">3.6 可扩展性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#361-总控节点"><span class="nav-number">3.6.1.</span> <span class="nav-text">3.6.1 总控节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#362-数据库扩容"><span class="nav-number">3.6.2.</span> <span class="nav-text">3.6.2 数据库扩容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#363-异构系统"><span class="nav-number">3.6.3.</span> <span class="nav-text">3.6.3 异构系统</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#37-分布式协议"><span class="nav-number">3.7.</span> <span class="nav-text">3.7 分布式协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#371-两阶段提交协议"><span class="nav-number">3.7.1.</span> <span class="nav-text">3.7.1 两阶段提交协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#372-paxos"><span class="nav-number">3.7.2.</span> <span class="nav-text">3.7.2 Paxos</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#373-paxos-和-2pc"><span class="nav-number">3.7.3.</span> <span class="nav-text">3.7.3 Paxos 和 2PC</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#38-跨机房部署"><span class="nav-number">3.8.</span> <span class="nav-text">3.8  跨机房部署</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第4章-分布式文件系统"><span class="nav-number">4.</span> <span class="nav-text">第4章 分布式文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#41-gfs"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 GFS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#411-系统架构"><span class="nav-number">4.1.1.</span> <span class="nav-text">4.1.1 系统架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#412-关键问题"><span class="nav-number">4.1.2.</span> <span class="nav-text">4.1.2 关键问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#413-master设计"><span class="nav-number">4.1.3.</span> <span class="nav-text">4.1.3 Master设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#414-chunkserver设计"><span class="nav-number">4.1.4.</span> <span class="nav-text">4.1.4 ChunkServer设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#415-讨论"><span class="nav-number">4.1.5.</span> <span class="nav-text">4.1.5 讨论</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-taobao-file-system"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 Taobao File System</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#421-系统架构"><span class="nav-number">4.2.1.</span> <span class="nav-text">4.2.1 系统架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#422-讨论"><span class="nav-number">4.2.2.</span> <span class="nav-text">4.2.2 讨论</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#43-facebook-haystack"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 Facebook Haystack</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#431-系统架构"><span class="nav-number">4.3.1.</span> <span class="nav-text">4.3.1 系统架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#432-讨论"><span class="nav-number">4.3.2.</span> <span class="nav-text">4.3.2 讨论</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#44-内容分发网络-cdn"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 内容分发网络 CDN</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#441-cdn-架构"><span class="nav-number">4.4.1.</span> <span class="nav-text">4.4.1 CDN 架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#442-讨论"><span class="nav-number">4.4.2.</span> <span class="nav-text">4.4.2 讨论</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五章-分布式键值系统"><span class="nav-number">5.</span> <span class="nav-text">第五章 分布式键值系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#51-amazon-dynamo"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 Amazon Dynamo</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#511-数据分布"><span class="nav-number">5.1.1.</span> <span class="nav-text">5.1.1 数据分布</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#512-一致性和复制"><span class="nav-number">5.1.2.</span> <span class="nav-text">5.1.2 一致性和复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#513-容错"><span class="nav-number">5.1.3.</span> <span class="nav-text">5.1.3 容错</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#514-负载均衡"><span class="nav-number">5.1.4.</span> <span class="nav-text">5.1.4 负载均衡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#515-读写流程"><span class="nav-number">5.1.5.</span> <span class="nav-text">5.1.5 读写流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#516-单机实现"><span class="nav-number">5.1.6.</span> <span class="nav-text">5.1.6 单机实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#517-讨论"><span class="nav-number">5.1.7.</span> <span class="nav-text">5.1.7 讨论</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#52-淘宝-tair"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 淘宝 Tair</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#521-系统架构"><span class="nav-number">5.2.1.</span> <span class="nav-text">5.2.1 系统架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#522-关键问题"><span class="nav-number">5.2.2.</span> <span class="nav-text">5.2.2 关键问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#523"><span class="nav-number">5.2.3.</span> <span class="nav-text">5.2.3</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第6章-分布式表格系统"><span class="nav-number">6.</span> <span class="nav-text">第6章 分布式表格系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#61-google-bigtable"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 Google Bigtable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#62-google-megastore"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 Google Megastore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#63-windows-azure-storage"><span class="nav-number">6.3.</span> <span class="nav-text">6.3 Windows Azure Storage</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第7章-分布式数据库"><span class="nav-number">7.</span> <span class="nav-text">第7章 分布式数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第8章-oceanbase-架构初探"><span class="nav-number">8.</span> <span class="nav-text">第8章 OceanBase 架构初探</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第9章-分布式存储引擎"><span class="nav-number">9.</span> <span class="nav-text">第9章 分布式存储引擎</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第10章-数据库功能"><span class="nav-number">10.</span> <span class="nav-text">第10章 数据库功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第11章-质量保证-运维及实践"><span class="nav-number">11.</span> <span class="nav-text">第11章 质量保证、运维及实践</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">chengr</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">97</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">京ICP备2020045262号 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chengr</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
